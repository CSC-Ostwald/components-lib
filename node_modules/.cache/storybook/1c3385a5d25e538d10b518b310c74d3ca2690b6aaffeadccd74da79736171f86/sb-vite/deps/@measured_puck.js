import {
  require_react_dom
} from "./chunk-K6TDD2WV.js";
import {
  require_jsx_runtime
} from "./chunk-T5ADJFKO.js";
import {
  require_react
} from "./chunk-4UH3PDUB.js";
import {
  v4_default
} from "./chunk-W6XPILYN.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/dist/object_hash.js"(exports, module) {
    !function(e3) {
      var t3;
      "object" == typeof exports ? module.exports = e3() : "function" == typeof define && define.amd ? define(e3) : ("undefined" != typeof window ? t3 = window : "undefined" != typeof global ? t3 = global : "undefined" != typeof self && (t3 = self), t3.objectHash = e3());
    }(function() {
      return function r3(o2, i2, u3) {
        function s2(n3, e4) {
          if (!i2[n3]) {
            if (!o2[n3]) {
              var t3 = "function" == typeof __require && __require;
              if (!e4 && t3) return t3(n3, true);
              if (a2) return a2(n3, true);
              throw new Error("Cannot find module '" + n3 + "'");
            }
            e4 = i2[n3] = { exports: {} };
            o2[n3][0].call(e4.exports, function(e5) {
              var t4 = o2[n3][1][e5];
              return s2(t4 || e5);
            }, e4, e4.exports, r3, o2, i2, u3);
          }
          return i2[n3].exports;
        }
        for (var a2 = "function" == typeof __require && __require, e3 = 0; e3 < u3.length; e3++) s2(u3[e3]);
        return s2;
      }({ 1: [function(w2, b2, m) {
        !(function(e3, n3, s2, c3, d2, h2, p2, g2, y2) {
          "use strict";
          var r3 = w2("crypto");
          function t3(e4, t4) {
            t4 = u3(e4, t4);
            var n4;
            return void 0 === (n4 = "passthrough" !== t4.algorithm ? r3.createHash(t4.algorithm) : new l2()).write && (n4.write = n4.update, n4.end = n4.update), f2(t4, n4).dispatch(e4), n4.update || n4.end(""), n4.digest ? n4.digest("buffer" === t4.encoding ? void 0 : t4.encoding) : (e4 = n4.read(), "buffer" !== t4.encoding ? e4.toString(t4.encoding) : e4);
          }
          (m = b2.exports = t3).sha1 = function(e4) {
            return t3(e4);
          }, m.keys = function(e4) {
            return t3(e4, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m.MD5 = function(e4) {
            return t3(e4, { algorithm: "md5", encoding: "hex" });
          }, m.keysMD5 = function(e4) {
            return t3(e4, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o2 = r3.getHashes ? r3.getHashes().slice() : ["sha1", "md5"], i2 = (o2.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u3(e4, t4) {
            var n4 = {};
            if (n4.algorithm = (t4 = t4 || {}).algorithm || "sha1", n4.encoding = t4.encoding || "hex", n4.excludeValues = !!t4.excludeValues, n4.algorithm = n4.algorithm.toLowerCase(), n4.encoding = n4.encoding.toLowerCase(), n4.ignoreUnknown = true === t4.ignoreUnknown, n4.respectType = false !== t4.respectType, n4.respectFunctionNames = false !== t4.respectFunctionNames, n4.respectFunctionProperties = false !== t4.respectFunctionProperties, n4.unorderedArrays = true === t4.unorderedArrays, n4.unorderedSets = false !== t4.unorderedSets, n4.unorderedObjects = false !== t4.unorderedObjects, n4.replacer = t4.replacer || void 0, n4.excludeKeys = t4.excludeKeys || void 0, void 0 === e4) throw new Error("Object argument required.");
            for (var r4 = 0; r4 < o2.length; ++r4) o2[r4].toLowerCase() === n4.algorithm.toLowerCase() && (n4.algorithm = o2[r4]);
            if (-1 === o2.indexOf(n4.algorithm)) throw new Error('Algorithm "' + n4.algorithm + '"  not supported. supported values: ' + o2.join(", "));
            if (-1 === i2.indexOf(n4.encoding) && "passthrough" !== n4.algorithm) throw new Error('Encoding "' + n4.encoding + '"  not supported. supported values: ' + i2.join(", "));
            return n4;
          }
          function a2(e4) {
            if ("function" == typeof e4) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e4));
          }
          function f2(o3, t4, i3) {
            i3 = i3 || [];
            function u4(e4) {
              return t4.update ? t4.update(e4, "utf8") : t4.write(e4, "utf8");
            }
            return { dispatch: function(e4) {
              return this["_" + (null === (e4 = o3.replacer ? o3.replacer(e4) : e4) ? "null" : typeof e4)](e4);
            }, _object: function(t5) {
              var n4, e4 = Object.prototype.toString.call(t5), r4 = /\[object (.*)\]/i.exec(e4);
              r4 = (r4 = r4 ? r4[1] : "unknown:[" + e4 + "]").toLowerCase();
              if (0 <= (e4 = i3.indexOf(t5))) return this.dispatch("[CIRCULAR:" + e4 + "]");
              if (i3.push(t5), void 0 !== s2 && s2.isBuffer && s2.isBuffer(t5)) return u4("buffer:"), u4(t5);
              if ("object" === r4 || "function" === r4 || "asyncfunction" === r4) return e4 = Object.keys(t5), o3.unorderedObjects && (e4 = e4.sort()), false === o3.respectType || a2(t5) || e4.splice(0, 0, "prototype", "__proto__", "constructor"), o3.excludeKeys && (e4 = e4.filter(function(e5) {
                return !o3.excludeKeys(e5);
              })), u4("object:" + e4.length + ":"), n4 = this, e4.forEach(function(e5) {
                n4.dispatch(e5), u4(":"), o3.excludeValues || n4.dispatch(t5[e5]), u4(",");
              });
              if (!this["_" + r4]) {
                if (o3.ignoreUnknown) return u4("[" + r4 + "]");
                throw new Error('Unknown object type "' + r4 + '"');
              }
              this["_" + r4](t5);
            }, _array: function(e4, t5) {
              t5 = void 0 !== t5 ? t5 : false !== o3.unorderedArrays;
              var n4 = this;
              if (u4("array:" + e4.length + ":"), !t5 || e4.length <= 1) return e4.forEach(function(e5) {
                return n4.dispatch(e5);
              });
              var r4 = [], t5 = e4.map(function(e5) {
                var t6 = new l2(), n5 = i3.slice();
                return f2(o3, t6, n5).dispatch(e5), r4 = r4.concat(n5.slice(i3.length)), t6.read().toString();
              });
              return i3 = i3.concat(r4), t5.sort(), this._array(t5, false);
            }, _date: function(e4) {
              return u4("date:" + e4.toJSON());
            }, _symbol: function(e4) {
              return u4("symbol:" + e4.toString());
            }, _error: function(e4) {
              return u4("error:" + e4.toString());
            }, _boolean: function(e4) {
              return u4("bool:" + e4.toString());
            }, _string: function(e4) {
              u4("string:" + e4.length + ":"), u4(e4.toString());
            }, _function: function(e4) {
              u4("fn:"), a2(e4) ? this.dispatch("[native]") : this.dispatch(e4.toString()), false !== o3.respectFunctionNames && this.dispatch("function-name:" + String(e4.name)), o3.respectFunctionProperties && this._object(e4);
            }, _number: function(e4) {
              return u4("number:" + e4.toString());
            }, _xml: function(e4) {
              return u4("xml:" + e4.toString());
            }, _null: function() {
              return u4("Null");
            }, _undefined: function() {
              return u4("Undefined");
            }, _regexp: function(e4) {
              return u4("regex:" + e4.toString());
            }, _uint8array: function(e4) {
              return u4("uint8array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _uint8clampedarray: function(e4) {
              return u4("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _int8array: function(e4) {
              return u4("int8array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _uint16array: function(e4) {
              return u4("uint16array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _int16array: function(e4) {
              return u4("int16array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _uint32array: function(e4) {
              return u4("uint32array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _int32array: function(e4) {
              return u4("int32array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _float32array: function(e4) {
              return u4("float32array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _float64array: function(e4) {
              return u4("float64array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _arraybuffer: function(e4) {
              return u4("arraybuffer:"), this.dispatch(new Uint8Array(e4));
            }, _url: function(e4) {
              return u4("url:" + e4.toString());
            }, _map: function(e4) {
              u4("map:");
              e4 = Array.from(e4);
              return this._array(e4, false !== o3.unorderedSets);
            }, _set: function(e4) {
              u4("set:");
              e4 = Array.from(e4);
              return this._array(e4, false !== o3.unorderedSets);
            }, _file: function(e4) {
              return u4("file:"), this.dispatch([e4.name, e4.size, e4.type, e4.lastModfied]);
            }, _blob: function() {
              if (o3.ignoreUnknown) return u4("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u4("domwindow");
            }, _bigint: function(e4) {
              return u4("bigint:" + e4.toString());
            }, _process: function() {
              return u4("process");
            }, _timer: function() {
              return u4("timer");
            }, _pipe: function() {
              return u4("pipe");
            }, _tcp: function() {
              return u4("tcp");
            }, _udp: function() {
              return u4("udp");
            }, _tty: function() {
              return u4("tty");
            }, _statwatcher: function() {
              return u4("statwatcher");
            }, _securecontext: function() {
              return u4("securecontext");
            }, _connection: function() {
              return u4("connection");
            }, _zlib: function() {
              return u4("zlib");
            }, _context: function() {
              return u4("context");
            }, _nodescript: function() {
              return u4("nodescript");
            }, _httpparser: function() {
              return u4("httpparser");
            }, _dataview: function() {
              return u4("dataview");
            }, _signal: function() {
              return u4("signal");
            }, _fsevent: function() {
              return u4("fsevent");
            }, _tlswrap: function() {
              return u4("tlswrap");
            } };
          }
          function l2() {
            return { buf: "", write: function(e4) {
              this.buf += e4;
            }, end: function(e4) {
              this.buf += e4;
            }, read: function() {
              return this.buf;
            } };
          }
          m.writeToStream = function(e4, t4, n4) {
            return void 0 === n4 && (n4 = t4, t4 = {}), f2(t4 = u3(e4, t4), n4).dispatch(e4);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e3, t3, f2) {
        !(function(e4, t4, n3, r3, o2, i2, u3, s2, a2) {
          !function(e5) {
            "use strict";
            var a3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t5 = "+".charCodeAt(0), n4 = "/".charCodeAt(0), r4 = "0".charCodeAt(0), o3 = "a".charCodeAt(0), i3 = "A".charCodeAt(0), u4 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
            function f3(e6) {
              e6 = e6.charCodeAt(0);
              return e6 === t5 || e6 === u4 ? 62 : e6 === n4 || e6 === s3 ? 63 : e6 < r4 ? -1 : e6 < r4 + 10 ? e6 - r4 + 26 + 26 : e6 < i3 + 26 ? e6 - i3 : e6 < o3 + 26 ? e6 - o3 + 26 : void 0;
            }
            e5.toByteArray = function(e6) {
              var t6, n5;
              if (0 < e6.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
              var r5 = e6.length, r5 = "=" === e6.charAt(r5 - 2) ? 2 : "=" === e6.charAt(r5 - 1) ? 1 : 0, o4 = new a3(3 * e6.length / 4 - r5), i4 = 0 < r5 ? e6.length - 4 : e6.length, u5 = 0;
              function s4(e7) {
                o4[u5++] = e7;
              }
              for (t6 = 0; t6 < i4; t6 += 4, 0) s4((16711680 & (n5 = f3(e6.charAt(t6)) << 18 | f3(e6.charAt(t6 + 1)) << 12 | f3(e6.charAt(t6 + 2)) << 6 | f3(e6.charAt(t6 + 3)))) >> 16), s4((65280 & n5) >> 8), s4(255 & n5);
              return 2 == r5 ? s4(255 & (n5 = f3(e6.charAt(t6)) << 2 | f3(e6.charAt(t6 + 1)) >> 4)) : 1 == r5 && (s4((n5 = f3(e6.charAt(t6)) << 10 | f3(e6.charAt(t6 + 1)) << 4 | f3(e6.charAt(t6 + 2)) >> 2) >> 8 & 255), s4(255 & n5)), o4;
            }, e5.fromByteArray = function(e6) {
              var t6, n5, r5, o4, i4 = e6.length % 3, u5 = "";
              function s4(e7) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e7);
              }
              for (t6 = 0, r5 = e6.length - i4; t6 < r5; t6 += 3) n5 = (e6[t6] << 16) + (e6[t6 + 1] << 8) + e6[t6 + 2], u5 += s4((o4 = n5) >> 18 & 63) + s4(o4 >> 12 & 63) + s4(o4 >> 6 & 63) + s4(63 & o4);
              switch (i4) {
                case 1:
                  u5 = (u5 += s4((n5 = e6[e6.length - 1]) >> 2)) + s4(n5 << 4 & 63) + "==";
                  break;
                case 2:
                  u5 = (u5 = (u5 += s4((n5 = (e6[e6.length - 2] << 8) + e6[e6.length - 1]) >> 10)) + s4(n5 >> 4 & 63)) + s4(n5 << 2 & 63) + "=";
              }
              return u5;
            };
          }(void 0 === f2 ? this.base64js = {} : f2);
        }).call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O, e3, H) {
        !(function(e4, n3, f2, r3, h2, p2, g2, y2, w2) {
          var a2 = O("base64-js"), i2 = O("ieee754");
          function f2(e5, t4, n4) {
            if (!(this instanceof f2)) return new f2(e5, t4, n4);
            var r4, o3, i3, u4, s3 = typeof e5;
            if ("base64" === t4 && "string" == s3) for (e5 = (u4 = e5).trim ? u4.trim() : u4.replace(/^\s+|\s+$/g, ""); e5.length % 4 != 0; ) e5 += "=";
            if ("number" == s3) r4 = j(e5);
            else if ("string" == s3) r4 = f2.byteLength(e5, t4);
            else {
              if ("object" != s3) throw new Error("First argument needs to be a number, array or string.");
              r4 = j(e5.length);
            }
            if (f2._useTypedArrays ? o3 = f2._augment(new Uint8Array(r4)) : ((o3 = this).length = r4, o3._isBuffer = true), f2._useTypedArrays && "number" == typeof e5.byteLength) o3._set(e5);
            else if (C(u4 = e5) || f2.isBuffer(u4) || u4 && "object" == typeof u4 && "number" == typeof u4.length) for (i3 = 0; i3 < r4; i3++) f2.isBuffer(e5) ? o3[i3] = e5.readUInt8(i3) : o3[i3] = e5[i3];
            else if ("string" == s3) o3.write(e5, 0, t4);
            else if ("number" == s3 && !f2._useTypedArrays && !n4) for (i3 = 0; i3 < r4; i3++) o3[i3] = 0;
            return o3;
          }
          function b2(e5, t4, n4, r4) {
            return f2._charsWritten = c3(function(e6) {
              for (var t5 = [], n5 = 0; n5 < e6.length; n5++) t5.push(255 & e6.charCodeAt(n5));
              return t5;
            }(t4), e5, n4, r4);
          }
          function m(e5, t4, n4, r4) {
            return f2._charsWritten = c3(function(e6) {
              for (var t5, n5, r5 = [], o3 = 0; o3 < e6.length; o3++) n5 = e6.charCodeAt(o3), t5 = n5 >> 8, n5 = n5 % 256, r5.push(n5), r5.push(t5);
              return r5;
            }(t4), e5, n4, r4);
          }
          function v2(e5, t4, n4) {
            var r4 = "";
            n4 = Math.min(e5.length, n4);
            for (var o3 = t4; o3 < n4; o3++) r4 += String.fromCharCode(e5[o3]);
            return r4;
          }
          function o2(e5, t4, n4, r4) {
            r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(null != t4, "missing offset"), d2(t4 + 1 < e5.length, "Trying to read beyond buffer length"));
            var o3, r4 = e5.length;
            if (!(r4 <= t4)) return n4 ? (o3 = e5[t4], t4 + 1 < r4 && (o3 |= e5[t4 + 1] << 8)) : (o3 = e5[t4] << 8, t4 + 1 < r4 && (o3 |= e5[t4 + 1])), o3;
          }
          function u3(e5, t4, n4, r4) {
            r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(null != t4, "missing offset"), d2(t4 + 3 < e5.length, "Trying to read beyond buffer length"));
            var o3, r4 = e5.length;
            if (!(r4 <= t4)) return n4 ? (t4 + 2 < r4 && (o3 = e5[t4 + 2] << 16), t4 + 1 < r4 && (o3 |= e5[t4 + 1] << 8), o3 |= e5[t4], t4 + 3 < r4 && (o3 += e5[t4 + 3] << 24 >>> 0)) : (t4 + 1 < r4 && (o3 = e5[t4 + 1] << 16), t4 + 2 < r4 && (o3 |= e5[t4 + 2] << 8), t4 + 3 < r4 && (o3 |= e5[t4 + 3]), o3 += e5[t4] << 24 >>> 0), o3;
          }
          function _2(e5, t4, n4, r4) {
            if (r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(null != t4, "missing offset"), d2(t4 + 1 < e5.length, "Trying to read beyond buffer length")), !(e5.length <= t4)) return r4 = o2(e5, t4, n4, true), 32768 & r4 ? -1 * (65535 - r4 + 1) : r4;
          }
          function E2(e5, t4, n4, r4) {
            if (r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(null != t4, "missing offset"), d2(t4 + 3 < e5.length, "Trying to read beyond buffer length")), !(e5.length <= t4)) return r4 = u3(e5, t4, n4, true), 2147483648 & r4 ? -1 * (4294967295 - r4 + 1) : r4;
          }
          function I(e5, t4, n4, r4) {
            return r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(t4 + 3 < e5.length, "Trying to read beyond buffer length")), i2.read(e5, t4, n4, 23, 4);
          }
          function A(e5, t4, n4, r4) {
            return r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(t4 + 7 < e5.length, "Trying to read beyond buffer length")), i2.read(e5, t4, n4, 52, 8);
          }
          function s2(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 1 < e5.length, "trying to write beyond buffer length"), Y(t4, 65535));
            o3 = e5.length;
            if (!(o3 <= n4)) for (var i3 = 0, u4 = Math.min(o3 - n4, 2); i3 < u4; i3++) e5[n4 + i3] = (t4 & 255 << 8 * (r4 ? i3 : 1 - i3)) >>> 8 * (r4 ? i3 : 1 - i3);
          }
          function l2(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 3 < e5.length, "trying to write beyond buffer length"), Y(t4, 4294967295));
            o3 = e5.length;
            if (!(o3 <= n4)) for (var i3 = 0, u4 = Math.min(o3 - n4, 4); i3 < u4; i3++) e5[n4 + i3] = t4 >>> 8 * (r4 ? i3 : 3 - i3) & 255;
          }
          function B(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 1 < e5.length, "Trying to write beyond buffer length"), F(t4, 32767, -32768)), e5.length <= n4 || s2(e5, 0 <= t4 ? t4 : 65535 + t4 + 1, n4, r4, o3);
          }
          function L(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 3 < e5.length, "Trying to write beyond buffer length"), F(t4, 2147483647, -2147483648)), e5.length <= n4 || l2(e5, 0 <= t4 ? t4 : 4294967295 + t4 + 1, n4, r4, o3);
          }
          function U(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 3 < e5.length, "Trying to write beyond buffer length"), D(t4, 34028234663852886e22, -34028234663852886e22)), e5.length <= n4 || i2.write(e5, t4, n4, r4, 23, 4);
          }
          function x(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 7 < e5.length, "Trying to write beyond buffer length"), D(t4, 17976931348623157e292, -17976931348623157e292)), e5.length <= n4 || i2.write(e5, t4, n4, r4, 52, 8);
          }
          H.Buffer = f2, H.SlowBuffer = f2, H.INSPECT_MAX_BYTES = 50, f2.poolSize = 8192, f2._useTypedArrays = function() {
            try {
              var e5 = new ArrayBuffer(0), t4 = new Uint8Array(e5);
              return t4.foo = function() {
                return 42;
              }, 42 === t4.foo() && "function" == typeof t4.subarray;
            } catch (e6) {
              return false;
            }
          }(), f2.isEncoding = function(e5) {
            switch (String(e5).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f2.isBuffer = function(e5) {
            return !(null == e5 || !e5._isBuffer);
          }, f2.byteLength = function(e5, t4) {
            var n4;
            switch (e5 += "", t4 || "utf8") {
              case "hex":
                n4 = e5.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n4 = T(e5).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n4 = e5.length;
                break;
              case "base64":
                n4 = M(e5).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n4 = 2 * e5.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n4;
          }, f2.concat = function(e5, t4) {
            if (d2(C(e5), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e5.length) return new f2(0);
            if (1 === e5.length) return e5[0];
            if ("number" != typeof t4) for (o3 = t4 = 0; o3 < e5.length; o3++) t4 += e5[o3].length;
            for (var n4 = new f2(t4), r4 = 0, o3 = 0; o3 < e5.length; o3++) {
              var i3 = e5[o3];
              i3.copy(n4, r4), r4 += i3.length;
            }
            return n4;
          }, f2.prototype.write = function(e5, t4, n4, r4) {
            isFinite(t4) ? isFinite(n4) || (r4 = n4, n4 = void 0) : (a3 = r4, r4 = t4, t4 = n4, n4 = a3), t4 = Number(t4) || 0;
            var o3, i3, u4, s3, a3 = this.length - t4;
            switch ((!n4 || a3 < (n4 = Number(n4))) && (n4 = a3), r4 = String(r4 || "utf8").toLowerCase()) {
              case "hex":
                o3 = function(e6, t5, n5, r5) {
                  n5 = Number(n5) || 0;
                  var o4 = e6.length - n5;
                  (!r5 || o4 < (r5 = Number(r5))) && (r5 = o4), d2((o4 = t5.length) % 2 == 0, "Invalid hex string"), o4 / 2 < r5 && (r5 = o4 / 2);
                  for (var i4 = 0; i4 < r5; i4++) {
                    var u5 = parseInt(t5.substr(2 * i4, 2), 16);
                    d2(!isNaN(u5), "Invalid hex string"), e6[n5 + i4] = u5;
                  }
                  return f2._charsWritten = 2 * i4, i4;
                }(this, e5, t4, n4);
                break;
              case "utf8":
              case "utf-8":
                i3 = this, u4 = t4, s3 = n4, o3 = f2._charsWritten = c3(T(e5), i3, u4, s3);
                break;
              case "ascii":
              case "binary":
                o3 = b2(this, e5, t4, n4);
                break;
              case "base64":
                i3 = this, u4 = t4, s3 = n4, o3 = f2._charsWritten = c3(M(e5), i3, u4, s3);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o3 = m(this, e5, t4, n4);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o3;
          }, f2.prototype.toString = function(e5, t4, n4) {
            var r4, o3, i3, u4, s3 = this;
            if (e5 = String(e5 || "utf8").toLowerCase(), t4 = Number(t4) || 0, (n4 = void 0 !== n4 ? Number(n4) : s3.length) === t4) return "";
            switch (e5) {
              case "hex":
                r4 = function(e6, t5, n5) {
                  var r5 = e6.length;
                  (!t5 || t5 < 0) && (t5 = 0);
                  (!n5 || n5 < 0 || r5 < n5) && (n5 = r5);
                  for (var o4 = "", i4 = t5; i4 < n5; i4++) o4 += k(e6[i4]);
                  return o4;
                }(s3, t4, n4);
                break;
              case "utf8":
              case "utf-8":
                r4 = function(e6, t5, n5) {
                  var r5 = "", o4 = "";
                  n5 = Math.min(e6.length, n5);
                  for (var i4 = t5; i4 < n5; i4++) e6[i4] <= 127 ? (r5 += N(o4) + String.fromCharCode(e6[i4]), o4 = "") : o4 += "%" + e6[i4].toString(16);
                  return r5 + N(o4);
                }(s3, t4, n4);
                break;
              case "ascii":
              case "binary":
                r4 = v2(s3, t4, n4);
                break;
              case "base64":
                o3 = s3, u4 = n4, r4 = 0 === (i3 = t4) && u4 === o3.length ? a2.fromByteArray(o3) : a2.fromByteArray(o3.slice(i3, u4));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r4 = function(e6, t5, n5) {
                  for (var r5 = e6.slice(t5, n5), o4 = "", i4 = 0; i4 < r5.length; i4 += 2) o4 += String.fromCharCode(r5[i4] + 256 * r5[i4 + 1]);
                  return o4;
                }(s3, t4, n4);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r4;
          }, f2.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f2.prototype.copy = function(e5, t4, n4, r4) {
            if (t4 = t4 || 0, (r4 = r4 || 0 === r4 ? r4 : this.length) !== (n4 = n4 || 0) && 0 !== e5.length && 0 !== this.length) {
              d2(n4 <= r4, "sourceEnd < sourceStart"), d2(0 <= t4 && t4 < e5.length, "targetStart out of bounds"), d2(0 <= n4 && n4 < this.length, "sourceStart out of bounds"), d2(0 <= r4 && r4 <= this.length, "sourceEnd out of bounds"), r4 > this.length && (r4 = this.length);
              var o3 = (r4 = e5.length - t4 < r4 - n4 ? e5.length - t4 + n4 : r4) - n4;
              if (o3 < 100 || !f2._useTypedArrays) for (var i3 = 0; i3 < o3; i3++) e5[i3 + t4] = this[i3 + n4];
              else e5._set(this.subarray(n4, n4 + o3), t4);
            }
          }, f2.prototype.slice = function(e5, t4) {
            var n4 = this.length;
            if (e5 = S(e5, n4, 0), t4 = S(t4, n4, n4), f2._useTypedArrays) return f2._augment(this.subarray(e5, t4));
            for (var r4 = t4 - e5, o3 = new f2(r4, void 0, true), i3 = 0; i3 < r4; i3++) o3[i3] = this[i3 + e5];
            return o3;
          }, f2.prototype.get = function(e5) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e5);
          }, f2.prototype.set = function(e5, t4) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e5, t4);
          }, f2.prototype.readUInt8 = function(e5, t4) {
            if (t4 || (d2(null != e5, "missing offset"), d2(e5 < this.length, "Trying to read beyond buffer length")), !(e5 >= this.length)) return this[e5];
          }, f2.prototype.readUInt16LE = function(e5, t4) {
            return o2(this, e5, true, t4);
          }, f2.prototype.readUInt16BE = function(e5, t4) {
            return o2(this, e5, false, t4);
          }, f2.prototype.readUInt32LE = function(e5, t4) {
            return u3(this, e5, true, t4);
          }, f2.prototype.readUInt32BE = function(e5, t4) {
            return u3(this, e5, false, t4);
          }, f2.prototype.readInt8 = function(e5, t4) {
            if (t4 || (d2(null != e5, "missing offset"), d2(e5 < this.length, "Trying to read beyond buffer length")), !(e5 >= this.length)) return 128 & this[e5] ? -1 * (255 - this[e5] + 1) : this[e5];
          }, f2.prototype.readInt16LE = function(e5, t4) {
            return _2(this, e5, true, t4);
          }, f2.prototype.readInt16BE = function(e5, t4) {
            return _2(this, e5, false, t4);
          }, f2.prototype.readInt32LE = function(e5, t4) {
            return E2(this, e5, true, t4);
          }, f2.prototype.readInt32BE = function(e5, t4) {
            return E2(this, e5, false, t4);
          }, f2.prototype.readFloatLE = function(e5, t4) {
            return I(this, e5, true, t4);
          }, f2.prototype.readFloatBE = function(e5, t4) {
            return I(this, e5, false, t4);
          }, f2.prototype.readDoubleLE = function(e5, t4) {
            return A(this, e5, true, t4);
          }, f2.prototype.readDoubleBE = function(e5, t4) {
            return A(this, e5, false, t4);
          }, f2.prototype.writeUInt8 = function(e5, t4, n4) {
            n4 || (d2(null != e5, "missing value"), d2(null != t4, "missing offset"), d2(t4 < this.length, "trying to write beyond buffer length"), Y(e5, 255)), t4 >= this.length || (this[t4] = e5);
          }, f2.prototype.writeUInt16LE = function(e5, t4, n4) {
            s2(this, e5, t4, true, n4);
          }, f2.prototype.writeUInt16BE = function(e5, t4, n4) {
            s2(this, e5, t4, false, n4);
          }, f2.prototype.writeUInt32LE = function(e5, t4, n4) {
            l2(this, e5, t4, true, n4);
          }, f2.prototype.writeUInt32BE = function(e5, t4, n4) {
            l2(this, e5, t4, false, n4);
          }, f2.prototype.writeInt8 = function(e5, t4, n4) {
            n4 || (d2(null != e5, "missing value"), d2(null != t4, "missing offset"), d2(t4 < this.length, "Trying to write beyond buffer length"), F(e5, 127, -128)), t4 >= this.length || (0 <= e5 ? this.writeUInt8(e5, t4, n4) : this.writeUInt8(255 + e5 + 1, t4, n4));
          }, f2.prototype.writeInt16LE = function(e5, t4, n4) {
            B(this, e5, t4, true, n4);
          }, f2.prototype.writeInt16BE = function(e5, t4, n4) {
            B(this, e5, t4, false, n4);
          }, f2.prototype.writeInt32LE = function(e5, t4, n4) {
            L(this, e5, t4, true, n4);
          }, f2.prototype.writeInt32BE = function(e5, t4, n4) {
            L(this, e5, t4, false, n4);
          }, f2.prototype.writeFloatLE = function(e5, t4, n4) {
            U(this, e5, t4, true, n4);
          }, f2.prototype.writeFloatBE = function(e5, t4, n4) {
            U(this, e5, t4, false, n4);
          }, f2.prototype.writeDoubleLE = function(e5, t4, n4) {
            x(this, e5, t4, true, n4);
          }, f2.prototype.writeDoubleBE = function(e5, t4, n4) {
            x(this, e5, t4, false, n4);
          }, f2.prototype.fill = function(e5, t4, n4) {
            if (t4 = t4 || 0, n4 = n4 || this.length, d2("number" == typeof (e5 = "string" == typeof (e5 = e5 || 0) ? e5.charCodeAt(0) : e5) && !isNaN(e5), "value is not a number"), d2(t4 <= n4, "end < start"), n4 !== t4 && 0 !== this.length) {
              d2(0 <= t4 && t4 < this.length, "start out of bounds"), d2(0 <= n4 && n4 <= this.length, "end out of bounds");
              for (var r4 = t4; r4 < n4; r4++) this[r4] = e5;
            }
          }, f2.prototype.inspect = function() {
            for (var e5 = [], t4 = this.length, n4 = 0; n4 < t4; n4++) if (e5[n4] = k(this[n4]), n4 === H.INSPECT_MAX_BYTES) {
              e5[n4 + 1] = "...";
              break;
            }
            return "<Buffer " + e5.join(" ") + ">";
          }, f2.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f2._useTypedArrays) return new f2(this).buffer;
            for (var e5 = new Uint8Array(this.length), t4 = 0, n4 = e5.length; t4 < n4; t4 += 1) e5[t4] = this[t4];
            return e5.buffer;
          };
          var t3 = f2.prototype;
          function S(e5, t4, n4) {
            return "number" != typeof e5 ? n4 : t4 <= (e5 = ~~e5) ? t4 : 0 <= e5 || 0 <= (e5 += t4) ? e5 : 0;
          }
          function j(e5) {
            return (e5 = ~~Math.ceil(+e5)) < 0 ? 0 : e5;
          }
          function C(e5) {
            return (Array.isArray || function(e6) {
              return "[object Array]" === Object.prototype.toString.call(e6);
            })(e5);
          }
          function k(e5) {
            return e5 < 16 ? "0" + e5.toString(16) : e5.toString(16);
          }
          function T(e5) {
            for (var t4 = [], n4 = 0; n4 < e5.length; n4++) {
              var r4 = e5.charCodeAt(n4);
              if (r4 <= 127) t4.push(e5.charCodeAt(n4));
              else for (var o3 = n4, i3 = (55296 <= r4 && r4 <= 57343 && n4++, encodeURIComponent(e5.slice(o3, n4 + 1)).substr(1).split("%")), u4 = 0; u4 < i3.length; u4++) t4.push(parseInt(i3[u4], 16));
            }
            return t4;
          }
          function M(e5) {
            return a2.toByteArray(e5);
          }
          function c3(e5, t4, n4, r4) {
            for (var o3 = 0; o3 < r4 && !(o3 + n4 >= t4.length || o3 >= e5.length); o3++) t4[o3 + n4] = e5[o3];
            return o3;
          }
          function N(e5) {
            try {
              return decodeURIComponent(e5);
            } catch (e6) {
              return String.fromCharCode(65533);
            }
          }
          function Y(e5, t4) {
            d2("number" == typeof e5, "cannot write a non-number as a number"), d2(0 <= e5, "specified a negative value for writing an unsigned value"), d2(e5 <= t4, "value is larger than maximum value for type"), d2(Math.floor(e5) === e5, "value has a fractional component");
          }
          function F(e5, t4, n4) {
            d2("number" == typeof e5, "cannot write a non-number as a number"), d2(e5 <= t4, "value larger than maximum allowed value"), d2(n4 <= e5, "value smaller than minimum allowed value"), d2(Math.floor(e5) === e5, "value has a fractional component");
          }
          function D(e5, t4, n4) {
            d2("number" == typeof e5, "cannot write a non-number as a number"), d2(e5 <= t4, "value larger than maximum allowed value"), d2(n4 <= e5, "value smaller than minimum allowed value");
          }
          function d2(e5, t4) {
            if (!e5) throw new Error(t4 || "Failed assertion");
          }
          f2._augment = function(e5) {
            return e5._isBuffer = true, e5._get = e5.get, e5._set = e5.set, e5.get = t3.get, e5.set = t3.set, e5.write = t3.write, e5.toString = t3.toString, e5.toLocaleString = t3.toString, e5.toJSON = t3.toJSON, e5.copy = t3.copy, e5.slice = t3.slice, e5.readUInt8 = t3.readUInt8, e5.readUInt16LE = t3.readUInt16LE, e5.readUInt16BE = t3.readUInt16BE, e5.readUInt32LE = t3.readUInt32LE, e5.readUInt32BE = t3.readUInt32BE, e5.readInt8 = t3.readInt8, e5.readInt16LE = t3.readInt16LE, e5.readInt16BE = t3.readInt16BE, e5.readInt32LE = t3.readInt32LE, e5.readInt32BE = t3.readInt32BE, e5.readFloatLE = t3.readFloatLE, e5.readFloatBE = t3.readFloatBE, e5.readDoubleLE = t3.readDoubleLE, e5.readDoubleBE = t3.readDoubleBE, e5.writeUInt8 = t3.writeUInt8, e5.writeUInt16LE = t3.writeUInt16LE, e5.writeUInt16BE = t3.writeUInt16BE, e5.writeUInt32LE = t3.writeUInt32LE, e5.writeUInt32BE = t3.writeUInt32BE, e5.writeInt8 = t3.writeInt8, e5.writeInt16LE = t3.writeInt16LE, e5.writeInt16BE = t3.writeInt16BE, e5.writeInt32LE = t3.writeInt32LE, e5.writeInt32BE = t3.writeInt32BE, e5.writeFloatLE = t3.writeFloatLE, e5.writeFloatBE = t3.writeFloatBE, e5.writeDoubleLE = t3.writeDoubleLE, e5.writeDoubleBE = t3.writeDoubleBE, e5.fill = t3.fill, e5.inspect = t3.inspect, e5.toArrayBuffer = t3.toArrayBuffer, e5;
          };
        }).call(this, O("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c3, d2, e3) {
        !(function(e4, t3, a2, n3, r3, o2, i2, u3, s2) {
          var a2 = c3("buffer").Buffer, f2 = 4, l2 = new a2(f2);
          l2.fill(0);
          d2.exports = { hash: function(e5, t4, n4, r4) {
            for (var o3 = t4(function(e6, t5) {
              e6.length % f2 != 0 && (n5 = e6.length + (f2 - e6.length % f2), e6 = a2.concat([e6, l2], n5));
              for (var n5, r5 = [], o4 = t5 ? e6.readInt32BE : e6.readInt32LE, i4 = 0; i4 < e6.length; i4 += f2) r5.push(o4.call(e6, i4));
              return r5;
            }(e5 = a2.isBuffer(e5) ? e5 : new a2(e5), r4), 8 * e5.length), t4 = r4, i3 = new a2(n4), u4 = t4 ? i3.writeInt32BE : i3.writeInt32LE, s3 = 0; s3 < o3.length; s3++) u4.call(i3, o3[s3], 4 * s3, true);
            return i3;
          } };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v2, e3, _2) {
        !(function(l2, c3, u3, d2, h2, p2, g2, y2, w2) {
          var u3 = v2("buffer").Buffer, e4 = v2("./sha"), t3 = v2("./sha256"), n3 = v2("./rng"), b2 = { sha1: e4, sha256: t3, md5: v2("./md5") }, s2 = 64, a2 = new u3(s2);
          function r3(e5, n4) {
            var r4 = b2[e5 = e5 || "sha1"], o3 = [];
            return r4 || i2("algorithm:", e5, "is not yet supported"), { update: function(e6) {
              return u3.isBuffer(e6) || (e6 = new u3(e6)), o3.push(e6), e6.length, this;
            }, digest: function(e6) {
              var t4 = u3.concat(o3), t4 = n4 ? function(e7, t5, n5) {
                u3.isBuffer(t5) || (t5 = new u3(t5)), u3.isBuffer(n5) || (n5 = new u3(n5)), t5.length > s2 ? t5 = e7(t5) : t5.length < s2 && (t5 = u3.concat([t5, a2], s2));
                for (var r5 = new u3(s2), o4 = new u3(s2), i3 = 0; i3 < s2; i3++) r5[i3] = 54 ^ t5[i3], o4[i3] = 92 ^ t5[i3];
                return n5 = e7(u3.concat([r5, n5])), e7(u3.concat([o4, n5]));
              }(r4, n4, t4) : r4(t4);
              return o3 = null, e6 ? t4.toString(e6) : t4;
            } };
          }
          function i2() {
            var e5 = [].slice.call(arguments).join(" ");
            throw new Error([e5, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a2.fill(0), _2.createHash = function(e5) {
            return r3(e5);
          }, _2.createHmac = r3, _2.randomBytes = function(e5, t4) {
            if (!t4 || !t4.call) return new u3(n3(e5));
            try {
              t4.call(this, void 0, new u3(n3(e5)));
            } catch (e6) {
              t4(e6);
            }
          };
          var o2, f2 = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m = function(e5) {
            _2[e5] = function() {
              i2("sorry,", e5, "is not implemented yet");
            };
          };
          for (o2 in f2) m(f2[o2], o2);
        }).call(this, v2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w2, b2, e3) {
        !(function(e4, r3, o2, i2, u3, a2, f2, l2, y2) {
          var t3 = w2("./helpers");
          function n3(e5, t4) {
            e5[t4 >> 5] |= 128 << t4 % 32, e5[14 + (t4 + 64 >>> 9 << 4)] = t4;
            for (var n4 = 1732584193, r4 = -271733879, o3 = -1732584194, i3 = 271733878, u4 = 0; u4 < e5.length; u4 += 16) {
              var s3 = n4, a3 = r4, f3 = o3, l3 = i3, n4 = c3(n4, r4, o3, i3, e5[u4 + 0], 7, -680876936), i3 = c3(i3, n4, r4, o3, e5[u4 + 1], 12, -389564586), o3 = c3(o3, i3, n4, r4, e5[u4 + 2], 17, 606105819), r4 = c3(r4, o3, i3, n4, e5[u4 + 3], 22, -1044525330);
              n4 = c3(n4, r4, o3, i3, e5[u4 + 4], 7, -176418897), i3 = c3(i3, n4, r4, o3, e5[u4 + 5], 12, 1200080426), o3 = c3(o3, i3, n4, r4, e5[u4 + 6], 17, -1473231341), r4 = c3(r4, o3, i3, n4, e5[u4 + 7], 22, -45705983), n4 = c3(n4, r4, o3, i3, e5[u4 + 8], 7, 1770035416), i3 = c3(i3, n4, r4, o3, e5[u4 + 9], 12, -1958414417), o3 = c3(o3, i3, n4, r4, e5[u4 + 10], 17, -42063), r4 = c3(r4, o3, i3, n4, e5[u4 + 11], 22, -1990404162), n4 = c3(n4, r4, o3, i3, e5[u4 + 12], 7, 1804603682), i3 = c3(i3, n4, r4, o3, e5[u4 + 13], 12, -40341101), o3 = c3(o3, i3, n4, r4, e5[u4 + 14], 17, -1502002290), n4 = d2(n4, r4 = c3(r4, o3, i3, n4, e5[u4 + 15], 22, 1236535329), o3, i3, e5[u4 + 1], 5, -165796510), i3 = d2(i3, n4, r4, o3, e5[u4 + 6], 9, -1069501632), o3 = d2(o3, i3, n4, r4, e5[u4 + 11], 14, 643717713), r4 = d2(r4, o3, i3, n4, e5[u4 + 0], 20, -373897302), n4 = d2(n4, r4, o3, i3, e5[u4 + 5], 5, -701558691), i3 = d2(i3, n4, r4, o3, e5[u4 + 10], 9, 38016083), o3 = d2(o3, i3, n4, r4, e5[u4 + 15], 14, -660478335), r4 = d2(r4, o3, i3, n4, e5[u4 + 4], 20, -405537848), n4 = d2(n4, r4, o3, i3, e5[u4 + 9], 5, 568446438), i3 = d2(i3, n4, r4, o3, e5[u4 + 14], 9, -1019803690), o3 = d2(o3, i3, n4, r4, e5[u4 + 3], 14, -187363961), r4 = d2(r4, o3, i3, n4, e5[u4 + 8], 20, 1163531501), n4 = d2(n4, r4, o3, i3, e5[u4 + 13], 5, -1444681467), i3 = d2(i3, n4, r4, o3, e5[u4 + 2], 9, -51403784), o3 = d2(o3, i3, n4, r4, e5[u4 + 7], 14, 1735328473), n4 = h2(n4, r4 = d2(r4, o3, i3, n4, e5[u4 + 12], 20, -1926607734), o3, i3, e5[u4 + 5], 4, -378558), i3 = h2(i3, n4, r4, o3, e5[u4 + 8], 11, -2022574463), o3 = h2(o3, i3, n4, r4, e5[u4 + 11], 16, 1839030562), r4 = h2(r4, o3, i3, n4, e5[u4 + 14], 23, -35309556), n4 = h2(n4, r4, o3, i3, e5[u4 + 1], 4, -1530992060), i3 = h2(i3, n4, r4, o3, e5[u4 + 4], 11, 1272893353), o3 = h2(o3, i3, n4, r4, e5[u4 + 7], 16, -155497632), r4 = h2(r4, o3, i3, n4, e5[u4 + 10], 23, -1094730640), n4 = h2(n4, r4, o3, i3, e5[u4 + 13], 4, 681279174), i3 = h2(i3, n4, r4, o3, e5[u4 + 0], 11, -358537222), o3 = h2(o3, i3, n4, r4, e5[u4 + 3], 16, -722521979), r4 = h2(r4, o3, i3, n4, e5[u4 + 6], 23, 76029189), n4 = h2(n4, r4, o3, i3, e5[u4 + 9], 4, -640364487), i3 = h2(i3, n4, r4, o3, e5[u4 + 12], 11, -421815835), o3 = h2(o3, i3, n4, r4, e5[u4 + 15], 16, 530742520), n4 = p2(n4, r4 = h2(r4, o3, i3, n4, e5[u4 + 2], 23, -995338651), o3, i3, e5[u4 + 0], 6, -198630844), i3 = p2(i3, n4, r4, o3, e5[u4 + 7], 10, 1126891415), o3 = p2(o3, i3, n4, r4, e5[u4 + 14], 15, -1416354905), r4 = p2(r4, o3, i3, n4, e5[u4 + 5], 21, -57434055), n4 = p2(n4, r4, o3, i3, e5[u4 + 12], 6, 1700485571), i3 = p2(i3, n4, r4, o3, e5[u4 + 3], 10, -1894986606), o3 = p2(o3, i3, n4, r4, e5[u4 + 10], 15, -1051523), r4 = p2(r4, o3, i3, n4, e5[u4 + 1], 21, -2054922799), n4 = p2(n4, r4, o3, i3, e5[u4 + 8], 6, 1873313359), i3 = p2(i3, n4, r4, o3, e5[u4 + 15], 10, -30611744), o3 = p2(o3, i3, n4, r4, e5[u4 + 6], 15, -1560198380), r4 = p2(r4, o3, i3, n4, e5[u4 + 13], 21, 1309151649), n4 = p2(n4, r4, o3, i3, e5[u4 + 4], 6, -145523070), i3 = p2(i3, n4, r4, o3, e5[u4 + 11], 10, -1120210379), o3 = p2(o3, i3, n4, r4, e5[u4 + 2], 15, 718787259), r4 = p2(r4, o3, i3, n4, e5[u4 + 9], 21, -343485551), n4 = g2(n4, s3), r4 = g2(r4, a3), o3 = g2(o3, f3), i3 = g2(i3, l3);
            }
            return Array(n4, r4, o3, i3);
          }
          function s2(e5, t4, n4, r4, o3, i3) {
            return g2((t4 = g2(g2(t4, e5), g2(r4, i3))) << o3 | t4 >>> 32 - o3, n4);
          }
          function c3(e5, t4, n4, r4, o3, i3, u4) {
            return s2(t4 & n4 | ~t4 & r4, e5, t4, o3, i3, u4);
          }
          function d2(e5, t4, n4, r4, o3, i3, u4) {
            return s2(t4 & r4 | n4 & ~r4, e5, t4, o3, i3, u4);
          }
          function h2(e5, t4, n4, r4, o3, i3, u4) {
            return s2(t4 ^ n4 ^ r4, e5, t4, o3, i3, u4);
          }
          function p2(e5, t4, n4, r4, o3, i3, u4) {
            return s2(n4 ^ (t4 | ~r4), e5, t4, o3, i3, u4);
          }
          function g2(e5, t4) {
            var n4 = (65535 & e5) + (65535 & t4);
            return (e5 >> 16) + (t4 >> 16) + (n4 >> 16) << 16 | 65535 & n4;
          }
          b2.exports = function(e5) {
            return t3.hash(e5, n3, 16);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e3, l2, t3) {
        !(function(e4, t4, n3, r3, o2, i2, u3, s2, f2) {
          var a2;
          l2.exports = a2 || function(e5) {
            for (var t5, n4 = new Array(e5), r4 = 0; r4 < e5; r4++) 0 == (3 & r4) && (t5 = 4294967296 * Math.random()), n4[r4] = t5 >>> ((3 & r4) << 3) & 255;
            return n4;
          };
        }).call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c3, d2, e3) {
        !(function(e4, t3, n3, r3, o2, s2, a2, f2, l2) {
          var i2 = c3("./helpers");
          function u3(l3, c4) {
            l3[c4 >> 5] |= 128 << 24 - c4 % 32, l3[15 + (c4 + 64 >> 9 << 4)] = c4;
            for (var e5, t4, n4, r4 = Array(80), o3 = 1732584193, i3 = -271733879, u4 = -1732584194, s3 = 271733878, d3 = -1009589776, h2 = 0; h2 < l3.length; h2 += 16) {
              for (var p2 = o3, g2 = i3, y2 = u4, w2 = s3, b2 = d3, a3 = 0; a3 < 80; a3++) {
                r4[a3] = a3 < 16 ? l3[h2 + a3] : v2(r4[a3 - 3] ^ r4[a3 - 8] ^ r4[a3 - 14] ^ r4[a3 - 16], 1);
                var f3 = m(m(v2(o3, 5), (f3 = i3, t4 = u4, n4 = s3, (e5 = a3) < 20 ? f3 & t4 | ~f3 & n4 : !(e5 < 40) && e5 < 60 ? f3 & t4 | f3 & n4 | t4 & n4 : f3 ^ t4 ^ n4)), m(m(d3, r4[a3]), (e5 = a3) < 20 ? 1518500249 : e5 < 40 ? 1859775393 : e5 < 60 ? -1894007588 : -899497514)), d3 = s3, s3 = u4, u4 = v2(i3, 30), i3 = o3, o3 = f3;
              }
              o3 = m(o3, p2), i3 = m(i3, g2), u4 = m(u4, y2), s3 = m(s3, w2), d3 = m(d3, b2);
            }
            return Array(o3, i3, u4, s3, d3);
          }
          function m(e5, t4) {
            var n4 = (65535 & e5) + (65535 & t4);
            return (e5 >> 16) + (t4 >> 16) + (n4 >> 16) << 16 | 65535 & n4;
          }
          function v2(e5, t4) {
            return e5 << t4 | e5 >>> 32 - t4;
          }
          d2.exports = function(e5) {
            return i2.hash(e5, u3, 20, true);
          };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c3, d2, e3) {
        !(function(e4, t3, n3, r3, u3, s2, a2, f2, l2) {
          function b2(e5, t4) {
            var n4 = (65535 & e5) + (65535 & t4);
            return (e5 >> 16) + (t4 >> 16) + (n4 >> 16) << 16 | 65535 & n4;
          }
          function o2(e5, l3) {
            var c4, d3 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t4 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n4 = new Array(64);
            e5[l3 >> 5] |= 128 << 24 - l3 % 32, e5[15 + (l3 + 64 >> 9 << 4)] = l3;
            for (var r4, o3, h2 = 0; h2 < e5.length; h2 += 16) {
              for (var i3 = t4[0], u4 = t4[1], s3 = t4[2], p2 = t4[3], a3 = t4[4], g2 = t4[5], y2 = t4[6], w2 = t4[7], f3 = 0; f3 < 64; f3++) n4[f3] = f3 < 16 ? e5[f3 + h2] : b2(b2(b2((o3 = n4[f3 - 2], m(o3, 17) ^ m(o3, 19) ^ v2(o3, 10)), n4[f3 - 7]), (o3 = n4[f3 - 15], m(o3, 7) ^ m(o3, 18) ^ v2(o3, 3))), n4[f3 - 16]), c4 = b2(b2(b2(b2(w2, m(o3 = a3, 6) ^ m(o3, 11) ^ m(o3, 25)), a3 & g2 ^ ~a3 & y2), d3[f3]), n4[f3]), r4 = b2(m(r4 = i3, 2) ^ m(r4, 13) ^ m(r4, 22), i3 & u4 ^ i3 & s3 ^ u4 & s3), w2 = y2, y2 = g2, g2 = a3, a3 = b2(p2, c4), p2 = s3, s3 = u4, u4 = i3, i3 = b2(c4, r4);
              t4[0] = b2(i3, t4[0]), t4[1] = b2(u4, t4[1]), t4[2] = b2(s3, t4[2]), t4[3] = b2(p2, t4[3]), t4[4] = b2(a3, t4[4]), t4[5] = b2(g2, t4[5]), t4[6] = b2(y2, t4[6]), t4[7] = b2(w2, t4[7]);
            }
            return t4;
          }
          var i2 = c3("./helpers"), m = function(e5, t4) {
            return e5 >>> t4 | e5 << 32 - t4;
          }, v2 = function(e5, t4) {
            return e5 >>> t4;
          };
          d2.exports = function(e5) {
            return i2.hash(e5, o2, 32, true);
          };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e3, t3, f2) {
        !(function(e4, t4, n3, r3, o2, i2, u3, s2, a2) {
          f2.read = function(e5, t5, n4, r4, o3) {
            var i3, u4, l2 = 8 * o3 - r4 - 1, c3 = (1 << l2) - 1, d2 = c3 >> 1, s3 = -7, a3 = n4 ? o3 - 1 : 0, f3 = n4 ? -1 : 1, o3 = e5[t5 + a3];
            for (a3 += f3, i3 = o3 & (1 << -s3) - 1, o3 >>= -s3, s3 += l2; 0 < s3; i3 = 256 * i3 + e5[t5 + a3], a3 += f3, s3 -= 8) ;
            for (u4 = i3 & (1 << -s3) - 1, i3 >>= -s3, s3 += r4; 0 < s3; u4 = 256 * u4 + e5[t5 + a3], a3 += f3, s3 -= 8) ;
            if (0 === i3) i3 = 1 - d2;
            else {
              if (i3 === c3) return u4 ? NaN : 1 / 0 * (o3 ? -1 : 1);
              u4 += Math.pow(2, r4), i3 -= d2;
            }
            return (o3 ? -1 : 1) * u4 * Math.pow(2, i3 - r4);
          }, f2.write = function(e5, t5, l2, n4, r4, c3) {
            var o3, i3, u4 = 8 * c3 - r4 - 1, s3 = (1 << u4) - 1, a3 = s3 >> 1, d2 = 23 === r4 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f3 = n4 ? 0 : c3 - 1, h2 = n4 ? 1 : -1, c3 = t5 < 0 || 0 === t5 && 1 / t5 < 0 ? 1 : 0;
            for (t5 = Math.abs(t5), isNaN(t5) || t5 === 1 / 0 ? (i3 = isNaN(t5) ? 1 : 0, o3 = s3) : (o3 = Math.floor(Math.log(t5) / Math.LN2), t5 * (n4 = Math.pow(2, -o3)) < 1 && (o3--, n4 *= 2), 2 <= (t5 += 1 <= o3 + a3 ? d2 / n4 : d2 * Math.pow(2, 1 - a3)) * n4 && (o3++, n4 /= 2), s3 <= o3 + a3 ? (i3 = 0, o3 = s3) : 1 <= o3 + a3 ? (i3 = (t5 * n4 - 1) * Math.pow(2, r4), o3 += a3) : (i3 = t5 * Math.pow(2, a3 - 1) * Math.pow(2, r4), o3 = 0)); 8 <= r4; e5[l2 + f3] = 255 & i3, f3 += h2, i3 /= 256, r4 -= 8) ;
            for (o3 = o3 << r4 | i3, u4 += r4; 0 < u4; e5[l2 + f3] = 255 & o3, f3 += h2, o3 /= 256, u4 -= 8) ;
            e5[l2 + f3 - h2] |= 128 * c3;
          };
        }).call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e3, h2, t3) {
        !(function(e4, t4, n3, r3, o2, f2, l2, c3, d2) {
          var i2, u3, s2;
          function a2() {
          }
          (e4 = h2.exports = {}).nextTick = (u3 = "undefined" != typeof window && window.setImmediate, s2 = "undefined" != typeof window && window.postMessage && window.addEventListener, u3 ? function(e5) {
            return window.setImmediate(e5);
          } : s2 ? (i2 = [], window.addEventListener("message", function(e5) {
            var t5 = e5.source;
            t5 !== window && null !== t5 || "process-tick" !== e5.data || (e5.stopPropagation(), 0 < i2.length && i2.shift()());
          }, true), function(e5) {
            i2.push(e5), window.postMessage("process-tick", "*");
          }) : function(e5) {
            setTimeout(e5, 0);
          }), e4.title = "browser", e4.browser = true, e4.env = {}, e4.argv = [], e4.on = a2, e4.addListener = a2, e4.once = a2, e4.off = a2, e4.removeListener = a2, e4.removeAllListeners = a2, e4.emit = a2, e4.binding = function(e5) {
            throw new Error("process.binding is not supported");
          }, e4.cwd = function() {
            return "/";
          }, e4.chdir = function(e5) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// node_modules/@measured/puck/dist/chunk-CHWFBYEM.mjs
var import_react = __toESM(require_react(), 1);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var init_react_import = __esm({
  "../tsup-config/react-import.js"() {
    "use strict";
  }
});
init_react_import();
init_react_import();
init_react_import();
var getChanged = (newItem, oldItem) => {
  return newItem ? Object.keys(newItem.props || {}).reduce((acc, item) => {
    const newItemProps = (newItem == null ? void 0 : newItem.props) || {};
    const oldItemProps = (oldItem == null ? void 0 : oldItem.props) || {};
    return __spreadProps(__spreadValues({}, acc), {
      [item]: oldItemProps[item] !== newItemProps[item]
    });
  }, {}) : {};
};
var cache = { lastChange: {} };
var resolveAllComponentData = (content, config, onResolveStart, onResolveEnd) => __async(void 0, null, function* () {
  return yield Promise.all(
    content.map((item) => __async(void 0, null, function* () {
      return yield resolveComponentData(
        item,
        config,
        onResolveStart,
        onResolveEnd
      );
    }))
  );
});
var resolveComponentData = (item, config, onResolveStart, onResolveEnd) => __async(void 0, null, function* () {
  const configForItem = config.components[item.type];
  if (configForItem.resolveData) {
    const { item: oldItem = null, resolved = {} } = cache.lastChange[item.props.id] || {};
    if (item && item === oldItem) {
      return resolved;
    }
    const changed = getChanged(item, oldItem);
    if (onResolveStart) {
      onResolveStart(item);
    }
    const { props: resolvedProps, readOnly = {} } = yield configForItem.resolveData(item, { changed, lastData: oldItem });
    const resolvedItem = __spreadProps(__spreadValues({}, item), {
      props: __spreadValues(__spreadValues({}, item.props), resolvedProps)
    });
    if (Object.keys(readOnly).length) {
      resolvedItem.readOnly = readOnly;
    }
    cache.lastChange[item.props.id] = {
      item,
      resolved: resolvedItem
    };
    if (onResolveEnd) {
      onResolveEnd(resolvedItem);
    }
    return resolvedItem;
  }
  return item;
});
init_react_import();
var cache2 = {};
function resolveRootData(data, config) {
  return __async(this, null, function* () {
    var _a3, _b2, _c4, _d2, _e;
    if (((_a3 = config.root) == null ? void 0 : _a3.resolveData) && data.root.props) {
      if (((_b2 = cache2.lastChange) == null ? void 0 : _b2.original) === data.root) {
        return cache2.lastChange.resolved;
      }
      const changed = getChanged(data.root, (_c4 = cache2.lastChange) == null ? void 0 : _c4.original);
      const rootWithProps = data.root;
      const resolvedRoot = yield (_e = config.root) == null ? void 0 : _e.resolveData(rootWithProps, {
        changed,
        lastData: ((_d2 = cache2.lastChange) == null ? void 0 : _d2.original) || {}
      });
      cache2.lastChange = {
        original: data.root,
        resolved: resolvedRoot
      };
      return __spreadProps(__spreadValues(__spreadValues({}, data.root), resolvedRoot), {
        props: __spreadValues(__spreadValues({}, data.root.props), resolvedRoot.props)
      });
    }
    return data.root;
  });
}
init_react_import();
var defaultData = (data) => __spreadProps(__spreadValues({}, data), {
  root: data.root || {},
  content: data.content || []
});
function resolveAllData(data, config, onResolveStart, onResolveEnd) {
  return __async(this, null, function* () {
    const defaultedData = defaultData(data);
    const dynamicRoot = yield resolveRootData(defaultedData, config);
    const { zones = {} } = data;
    const zoneKeys = Object.keys(zones);
    const resolvedZones = {};
    for (let i2 = 0; i2 < zoneKeys.length; i2++) {
      const zoneKey = zoneKeys[i2];
      resolvedZones[zoneKey] = yield resolveAllComponentData(
        zones[zoneKey],
        config,
        onResolveStart,
        onResolveEnd
      );
    }
    return __spreadProps(__spreadValues({}, defaultedData), {
      root: dynamicRoot,
      content: yield resolveAllComponentData(
        defaultedData.content,
        config,
        onResolveStart,
        onResolveEnd
      ),
      zones: resolvedZones
    });
  });
}
init_react_import();
var rootDroppableId = "default-zone";
init_react_import();
var setupZone = (data, zoneKey) => {
  if (zoneKey === rootDroppableId) {
    return data;
  }
  const newData = __spreadProps(__spreadValues({}, data), {
    zones: data.zones ? __spreadValues({}, data.zones) : {}
  });
  newData.zones[zoneKey] = newData.zones[zoneKey] || [];
  return newData;
};

// node_modules/@measured/puck/dist/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);

// node_modules/@dnd-kit/react/index.js
var import_react3 = __toESM(require_react());

// node_modules/@preact/signals-core/dist/signals-core.module.js
var i = Symbol.for("preact-signals");
function t() {
  if (!(s > 1)) {
    var i2, t3 = false;
    while (void 0 !== h) {
      var r3 = h;
      h = void 0;
      f++;
      while (void 0 !== r3) {
        var o2 = r3.o;
        r3.o = void 0;
        r3.f &= -3;
        if (!(8 & r3.f) && c(r3)) try {
          r3.c();
        } catch (r4) {
          if (!t3) {
            i2 = r4;
            t3 = true;
          }
        }
        r3 = o2;
      }
    }
    f = 0;
    s--;
    if (t3) throw i2;
  } else s--;
}
function r(i2) {
  if (s > 0) return i2();
  s++;
  try {
    return i2();
  } finally {
    t();
  }
}
var o = void 0;
function n(i2) {
  var t3 = o;
  o = void 0;
  try {
    return i2();
  } finally {
    o = t3;
  }
}
var h = void 0;
var s = 0;
var f = 0;
var v = 0;
function e(i2) {
  if (void 0 !== o) {
    var t3 = i2.n;
    if (void 0 === t3 || t3.t !== o) {
      t3 = { i: 0, S: i2, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t3 };
      if (void 0 !== o.s) o.s.n = t3;
      o.s = t3;
      i2.n = t3;
      if (32 & o.f) i2.S(t3);
      return t3;
    } else if (-1 === t3.i) {
      t3.i = 0;
      if (void 0 !== t3.n) {
        t3.n.p = t3.p;
        if (void 0 !== t3.p) t3.p.n = t3.n;
        t3.p = o.s;
        t3.n = void 0;
        o.s.n = t3;
        o.s = t3;
      }
      return t3;
    }
  }
}
function u(i2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
}
u.prototype.brand = i;
u.prototype.h = function() {
  return true;
};
u.prototype.S = function(i2) {
  if (this.t !== i2 && void 0 === i2.e) {
    i2.x = this.t;
    if (void 0 !== this.t) this.t.e = i2;
    this.t = i2;
  }
};
u.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    var t3 = i2.e, r3 = i2.x;
    if (void 0 !== t3) {
      t3.x = r3;
      i2.e = void 0;
    }
    if (void 0 !== r3) {
      r3.e = t3;
      i2.x = void 0;
    }
    if (i2 === this.t) this.t = r3;
  }
};
u.prototype.subscribe = function(i2) {
  var t3 = this;
  return E(function() {
    var r3 = t3.value, n3 = o;
    o = void 0;
    try {
      i2(r3);
    } finally {
      o = n3;
    }
  });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  var i2 = o;
  o = void 0;
  try {
    return this.value;
  } finally {
    o = i2;
  }
};
Object.defineProperty(u.prototype, "value", { get: function() {
  var i2 = e(this);
  if (void 0 !== i2) i2.i = this.i;
  return this.v;
}, set: function(i2) {
  if (i2 !== this.v) {
    if (f > 100) throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    v++;
    s++;
    try {
      for (var r3 = this.t; void 0 !== r3; r3 = r3.x) r3.t.N();
    } finally {
      t();
    }
  }
} });
function d(i2) {
  return new u(i2);
}
function c(i2) {
  for (var t3 = i2.s; void 0 !== t3; t3 = t3.n) if (t3.S.i !== t3.i || !t3.S.h() || t3.S.i !== t3.i) return true;
  return false;
}
function a(i2) {
  for (var t3 = i2.s; void 0 !== t3; t3 = t3.n) {
    var r3 = t3.S.n;
    if (void 0 !== r3) t3.r = r3;
    t3.S.n = t3;
    t3.i = -1;
    if (void 0 === t3.n) {
      i2.s = t3;
      break;
    }
  }
}
function l(i2) {
  var t3 = i2.s, r3 = void 0;
  while (void 0 !== t3) {
    var o2 = t3.p;
    if (-1 === t3.i) {
      t3.S.U(t3);
      if (void 0 !== o2) o2.n = t3.n;
      if (void 0 !== t3.n) t3.n.p = o2;
    } else r3 = t3;
    t3.S.n = t3.r;
    if (void 0 !== t3.r) t3.r = void 0;
    t3 = o2;
  }
  i2.s = r3;
}
function y(i2) {
  u.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = v - 1;
  this.f = 4;
}
(y.prototype = new u()).h = function() {
  this.f &= -3;
  if (1 & this.f) return false;
  if (32 == (36 & this.f)) return true;
  this.f &= -5;
  if (this.g === v) return true;
  this.g = v;
  this.f |= 1;
  if (this.i > 0 && !c(this)) {
    this.f &= -2;
    return true;
  }
  var i2 = o;
  try {
    a(this);
    o = this;
    var t3 = this.x();
    if (16 & this.f || this.v !== t3 || 0 === this.i) {
      this.v = t3;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  o = i2;
  l(this);
  this.f &= -2;
  return true;
};
y.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (var t3 = this.s; void 0 !== t3; t3 = t3.n) t3.S.S(t3);
  }
  u.prototype.S.call(this, i2);
};
y.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    u.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (var t3 = this.s; void 0 !== t3; t3 = t3.n) t3.S.U(t3);
    }
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var i2 = this.t; void 0 !== i2; i2 = i2.x) i2.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var i2 = e(this);
  this.h();
  if (void 0 !== i2) i2.i = this.i;
  if (16 & this.f) throw this.v;
  return this.v;
} });
function w(i2) {
  return new y(i2);
}
function _(i2) {
  var r3 = i2.u;
  i2.u = void 0;
  if ("function" == typeof r3) {
    s++;
    var n3 = o;
    o = void 0;
    try {
      r3();
    } catch (t3) {
      i2.f &= -2;
      i2.f |= 8;
      g(i2);
      throw t3;
    } finally {
      o = n3;
      t();
    }
  }
}
function g(i2) {
  for (var t3 = i2.s; void 0 !== t3; t3 = t3.n) t3.S.U(t3);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function p(i2) {
  if (o !== this) throw new Error("Out-of-order effect");
  l(this);
  o = i2;
  this.f &= -2;
  if (8 & this.f) g(this);
  t();
}
function b(i2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
}
b.prototype.c = function() {
  var i2 = this.S();
  try {
    if (8 & this.f) return;
    if (void 0 === this.x) return;
    var t3 = this.x();
    if ("function" == typeof t3) this.u = t3;
  } finally {
    i2();
  }
};
b.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  a(this);
  s++;
  var i2 = o;
  o = this;
  return p.bind(this, i2);
};
b.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = h;
    h = this;
  }
};
b.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f)) g(this);
};
function E(i2) {
  var t3 = new b(i2);
  try {
    t3.c();
  } catch (i3) {
    t3.d();
    throw i3;
  }
  return t3.d.bind(t3);
}

// node_modules/@dnd-kit/state/dist/index.mjs
function computed(compute, comparator) {
  if (comparator) {
    let previousValue;
    return w(() => {
      const value = compute();
      if (value && previousValue && comparator(previousValue, value)) {
        return previousValue;
      }
      previousValue = value;
      return value;
    });
  }
  return w(compute);
}
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2 === b2;
  }
  if (a2 instanceof Set && b2 instanceof Set) {
    if (a2.size !== b2.size) {
      return false;
    }
    for (const value of a2) {
      if (!b2.has(value)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b2) || a2.length !== b2.length) {
      return false;
    }
    const hasDifferentValues = a2.some(
      (value, index) => !deepEqual(value, b2[index])
    );
    return !hasDifferentValues;
  }
  try {
    return JSON.stringify(a2) === JSON.stringify(b2);
  } catch (e3) {
    return false;
  }
}
function reactive({ get }, _2) {
  return {
    init(value) {
      return d(value);
    },
    get() {
      const current = get.call(this);
      return current.value;
    },
    set(newValue) {
      const current = get.call(this);
      if (current.peek() === newValue) {
        return;
      }
      current.value = newValue;
    }
  };
}
function derived(target, _2) {
  const map = /* @__PURE__ */ new WeakMap();
  return function() {
    let result = map.get(this);
    if (!result) {
      result = computed(target.bind(this));
      map.set(this, result);
    }
    return result.value;
  };
}
function effects(...entries) {
  const effects2 = entries.map(E);
  return () => effects2.forEach((cleanup) => cleanup());
}

// node_modules/@dnd-kit/geometry/dist/index.mjs
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __pow = Math.pow;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __decoratorStart = (base) => {
  var _a3;
  return [, , , __create2((_a3 = base == null ? void 0 : base[__knownSymbol("metadata")]) != null ? _a3 : null)];
};
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError2("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError2("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp2(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc2(k < 4 ? target : { get [name]() {
    return __privateGet2(this, extra);
  }, set [name](x) {
    return __privateSet2(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p2 ? (x) => (k ^ 1 ? __privateGet2 : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p2 ? (x, y2) => __privateSet2(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError2("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp2(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError2('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var Point = class _Point {
  /**
   * @param {number} Coordinate of the point on the horizontal axis
   * @param {number} Coordinate of the point on the vertical axis
   */
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  /**
   * Returns the delta between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static delta(a2, b2) {
    return new _Point(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns the distance (hypotenuse) between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static distance(a2, b2) {
    return Math.hypot(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns true if both points are equal.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static equals(a2, b2) {
    return a2.x === b2.x && a2.y === b2.y;
  }
  static from({ x, y: y2 }) {
    return new _Point(x, y2);
  }
};
var Rectangle = class _Rectangle {
  constructor(left, top, width, height) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
    this.scale = {
      x: 1,
      y: 1
    };
  }
  get inverseScale() {
    return {
      x: 1 / this.scale.x,
      y: 1 / this.scale.y
    };
  }
  translate(x, y2) {
    const { top, left, width, height, scale } = this;
    const newShape = new _Rectangle(left + x, top + y2, width, height);
    newShape.scale = __spreadValues2({}, scale);
    return newShape;
  }
  get boundingRectangle() {
    const { width, height, left, top, right, bottom } = this;
    return { width, height, left, top, right, bottom };
  }
  get center() {
    const { left, top, right, bottom } = this;
    return new Point((left + right) / 2, (top + bottom) / 2);
  }
  get area() {
    const { width, height } = this;
    return width * height;
  }
  equals(shape) {
    if (!(shape instanceof _Rectangle)) {
      return false;
    }
    const { left, top, width, height } = this;
    return left === shape.left && top === shape.top && width === shape.width && height === shape.height;
  }
  containsPoint(point) {
    const { top, left, bottom, right } = this;
    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;
  }
  intersectionArea(shape) {
    if (shape instanceof _Rectangle) {
      return rectangleRectangleIntersection(this, shape);
    }
    return 0;
  }
  intersectionRatio(shape) {
    const { area } = this;
    const intersectionArea = this.intersectionArea(shape);
    const intersectionRatio = intersectionArea / (shape.area + area - intersectionArea);
    return intersectionRatio;
  }
  get bottom() {
    const { top, height } = this;
    return top + height;
  }
  get right() {
    const { left, width } = this;
    return left + width;
  }
  static from({ top, left, width, height }) {
    return new _Rectangle(left, top, width, height);
  }
  static intersectionRatio(a2, b2) {
    return _Rectangle.from(a2).intersectionRatio(_Rectangle.from(b2));
  }
};
function rectangleRectangleIntersection(a2, b2) {
  const top = Math.max(b2.top, a2.top);
  const left = Math.max(b2.left, a2.left);
  const right = Math.min(b2.left + b2.width, a2.left + a2.width);
  const bottom = Math.min(b2.top + b2.height, a2.top + a2.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const intersectionArea = width * height;
    return intersectionArea;
  }
  return 0;
}
var SENSITIVITY = 10;
var _direction_dec;
var _delta_dec;
var _current_dec;
var _previous_dec;
var _initial_dec;
var _velocity_dec;
var _timestamp;
var _init;
var _velocity;
var _initial;
var _previous;
var _current;
_velocity_dec = [reactive], _initial_dec = [reactive], _previous_dec = [reactive], _current_dec = [reactive], _delta_dec = [derived], _direction_dec = [derived];
var Position = class {
  constructor(initialValue) {
    __runInitializers(_init, 5, this);
    __privateAdd2(this, _timestamp, 0);
    __privateAdd2(this, _velocity, __runInitializers(_init, 8, this, {
      x: 0,
      y: 0
    })), __runInitializers(_init, 11, this);
    __privateAdd2(this, _initial, __runInitializers(_init, 12, this)), __runInitializers(_init, 15, this);
    __privateAdd2(this, _previous, __runInitializers(_init, 16, this)), __runInitializers(_init, 19, this);
    __privateAdd2(this, _current, __runInitializers(_init, 20, this)), __runInitializers(_init, 23, this);
    const point = Point.from(initialValue);
    this.initial = point;
    this.current = point;
    this.previous = point;
  }
  get delta() {
    return Point.delta(this.current, this.initial);
  }
  get direction() {
    const delta = {
      x: this.current.x - this.previous.x,
      y: this.current.y - this.previous.y
    };
    if (!delta.x && !delta.y) {
      return null;
    }
    if (Math.abs(delta.x) > Math.abs(delta.y)) {
      return delta.x > 0 ? "right" : "left";
    }
    return delta.y > 0 ? "down" : "up";
  }
  reset(coordinates) {
    const point = Point.from(coordinates);
    r(() => {
      __privateSet2(this, _timestamp, 0);
      this.velocity = { x: 0, y: 0 };
      this.current = point;
      this.previous = point;
      this.initial = point;
    });
  }
  update(coordinates) {
    const { current } = this;
    const point = Point.from(coordinates);
    if (Point.equals(current, point)) {
      return;
    }
    const delta = {
      x: point.x - current.x,
      y: point.y - current.y
    };
    const timestamp = Date.now();
    const timeDelta = timestamp - __privateGet2(this, _timestamp);
    const velocity = (delta2) => Math.round(delta2 / timeDelta * 100);
    if (Math.abs(delta.x) < SENSITIVITY || Math.abs(delta.y) < SENSITIVITY) {
      this.previous = current;
    }
    __privateSet2(this, _timestamp, timestamp);
    this.velocity = {
      x: velocity(delta.x),
      y: velocity(delta.y)
    };
    this.current = point;
  }
};
_init = __decoratorStart(null);
_timestamp = /* @__PURE__ */ new WeakMap();
_velocity = /* @__PURE__ */ new WeakMap();
_initial = /* @__PURE__ */ new WeakMap();
_previous = /* @__PURE__ */ new WeakMap();
_current = /* @__PURE__ */ new WeakMap();
__decorateElement(_init, 4, "velocity", _velocity_dec, Position, _velocity);
__decorateElement(_init, 4, "initial", _initial_dec, Position, _initial);
__decorateElement(_init, 4, "previous", _previous_dec, Position, _previous);
__decorateElement(_init, 4, "current", _current_dec, Position, _current);
__decorateElement(_init, 2, "delta", _delta_dec, Position);
__decorateElement(_init, 2, "direction", _direction_dec, Position);
__decoratorMetadata(_init, Position);
function exceedsDistance({ x, y: y2 }, distance) {
  const dx = Math.abs(x);
  const dy = Math.abs(y2);
  if (typeof distance === "number") {
    return Math.sqrt(__pow(dx, 2) + __pow(dy, 2)) > distance;
  }
  if ("x" in distance && "y" in distance) {
    return dx > distance.x && dy > distance.y;
  }
  if ("x" in distance) {
    return dx > distance.x;
  }
  if ("y" in distance) {
    return dy > distance.y;
  }
  return false;
}
var Axis = ((Axis2) => {
  Axis2["Horizontal"] = "x";
  Axis2["Vertical"] = "y";
  return Axis2;
})(Axis || {});
var Axes = Object.values(Axis);

// node_modules/@dnd-kit/abstract/index.js
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp3.call(b2, prop))
      __defNormalProp3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b2)) {
      if (__propIsEnum3.call(b2, prop))
        __defNormalProp3(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart2 = (base) => {
  var _a3;
  return [, , , __create3((_a3 = base == null ? void 0 : base[__knownSymbol2("metadata")]) != null ? _a3 : null)];
};
var __decoratorStrings2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn2 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError3("Function expected") : fn;
var __decoratorContext2 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings2[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError3("Already initialized") : fns.push(__expectFn2(fn || null)) });
var __decoratorMetadata2 = (array, target) => __defNormalProp3(target, __knownSymbol2("metadata"), array[3]);
var __runInitializers2 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement2 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings2[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc3(k < 4 ? target : { get [name]() {
    return __privateGet3(this, extra);
  }, set [name](x) {
    return __privateSet3(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name2(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name2(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext2(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn2(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p2 ? (x) => (k ^ 1 ? __privateGet3 : __privateMethod2)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p2 ? (x, y2) => __privateSet3(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn2(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError3("Object expected");
    else __expectFn2(fn = it.get) && (desc.get = fn), __expectFn2(fn = it.set) && (desc.set = fn), __expectFn2(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata2(array, target), desc && __defProp3(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateIn2 = (member, obj) => Object(obj) !== obj ? __typeError3('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck3(obj, member, "access private method"), method);
function configure(plugin, options2) {
  return {
    plugin,
    options: options2
  };
}
function configurator(plugin) {
  return (options2) => {
    return configure(plugin, options2);
  };
}
function descriptor(plugin) {
  if (typeof plugin === "function") {
    return {
      plugin,
      options: void 0
    };
  }
  return plugin;
}
var _disabled_dec;
var _init2;
var _disabled;
_disabled_dec = [reactive];
var Plugin = class {
  constructor(manager, options2) {
    this.manager = manager;
    this.options = options2;
    __privateAdd3(this, _disabled, __runInitializers2(_init2, 8, this, false)), __runInitializers2(_init2, 11, this);
  }
  /**
   * Enable a disabled plugin instance.
   * Triggers effects.
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Disable an enabled plugin instance.
   * Triggers effects.
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Whether the plugin instance is disabled.
   * Does not trigger effects when accessed.
   */
  isDisabled() {
    return n(() => {
      return this.disabled;
    });
  }
  /**
   * Configure a plugin instance with new options.
   */
  configure(options2) {
    this.options = options2;
  }
  /**
   * Destroy a plugin instance.
   */
  destroy() {
  }
  /**
   * Configure a plugin constructor with options.
   * This method is used to configure the options that the
   * plugin constructor will use to create plugin instances.
   */
  static configure(options2) {
    return configure(this, options2);
  }
};
_init2 = __decoratorStart2(null);
_disabled = /* @__PURE__ */ new WeakMap();
__decorateElement2(_init2, 4, "disabled", _disabled_dec, Plugin, _disabled);
__decoratorMetadata2(_init2, Plugin);
var CorePlugin = class extends Plugin {
};
var _previousValues;
var PluginRegistry = class {
  constructor(manager) {
    this.manager = manager;
    this.instances = /* @__PURE__ */ new Map();
    __privateAdd3(this, _previousValues, []);
  }
  get values() {
    return Array.from(this.instances.values());
  }
  set values(entries) {
    const descriptors = entries.map(descriptor).reduceRight((acc, descriptor2) => {
      if (acc.some(({ plugin }) => plugin === descriptor2.plugin)) {
        return acc;
      }
      return [descriptor2, ...acc];
    }, []);
    const constructors = descriptors.map(({ plugin }) => plugin);
    for (const plugin of __privateGet3(this, _previousValues)) {
      if (!constructors.includes(plugin)) {
        if (plugin.prototype instanceof CorePlugin) {
          continue;
        }
        this.unregister(plugin);
      }
    }
    for (const { plugin, options: options2 } of descriptors) {
      this.register(plugin, options2);
    }
    __privateSet3(this, _previousValues, constructors);
  }
  get(plugin) {
    const instance = this.instances.get(plugin);
    return instance;
  }
  register(plugin, options2) {
    const existingInstance = this.instances.get(plugin);
    if (existingInstance) {
      if (existingInstance.options !== options2) {
        existingInstance.options = options2;
      }
      return existingInstance;
    }
    const instance = new plugin(this.manager, options2);
    this.instances.set(plugin, instance);
    return instance;
  }
  unregister(plugin) {
    const instance = this.instances.get(plugin);
    if (instance) {
      instance.destroy();
      this.instances.delete(plugin);
    }
  }
  destroy() {
    for (const plugin of this.instances.values()) {
      plugin.destroy();
    }
    this.instances.clear();
  }
};
_previousValues = /* @__PURE__ */ new WeakMap();
function sortCollisions(a2, b2) {
  if (a2.priority === b2.priority) {
    if (a2.type === b2.type) {
      return b2.value - a2.value;
    }
    return b2.type - a2.type;
  }
  return b2.priority - a2.priority;
}
var DEFAULT_VALUE = [];
var _previousCoordinates;
var _collisions;
var CollisionObserver = class extends Plugin {
  constructor(manager) {
    super(manager);
    __privateAdd3(this, _previousCoordinates);
    __privateAdd3(this, _collisions);
    this.computeCollisions = this.computeCollisions.bind(this);
    __privateSet3(this, _collisions, d(DEFAULT_VALUE));
    this.destroy = effects(
      () => {
        const collisions = this.computeCollisions();
        const coordinates = n(
          () => this.manager.dragOperation.position.current
        );
        const previousCoordinates = __privateGet3(this, _previousCoordinates);
        __privateSet3(this, _previousCoordinates, coordinates);
        if (previousCoordinates && coordinates.x == previousCoordinates.x && coordinates.y == previousCoordinates.y) {
          return;
        }
        __privateGet3(this, _collisions).value = collisions;
      },
      () => {
        const { dragOperation } = this.manager;
        if (dragOperation.status.initialized) {
          this.forceUpdate();
        }
      }
    );
  }
  forceUpdate(immediate = true) {
    n(() => {
      if (immediate) {
        __privateGet3(this, _collisions).value = this.computeCollisions();
      } else {
        __privateSet3(this, _previousCoordinates, void 0);
      }
    });
  }
  computeCollisions(entries, collisionDetector) {
    const { registry, dragOperation } = this.manager;
    const { source, shape, status } = dragOperation;
    if (!status.initialized || !shape) {
      return DEFAULT_VALUE;
    }
    const collisions = [];
    for (const entry of entries != null ? entries : registry.droppables) {
      if (entry.disabled) {
        continue;
      }
      if (source && !entry.accepts(source)) {
        continue;
      }
      const detectCollision = collisionDetector != null ? collisionDetector : entry.collisionDetector;
      if (!detectCollision) {
        continue;
      }
      entry.shape;
      const collision = n(
        () => detectCollision({
          droppable: entry,
          dragOperation
        })
      );
      if (collision) {
        if (entry.collisionPriority != null) {
          collision.priority = entry.collisionPriority;
        }
        collisions.push(collision);
      }
    }
    collisions.sort(sortCollisions);
    return collisions;
  }
  get collisions() {
    return __privateGet3(this, _collisions).value;
  }
};
_previousCoordinates = /* @__PURE__ */ new WeakMap();
_collisions = /* @__PURE__ */ new WeakMap();
var Monitor = class {
  constructor() {
    this.registry = /* @__PURE__ */ new Map();
  }
  addEventListener(name, handler) {
    const { registry } = this;
    const listeners = new Set(registry.get(name));
    listeners.add(handler);
    registry.set(name, listeners);
    return () => this.removeEventListener(name, handler);
  }
  removeEventListener(name, handler) {
    const { registry } = this;
    const listeners = new Set(registry.get(name));
    listeners.delete(handler);
    registry.set(name, listeners);
  }
  dispatch(name, ...args) {
    const { registry } = this;
    const listeners = registry.get(name);
    if (!listeners) {
      return;
    }
    for (const listener of listeners) {
      listener(...args);
    }
  }
};
var DragDropMonitor = class extends Monitor {
  constructor(manager) {
    super();
    this.manager = manager;
  }
  dispatch(type, event) {
    const args = [event, this.manager];
    super.dispatch(type, ...args);
  }
};
function defaultPreventable(event, cancelable = true) {
  let defaultPrevented = false;
  return __spreadProps2(__spreadValues3({}, event), {
    cancelable,
    get defaultPrevented() {
      return defaultPrevented;
    },
    preventDefault() {
      if (!cancelable) {
        return;
      }
      defaultPrevented = true;
    }
  });
}
var CollisionNotifier = class extends CorePlugin {
  constructor(manager) {
    super(manager);
    const isEqual = (a2, b2) => a2.map(({ id }) => id).join("") === b2.map(({ id }) => id).join("");
    let previousCollisions = [];
    this.destroy = effects(
      () => {
        const { dragOperation, collisionObserver } = manager;
        if (dragOperation.status.initializing) {
          previousCollisions = [];
          collisionObserver.enable();
        }
      },
      () => {
        const { collisionObserver, monitor } = manager;
        const { collisions } = collisionObserver;
        if (collisionObserver.isDisabled()) {
          return;
        }
        const event = defaultPreventable({
          collisions
        });
        monitor.dispatch("collision", event);
        if (event.defaultPrevented) {
          return;
        }
        if (isEqual(collisions, previousCollisions)) {
          return;
        } else {
          previousCollisions = collisions;
        }
        const [firstCollision] = collisions;
        n(() => {
          var _a3;
          if ((firstCollision == null ? void 0 : firstCollision.id) !== ((_a3 = manager.dragOperation.target) == null ? void 0 : _a3.id)) {
            collisionObserver.disable();
            manager.actions.setDropTarget(firstCollision == null ? void 0 : firstCollision.id).then(() => {
              collisionObserver.enable();
            });
          }
        });
      }
    );
  }
};
var CollisionPriority = ((CollisionPriority2) => {
  CollisionPriority2[CollisionPriority2["Lowest"] = 0] = "Lowest";
  CollisionPriority2[CollisionPriority2["Low"] = 1] = "Low";
  CollisionPriority2[CollisionPriority2["Normal"] = 2] = "Normal";
  CollisionPriority2[CollisionPriority2["High"] = 3] = "High";
  CollisionPriority2[CollisionPriority2["Highest"] = 4] = "Highest";
  return CollisionPriority2;
})(CollisionPriority || {});
var CollisionType = ((CollisionType2) => {
  CollisionType2[CollisionType2["Collision"] = 0] = "Collision";
  CollisionType2[CollisionType2["ShapeIntersection"] = 1] = "ShapeIntersection";
  CollisionType2[CollisionType2["PointerIntersection"] = 2] = "PointerIntersection";
  return CollisionType2;
})(CollisionType || {});
var _disabled_dec2;
var _data_dec;
var _id_dec;
var _manager_dec;
var _init22;
var _manager;
var _id;
var _data;
var _disabled2;
_manager_dec = [reactive], _id_dec = [reactive], _data_dec = [reactive], _disabled_dec2 = [reactive];
var Entity = class {
  /**
   * Creates a new instance of the `Entity` class.
   *
   * @param input - An object containing the initial properties of the entity.
   * @param manager - The manager that controls the drag and drop operations.
   */
  constructor(input, manager) {
    __privateAdd3(this, _manager, __runInitializers2(_init22, 8, this)), __runInitializers2(_init22, 11, this);
    __privateAdd3(this, _id, __runInitializers2(_init22, 12, this)), __runInitializers2(_init22, 15, this);
    __privateAdd3(this, _data, __runInitializers2(_init22, 16, this)), __runInitializers2(_init22, 19, this);
    __privateAdd3(this, _disabled2, __runInitializers2(_init22, 20, this)), __runInitializers2(_init22, 23, this);
    const { effects: effects5, id, data = {}, disabled = false } = input;
    let previousId = id;
    this.manager = manager;
    this.id = id;
    this.data = data;
    this.disabled = disabled;
    this.effects = () => {
      var _a3;
      return [
        () => {
          const { id: id2, manager: manager2 } = this;
          if (id2 === previousId) {
            return;
          }
          manager2 == null ? void 0 : manager2.registry.register(this);
          return () => manager2 == null ? void 0 : manager2.registry.unregister(this);
        },
        ...(_a3 = effects5 == null ? void 0 : effects5()) != null ? _a3 : []
      ];
    };
    this.register = this.register.bind(this);
    this.unregister = this.unregister.bind(this);
    this.destroy = this.destroy.bind(this);
    if (manager) {
      queueMicrotask(() => {
        var _a3;
        return (_a3 = this.manager) == null ? void 0 : _a3.registry.register(this);
      });
    }
  }
  /**
   * A method that registers the entity with the manager.
   * @returns CleanupFunction | void
   */
  register() {
    var _a3;
    return (_a3 = this.manager) == null ? void 0 : _a3.registry.register(this);
  }
  /**
   * A method that unregisters the entity from the manager.
   * @returns void
   */
  unregister() {
    var _a3;
    (_a3 = this.manager) == null ? void 0 : _a3.registry.unregister(this);
  }
  /**
   * A method that cleans up the entity when it is no longer needed.
   * @returns void
   */
  destroy() {
    var _a3;
    (_a3 = this.manager) == null ? void 0 : _a3.registry.unregister(this);
  }
};
_init22 = __decoratorStart2(null);
_manager = /* @__PURE__ */ new WeakMap();
_id = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_disabled2 = /* @__PURE__ */ new WeakMap();
__decorateElement2(_init22, 4, "manager", _manager_dec, Entity, _manager);
__decorateElement2(_init22, 4, "id", _id_dec, Entity, _id);
__decorateElement2(_init22, 4, "data", _data_dec, Entity, _data);
__decorateElement2(_init22, 4, "disabled", _disabled_dec2, Entity, _disabled2);
__decoratorMetadata2(_init22, Entity);
var EntityRegistry = class {
  constructor() {
    this.map = d(/* @__PURE__ */ new Map());
    this.cleanupFunctions = /* @__PURE__ */ new WeakMap();
    this.register = (key, value) => {
      const current = this.map.peek();
      const currentValue2 = current.get(key);
      const unregister = () => this.unregister(key, value);
      if (currentValue2 === value) return unregister;
      if (currentValue2) {
        const cleanup2 = this.cleanupFunctions.get(currentValue2);
        cleanup2 == null ? void 0 : cleanup2();
        this.cleanupFunctions.delete(currentValue2);
      }
      const updatedMap = new Map(current);
      updatedMap.set(key, value);
      this.map.value = updatedMap;
      const cleanup = effects(...value.effects());
      this.cleanupFunctions.set(value, cleanup);
      return unregister;
    };
    this.unregister = (key, value) => {
      const current = this.map.peek();
      if (current.get(key) !== value) {
        return;
      }
      const cleanup = this.cleanupFunctions.get(value);
      cleanup == null ? void 0 : cleanup();
      this.cleanupFunctions.delete(value);
      const updatedMap = new Map(current);
      updatedMap.delete(key);
      this.map.value = updatedMap;
    };
  }
  /**
   * Iterator for the EntityRegistry class.
   * @returns An iterator for the values in the map.
   */
  [Symbol.iterator]() {
    return this.map.peek().values();
  }
  get value() {
    return this.map.value.values();
  }
  /**
   * Checks if a entity with the given identifier exists in the registry.
   * @param identifier - The unique identifier of the entity.
   * @returns True if the entity exists, false otherwise.
   */
  has(identifier) {
    return this.map.value.has(identifier);
  }
  /**
   * Retrieves a entity from the registry using its identifier.
   * @param identifier - The unique identifier of the entity.
   * @returns The entity if it exists, undefined otherwise.
   */
  get(identifier) {
    return this.map.value.get(identifier);
  }
  /**
   * Destroys all entries in the registry and clears the registry.
   */
  destroy() {
    for (const entry of this) {
      const cleanup = this.cleanupFunctions.get(entry);
      cleanup == null ? void 0 : cleanup();
      entry.destroy();
    }
    this.map.value = /* @__PURE__ */ new Map();
  }
};
var _isDragSource_dec;
var _status_dec;
var _type_dec;
var _modifiers_dec;
var _c;
var _init3;
var _modifiers;
var _type;
var _status;
var Draggable = class extends (_c = Entity, _modifiers_dec = [reactive], _type_dec = [reactive], _status_dec = [reactive], _isDragSource_dec = [derived], _c) {
  constructor(_a3, manager) {
    var _b2 = _a3, { modifiers, type, sensors } = _b2, input = __objRest2(_b2, ["modifiers", "type", "sensors"]);
    super(input, manager);
    __runInitializers2(_init3, 5, this);
    __privateAdd3(this, _modifiers, __runInitializers2(_init3, 8, this)), __runInitializers2(_init3, 11, this);
    __privateAdd3(this, _type, __runInitializers2(_init3, 12, this)), __runInitializers2(_init3, 15, this);
    __privateAdd3(this, _status, __runInitializers2(_init3, 16, this, "idle")), __runInitializers2(_init3, 19, this);
    this.type = type;
    this.sensors = sensors;
    this.modifiers = modifiers;
  }
  get isDragSource() {
    var _a3, _b2;
    return ((_b2 = (_a3 = this.manager) == null ? void 0 : _a3.dragOperation.source) == null ? void 0 : _b2.id) === this.id;
  }
};
_init3 = __decoratorStart2(_c);
_modifiers = /* @__PURE__ */ new WeakMap();
_type = /* @__PURE__ */ new WeakMap();
_status = /* @__PURE__ */ new WeakMap();
__decorateElement2(_init3, 4, "modifiers", _modifiers_dec, Draggable, _modifiers);
__decorateElement2(_init3, 4, "type", _type_dec, Draggable, _type);
__decorateElement2(_init3, 4, "status", _status_dec, Draggable, _status);
__decorateElement2(_init3, 2, "isDragSource", _isDragSource_dec, Draggable);
__decoratorMetadata2(_init3, Draggable);
var _isDropTarget_dec;
var _shape_dec;
var _collisionPriority_dec;
var _collisionDetector_dec;
var _type_dec2;
var _accept_dec;
var _c2;
var _init4;
var _accept;
var _type2;
var _collisionDetector;
var _collisionPriority;
var _shape;
var Droppable = class extends (_c2 = Entity, _accept_dec = [reactive], _type_dec2 = [reactive], _collisionDetector_dec = [reactive], _collisionPriority_dec = [reactive], _shape_dec = [reactive], _isDropTarget_dec = [derived], _c2) {
  constructor(_a3, manager) {
    var _b2 = _a3, { accept, collisionDetector, collisionPriority, type } = _b2, input = __objRest2(_b2, ["accept", "collisionDetector", "collisionPriority", "type"]);
    super(input, manager);
    __runInitializers2(_init4, 5, this);
    __privateAdd3(this, _accept, __runInitializers2(_init4, 8, this)), __runInitializers2(_init4, 11, this);
    __privateAdd3(this, _type2, __runInitializers2(_init4, 12, this)), __runInitializers2(_init4, 15, this);
    __privateAdd3(this, _collisionDetector, __runInitializers2(_init4, 16, this)), __runInitializers2(_init4, 19, this);
    __privateAdd3(this, _collisionPriority, __runInitializers2(_init4, 20, this)), __runInitializers2(_init4, 23, this);
    __privateAdd3(this, _shape, __runInitializers2(_init4, 24, this)), __runInitializers2(_init4, 27, this);
    this.accept = accept;
    this.collisionDetector = collisionDetector;
    this.collisionPriority = collisionPriority;
    this.type = type;
  }
  /**
   * Checks whether or not the droppable accepts a given draggable.
   *
   * @param {Draggable} draggable
   * @returns {boolean}
   */
  accepts(draggable) {
    const { accept } = this;
    if (!accept) {
      return true;
    }
    if (typeof accept === "function") {
      return accept(draggable);
    }
    if (!draggable.type) {
      return false;
    }
    if (Array.isArray(accept)) {
      return accept.includes(draggable.type);
    }
    return draggable.type === accept;
  }
  get isDropTarget() {
    var _a3, _b2;
    return ((_b2 = (_a3 = this.manager) == null ? void 0 : _a3.dragOperation.target) == null ? void 0 : _b2.id) === this.id;
  }
};
_init4 = __decoratorStart2(_c2);
_accept = /* @__PURE__ */ new WeakMap();
_type2 = /* @__PURE__ */ new WeakMap();
_collisionDetector = /* @__PURE__ */ new WeakMap();
_collisionPriority = /* @__PURE__ */ new WeakMap();
_shape = /* @__PURE__ */ new WeakMap();
__decorateElement2(_init4, 4, "accept", _accept_dec, Droppable, _accept);
__decorateElement2(_init4, 4, "type", _type_dec2, Droppable, _type2);
__decorateElement2(_init4, 4, "collisionDetector", _collisionDetector_dec, Droppable, _collisionDetector);
__decorateElement2(_init4, 4, "collisionPriority", _collisionPriority_dec, Droppable, _collisionPriority);
__decorateElement2(_init4, 4, "shape", _shape_dec, Droppable, _shape);
__decorateElement2(_init4, 2, "isDropTarget", _isDropTarget_dec, Droppable);
__decoratorMetadata2(_init4, Droppable);
var Sensor = class extends Plugin {
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.options = options2;
  }
};
var Modifier = class extends Plugin {
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.options = options2;
  }
  apply(operation) {
    return operation.transform;
  }
};
var DragDropRegistry = class {
  constructor(manager) {
    this.draggables = new EntityRegistry();
    this.droppables = new EntityRegistry();
    this.plugins = new PluginRegistry(manager);
    this.sensors = new PluginRegistry(manager);
    this.modifiers = new PluginRegistry(manager);
  }
  register(input, options2) {
    if (input instanceof Draggable) {
      return this.draggables.register(input.id, input);
    }
    if (input instanceof Droppable) {
      return this.droppables.register(input.id, input);
    }
    if (input.prototype instanceof Modifier) {
      return this.modifiers.register(input, options2);
    }
    if (input.prototype instanceof Sensor) {
      return this.sensors.register(input, options2);
    }
    if (input.prototype instanceof Plugin) {
      return this.plugins.register(input, options2);
    }
    throw new Error("Invalid instance type");
  }
  unregister(input) {
    if (input instanceof Entity) {
      if (input instanceof Draggable) {
        return this.draggables.unregister(input.id, input);
      }
      if (input instanceof Droppable) {
        return this.droppables.unregister(input.id, input);
      }
      return () => {
      };
    }
    if (input.prototype instanceof Modifier) {
      return this.modifiers.unregister(input);
    }
    if (input.prototype instanceof Sensor) {
      return this.sensors.unregister(input);
    }
    if (input.prototype instanceof Plugin) {
      return this.plugins.unregister(input);
    }
    throw new Error("Invalid instance type");
  }
  destroy() {
    this.draggables.destroy();
    this.droppables.destroy();
    this.plugins.destroy();
    this.sensors.destroy();
    this.modifiers.destroy();
  }
};
var Status = ((Status2) => {
  Status2["Idle"] = "idle";
  Status2["Initializing"] = "initializing";
  Status2["Dragging"] = "dragging";
  Status2["Dropped"] = "dropped";
  return Status2;
})(Status || {});
function DragOperationManager(manager) {
  const {
    registry: { draggables, droppables },
    monitor
  } = manager;
  const status = d(
    "idle"
    /* Idle */
  );
  const shape = {
    initial: d(null),
    current: d(null)
  };
  const canceled = d(false);
  const position = new Position({ x: 0, y: 0 });
  const activatorEvent = d(null);
  const sourceIdentifier = d(null);
  const targetIdentifier = d(null);
  const dragging = computed(
    () => status.value === "dragging"
    /* Dragging */
  );
  const initialized = computed(
    () => status.value !== "idle"
    /* Idle */
  );
  const initializing = computed(
    () => status.value === "initializing"
    /* Initializing */
  );
  const idle = computed(
    () => status.value === "idle"
    /* Idle */
  );
  const dropped = computed(
    () => status.value === "dropped"
    /* Dropped */
  );
  const dragended = d(true);
  let previousSource;
  const source = computed(() => {
    var _a3;
    const identifier = sourceIdentifier.value;
    if (identifier == null) return null;
    const value = draggables.get(identifier);
    if (value) {
      previousSource = value;
    }
    return (_a3 = value != null ? value : previousSource) != null ? _a3 : null;
  });
  const target = computed(() => {
    var _a3;
    const identifier = targetIdentifier.value;
    return identifier != null ? (_a3 = droppables.get(identifier)) != null ? _a3 : null : null;
  });
  const modifiers = d([]);
  const dispose = E(() => {
    var _a3, _b2, _c32;
    const currentModifiers = modifiers.peek();
    if (!deepEqual(currentModifiers, manager.modifiers)) {
      currentModifiers.forEach((modifier) => modifier.destroy());
    }
    modifiers.value = (_c32 = (_b2 = (_a3 = source.value) == null ? void 0 : _a3.modifiers) == null ? void 0 : _b2.map((modifier) => {
      const { plugin, options: options2 } = descriptor(modifier);
      return new plugin(manager, options2);
    })) != null ? _c32 : manager.modifiers;
  });
  const transform = computed(() => {
    const { x, y: y2 } = position.delta;
    let transform2 = { x, y: y2 };
    const initialShape = shape.initial.peek();
    const currentShape = shape.current.peek();
    const operation2 = {
      activatorEvent: activatorEvent.peek(),
      canceled: canceled.peek(),
      source: source.peek(),
      target: target.peek(),
      status: {
        current: status.peek(),
        idle: idle.peek(),
        initializing: initializing.peek(),
        initialized: initialized.peek(),
        dragging: dragging.peek(),
        dragended: dragended.peek(),
        dropped: dropped.peek()
      },
      shape: initialShape && currentShape ? { initial: initialShape, current: currentShape } : null,
      position
    };
    for (const modifier of modifiers.value) {
      transform2 = modifier.apply(__spreadProps2(__spreadValues3({}, operation2), { transform: transform2 }));
    }
    return transform2;
  });
  const operation = {
    get activatorEvent() {
      return activatorEvent.value;
    },
    get canceled() {
      return canceled.value;
    },
    get source() {
      return source.value;
    },
    get target() {
      return target.value;
    },
    status: {
      get current() {
        return status.value;
      },
      get idle() {
        return idle.value;
      },
      get initializing() {
        return initializing.value;
      },
      get initialized() {
        return initialized.value;
      },
      get dragging() {
        return dragging.value;
      },
      get dragended() {
        return dragended.value;
      },
      get dropped() {
        return dropped.value;
      }
    },
    get shape() {
      const initial = shape.initial.value;
      const current = shape.current.value;
      return initial && current ? { initial, current } : null;
    },
    set shape(value) {
      var _a3;
      if (value && ((_a3 = shape.current.peek()) == null ? void 0 : _a3.equals(value))) {
        return;
      }
      const initial = shape.initial.peek();
      if (!initial) {
        shape.initial.value = value;
      }
      shape.current.value = value;
    },
    get transform() {
      return transform.value;
    },
    position
  };
  const reset = () => {
    r(() => {
      status.value = "idle";
      sourceIdentifier.value = null;
      targetIdentifier.value = null;
      shape.current.value = null;
      shape.initial.value = null;
      position.reset({ x: 0, y: 0 });
      modifiers.value = [];
    });
  };
  const actions = {
    setDragSource(identifier) {
      sourceIdentifier.value = identifier;
    },
    setDropTarget(identifier) {
      const id = identifier != null ? identifier : null;
      if (targetIdentifier.peek() === id) {
        return Promise.resolve(false);
      }
      targetIdentifier.value = id;
      const event = defaultPreventable({
        operation: snapshot(operation)
      });
      if (status.peek() === "dragging") {
        monitor.dispatch("dragover", event);
      }
      return manager.renderer.rendering.then(() => event.defaultPrevented);
    },
    start({ event, coordinates }) {
      const sourceInstance = source.peek();
      if (!sourceInstance) {
        throw new Error("Cannot start a drag operation without a drag source");
      }
      r(() => {
        shape.initial.value = null;
        shape.current.value = null;
        dragended.value = false;
        canceled.value = false;
        activatorEvent.value = event;
        position.reset(coordinates);
      });
      const beforeStartEvent = defaultPreventable({
        operation: snapshot(operation)
      });
      monitor.dispatch("beforedragstart", beforeStartEvent);
      manager.renderer.rendering.then(() => {
        if (beforeStartEvent.defaultPrevented) {
          reset();
          return;
        }
        status.value = "initializing";
        requestAnimationFrame(() => {
          status.value = "dragging";
          monitor.dispatch("dragstart", {
            operation: snapshot(operation),
            cancelable: false
          });
        });
      });
    },
    move({
      by,
      to,
      cancelable = true
    }) {
      if (!dragging.peek()) {
        return;
      }
      const event = defaultPreventable(
        {
          operation: snapshot(operation),
          by,
          to
        },
        cancelable
      );
      monitor.dispatch("dragmove", event);
      queueMicrotask(() => {
        if (event.defaultPrevented) {
          return;
        }
        const coordinates = to != null ? to : {
          x: position.current.x + by.x,
          y: position.current.y + by.y
        };
        position.update(coordinates);
      });
    },
    stop({ canceled: eventCanceled = false } = {}) {
      let promise;
      const suspend = () => {
        const output = {
          resume: () => {
          },
          abort: () => {
          }
        };
        promise = new Promise((resolve, reject) => {
          output.resume = resolve;
          output.abort = reject;
        });
        return output;
      };
      const end = () => {
        manager.renderer.rendering.then(() => {
          status.value = "dropped";
          manager.renderer.rendering.then(reset);
        });
      };
      r(() => {
        dragended.value = true;
        canceled.value = eventCanceled;
      });
      monitor.dispatch("dragend", {
        operation: snapshot(operation),
        canceled: eventCanceled,
        suspend
      });
      if (promise) {
        promise.then(end).catch(reset);
      } else {
        end();
      }
    }
  };
  return {
    operation,
    actions,
    cleanup() {
      if (status.peek() !== "idle") {
        actions.stop({ canceled: true });
      }
      modifiers.value.forEach((modifier) => modifier.destroy());
      dispose();
    }
  };
}
function snapshot(obj) {
  return __spreadValues3({}, obj);
}
var defaultRenderer = {
  get rendering() {
    return Promise.resolve();
  }
};
var DragDropManager = class {
  constructor(config) {
    this.destroy = () => {
      this.registry.destroy();
      this.collisionObserver.destroy();
    };
    const {
      plugins = [],
      sensors = [],
      modifiers = [],
      renderer = defaultRenderer
    } = config != null ? config : {};
    const monitor = new DragDropMonitor(this);
    const registry = new DragDropRegistry(this);
    this.registry = registry;
    this.monitor = monitor;
    this.renderer = renderer;
    const { actions, operation, cleanup } = DragOperationManager(this);
    this.actions = actions;
    this.dragOperation = operation;
    this.collisionObserver = new CollisionObserver(this);
    this.plugins = [CollisionNotifier, ...plugins];
    this.modifiers = modifiers;
    this.sensors = sensors;
    const { destroy } = this;
    this.destroy = () => {
      cleanup();
      destroy();
    };
  }
  get plugins() {
    return this.registry.plugins.values;
  }
  set plugins(plugins) {
    this.registry.plugins.values = plugins;
  }
  get modifiers() {
    return this.registry.modifiers.values;
  }
  set modifiers(modifiers) {
    this.registry.modifiers.values = modifiers;
  }
  get sensors() {
    return this.registry.sensors.values;
  }
  set sensors(sensors) {
    this.registry.sensors.values = sensors;
  }
};

// node_modules/@dnd-kit/dom/utilities.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
function getBoundingRectangle(element) {
  const { width, height, top, left, bottom, right } = element.getBoundingClientRect();
  return { width, height, top, left, bottom, right };
}
var canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || // In Electron context the Window object serializes to [object global]
  elementString === "[object global]";
}
function isNode(node) {
  return "nodeType" in node;
}
function getWindow(target) {
  var _a3, _b2, _c4;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode(target)) {
    return window;
  }
  if ("defaultView" in target) {
    return (_a3 = target.defaultView) != null ? _a3 : window;
  }
  return (_c4 = (_b2 = target.ownerDocument) == null ? void 0 : _b2.defaultView) != null ? _c4 : window;
}
function isDocument(node) {
  const { Document: Document2 } = getWindow(node);
  return node instanceof Document2;
}
function isHTMLElement(node) {
  if (!node || isWindow(node)) return false;
  return node instanceof getWindow(node).HTMLElement;
}
function getDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
function getViewportBoundingRectangle(element) {
  const { documentElement } = getDocument(element);
  const width = documentElement.clientWidth;
  const height = documentElement.clientHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function timeout(callback, duration) {
  const id = setTimeout(callback, duration);
  return () => clearTimeout(id);
}
function throttle(func, limit) {
  const time = () => performance.now();
  let cancel;
  let lastRan;
  return function(...args) {
    const context = this;
    if (!lastRan) {
      func.apply(context, args);
      lastRan = time();
    } else {
      cancel == null ? void 0 : cancel();
      cancel = timeout(
        () => {
          func.apply(context, args);
          lastRan = time();
        },
        limit - (time() - lastRan)
      );
    }
  };
}
function isRectEqual(a2, b2) {
  if (a2 === b2) return true;
  if (!a2 || !b2) return false;
  return a2.top == b2.top && a2.left == b2.left && a2.right == b2.right && a2.bottom == b2.bottom;
}
function isOverflowVisible(element, style) {
  if (element instanceof getWindow(element).HTMLDetailsElement && element.open === false) {
    return false;
  }
  const { overflow, overflowX, overflowY } = getComputedStyle(element);
  return overflow === "visible" && overflowX === "visible" && overflowY === "visible";
}
function getVisibleBoundingRectangle(element, boundingClientRect = element.getBoundingClientRect(), margin = 0) {
  var _a3;
  let rect = boundingClientRect;
  const { ownerDocument } = element;
  const ownerWindow = (_a3 = ownerDocument.defaultView) != null ? _a3 : window;
  let ancestor = element.parentElement;
  while (ancestor && ancestor !== ownerDocument.documentElement) {
    if (!isOverflowVisible(ancestor)) {
      const ancestorRect = ancestor.getBoundingClientRect();
      const marginTop = margin * (ancestorRect.bottom - ancestorRect.top);
      const marginRight = margin * (ancestorRect.right - ancestorRect.left);
      const marginBottom = margin * (ancestorRect.bottom - ancestorRect.top);
      const marginLeft = margin * (ancestorRect.right - ancestorRect.left);
      rect = {
        top: Math.max(rect.top, ancestorRect.top - marginTop),
        right: Math.min(rect.right, ancestorRect.right + marginRight),
        bottom: Math.min(rect.bottom, ancestorRect.bottom + marginBottom),
        left: Math.max(rect.left, ancestorRect.left - marginLeft),
        width: 0,
        // Will be calculated next
        height: 0
        // Will be calculated next
      };
      rect.width = rect.right - rect.left;
      rect.height = rect.bottom - rect.top;
    }
    ancestor = ancestor.parentElement;
  }
  const viewportWidth = ownerWindow.innerWidth;
  const viewportHeight = ownerWindow.innerHeight;
  const viewportMarginY = margin * viewportHeight;
  const viewportMarginX = margin * viewportWidth;
  rect = {
    top: Math.max(rect.top, 0 - viewportMarginY),
    right: Math.min(rect.right, viewportWidth + viewportMarginX),
    bottom: Math.min(rect.bottom, viewportHeight + viewportMarginY),
    left: Math.max(rect.left, 0 - viewportMarginX),
    width: 0,
    // Will be calculated next
    height: 0
    // Will be calculated next
  };
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  if (rect.width < 0) {
    rect.width = 0;
  }
  if (rect.height < 0) {
    rect.height = 0;
  }
  return rect;
}
function isVisible(element, boundingClientRect = element.getBoundingClientRect()) {
  const { width, height } = getVisibleBoundingRectangle(
    element,
    boundingClientRect
  );
  return width > 0 && height > 0;
}
var threshold = Array.from({ length: 100 }, (_2, index) => index / 100);
var THROTTLE_INTERVAL = 75;
var _callback;
var _visible;
var _previousBoundingClientRect;
var _resizeObserver;
var _positionObserver;
var _visibilityObserver;
var _debug;
var _disconnected;
var _observePosition;
var _PositionObserver_instances;
var notify_fn;
var updateDebug_fn;
var PositionObserver = class {
  constructor(element, callback, options2 = { debug: false }) {
    this.element = element;
    __privateAdd4(this, _PositionObserver_instances);
    __privateAdd4(this, _callback);
    __privateAdd4(this, _visible, true);
    __privateAdd4(this, _previousBoundingClientRect);
    __privateAdd4(this, _resizeObserver);
    __privateAdd4(this, _positionObserver);
    __privateAdd4(this, _visibilityObserver);
    __privateAdd4(this, _debug);
    __privateAdd4(this, _disconnected, false);
    __privateAdd4(this, _observePosition, throttle(() => {
      var _a3, _b2, _c4;
      const { element: element2 } = this;
      (_a3 = __privateGet4(this, _positionObserver)) == null ? void 0 : _a3.disconnect();
      if (__privateGet4(this, _disconnected) || !__privateGet4(this, _visible) || !element2.isConnected) {
        return;
      }
      const root2 = (_b2 = element2.ownerDocument) != null ? _b2 : document;
      const { innerHeight, innerWidth } = (_c4 = root2.defaultView) != null ? _c4 : window;
      const clientRect = element2.getBoundingClientRect();
      const visibleRect = getVisibleBoundingRectangle(element2, clientRect);
      const { top, left, bottom, right } = visibleRect;
      const insetTop = -Math.floor(top);
      const insetLeft = -Math.floor(left);
      const insetRight = -Math.floor(innerWidth - right);
      const insetBottom = -Math.floor(innerHeight - bottom);
      const rootMargin = `${insetTop}px ${insetRight}px ${insetBottom}px ${insetLeft}px`;
      this.boundingClientRect = clientRect;
      __privateSet4(this, _positionObserver, new IntersectionObserver(
        (entries) => {
          const [entry] = entries;
          const { intersectionRect } = entry;
          const intersectionRatio = Rectangle.intersectionRatio(
            intersectionRect,
            visibleRect
          );
          if (intersectionRatio !== 1) {
            __privateGet4(this, _observePosition).call(this);
          }
        },
        {
          threshold,
          rootMargin,
          root: root2
        }
      ));
      __privateGet4(this, _positionObserver).observe(element2);
      __privateMethod3(this, _PositionObserver_instances, notify_fn).call(this);
    }, THROTTLE_INTERVAL));
    __privateSet4(this, _callback, callback);
    this.boundingClientRect = element.getBoundingClientRect();
    __privateSet4(this, _visible, isVisible(element, this.boundingClientRect));
    const root = element.ownerDocument;
    if (options2 == null ? void 0 : options2.debug) {
      __privateSet4(this, _debug, document.createElement("div"));
      __privateGet4(this, _debug).style.background = "rgba(0,0,0,0.15)";
      __privateGet4(this, _debug).style.position = "fixed";
      __privateGet4(this, _debug).style.pointerEvents = "none";
      root.body.appendChild(__privateGet4(this, _debug));
    }
    __privateSet4(this, _visibilityObserver, new IntersectionObserver(
      (entries) => {
        var _a3, _b2;
        const entry = entries[entries.length - 1];
        const { boundingClientRect, isIntersecting: visible } = entry;
        const { width, height } = boundingClientRect;
        const previousVisible = __privateGet4(this, _visible);
        __privateSet4(this, _visible, visible);
        if (!width && !height) return;
        if (previousVisible && !visible) {
          (_a3 = __privateGet4(this, _positionObserver)) == null ? void 0 : _a3.disconnect();
          __privateGet4(this, _callback).call(this, null);
          (_b2 = __privateGet4(this, _resizeObserver)) == null ? void 0 : _b2.disconnect();
          __privateSet4(this, _resizeObserver, void 0);
          if (__privateGet4(this, _debug)) __privateGet4(this, _debug).style.visibility = "hidden";
        } else {
          __privateGet4(this, _observePosition).call(this);
        }
        if (visible && !__privateGet4(this, _resizeObserver)) {
          __privateSet4(this, _resizeObserver, new ResizeObserver(__privateGet4(this, _observePosition)));
          __privateGet4(this, _resizeObserver).observe(element);
        }
      },
      {
        threshold,
        root
      }
    ));
    if (__privateGet4(this, _visible)) {
      __privateGet4(this, _callback).call(this, this.boundingClientRect);
    }
    __privateGet4(this, _visibilityObserver).observe(element);
  }
  disconnect() {
    var _a3, _b2, _c4;
    __privateSet4(this, _disconnected, true);
    (_a3 = __privateGet4(this, _resizeObserver)) == null ? void 0 : _a3.disconnect();
    (_b2 = __privateGet4(this, _positionObserver)) == null ? void 0 : _b2.disconnect();
    __privateGet4(this, _visibilityObserver).disconnect();
    (_c4 = __privateGet4(this, _debug)) == null ? void 0 : _c4.remove();
  }
};
_callback = /* @__PURE__ */ new WeakMap();
_visible = /* @__PURE__ */ new WeakMap();
_previousBoundingClientRect = /* @__PURE__ */ new WeakMap();
_resizeObserver = /* @__PURE__ */ new WeakMap();
_positionObserver = /* @__PURE__ */ new WeakMap();
_visibilityObserver = /* @__PURE__ */ new WeakMap();
_debug = /* @__PURE__ */ new WeakMap();
_disconnected = /* @__PURE__ */ new WeakMap();
_observePosition = /* @__PURE__ */ new WeakMap();
_PositionObserver_instances = /* @__PURE__ */ new WeakSet();
notify_fn = function() {
  if (__privateGet4(this, _disconnected)) return;
  __privateMethod3(this, _PositionObserver_instances, updateDebug_fn).call(this);
  if (isRectEqual(this.boundingClientRect, __privateGet4(this, _previousBoundingClientRect)))
    return;
  __privateGet4(this, _callback).call(this, this.boundingClientRect);
  __privateSet4(this, _previousBoundingClientRect, this.boundingClientRect);
};
updateDebug_fn = function() {
  if (__privateGet4(this, _debug)) {
    const { top, left, width, height } = getVisibleBoundingRectangle(
      this.element
    );
    __privateGet4(this, _debug).style.overflow = "hidden";
    __privateGet4(this, _debug).style.visibility = "visible";
    __privateGet4(this, _debug).style.top = `${Math.floor(top)}px`;
    __privateGet4(this, _debug).style.left = `${Math.floor(left)}px`;
    __privateGet4(this, _debug).style.width = `${Math.floor(width)}px`;
    __privateGet4(this, _debug).style.height = `${Math.floor(height)}px`;
  }
};
function isSafari() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function cloneElement(element) {
  const window2 = getWindow(element);
  const selector = "input, textarea, select, canvas, [contenteditable]";
  const clonedElement = element.cloneNode(true);
  const fields = Array.from(element.querySelectorAll(selector));
  const clonedFields = Array.from(clonedElement.querySelectorAll(selector));
  clonedFields.forEach((field, index) => {
    const originalField = fields[index];
    if (isField(field) && isField(originalField)) {
      if (field.type !== "file") {
        field.value = originalField.value;
      }
      if (field.type === "radio" && field.name) {
        field.name = `Cloned__${field.name}`;
      }
    }
    if (field instanceof window2.HTMLCanvasElement && originalField instanceof window2.HTMLCanvasElement && originalField.width > 0 && originalField.height > 0) {
      const destCtx = field.getContext("2d");
      destCtx == null ? void 0 : destCtx.drawImage(originalField, 0, 0);
    }
  });
  return clonedElement;
}
function isField(element) {
  return "value" in element;
}
function getElementFromPoint(document2, { x, y: y2 }) {
  const element = document2.elementFromPoint(x, y2);
  if (element instanceof HTMLIFrameElement) {
    const { contentDocument } = element;
    if (contentDocument) {
      const { left, top } = element.getBoundingClientRect();
      return getElementFromPoint(contentDocument, {
        x: x - left,
        y: y2 - top
      });
    }
  }
  return element;
}
var ProxiedElements = /* @__PURE__ */ new WeakMap();
var Listeners = class {
  constructor() {
    this.entries = /* @__PURE__ */ new Set();
    this.clear = () => {
      for (const entry of this.entries) {
        const [target, { type, listener, options: options2 }] = entry;
        target.removeEventListener(type, listener, options2);
      }
      this.entries.clear();
    };
  }
  bind(target, input) {
    const listeners = Array.isArray(input) ? input : [input];
    const entries = [];
    for (const descriptor2 of listeners) {
      const { type, listener, options: options2 } = descriptor2;
      const entry = [target, descriptor2];
      target.addEventListener(type, listener, options2);
      this.entries.add(entry);
      entries.push(entry);
    }
    return function cleanup() {
      for (const [target2, { type, listener, options: options2 }] of entries) {
        target2.removeEventListener(type, listener, options2);
      }
    };
  }
};
function supportsPopover(element) {
  return "showPopover" in element && "hidePopover" in element && typeof element.showPopover === "function" && typeof element.hidePopover === "function";
}
function showPopover(element) {
  if (supportsPopover(element) && element.isConnected && element.hasAttribute("popover")) {
    element.showPopover();
  }
}
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === getDocument(element).scrollingElement;
}
function getScrollPosition(scrollableElement) {
  const window2 = getWindow(scrollableElement);
  const rect = isDocumentScrollingElement(scrollableElement) ? getViewportBoundingRectangle(scrollableElement) : getBoundingRectangle(scrollableElement);
  const dimensions = isDocumentScrollingElement(scrollableElement) ? {
    height: window2.innerHeight,
    width: window2.innerWidth
  } : {
    height: scrollableElement.clientHeight,
    width: scrollableElement.clientWidth
  };
  const position = {
    current: {
      x: scrollableElement.scrollLeft,
      y: scrollableElement.scrollTop
    },
    max: {
      x: scrollableElement.scrollWidth - dimensions.width,
      y: scrollableElement.scrollHeight - dimensions.height
    }
  };
  const isTop = position.current.y <= 0;
  const isLeft = position.current.x <= 0;
  const isBottom = position.current.y >= position.max.y;
  const isRight = position.current.x >= position.max.x;
  return {
    rect,
    position,
    isTop,
    isLeft,
    isBottom,
    isRight
  };
}
function canScroll(scrollableElement, by) {
  const { isTop, isBottom, isLeft, isRight, position } = getScrollPosition(scrollableElement);
  const { x, y: y2 } = by != null ? by : { x: 0, y: 0 };
  const top = !isTop && position.current.y + y2 > 0;
  const bottom = !isBottom && position.current.y + y2 < position.max.y;
  const left = !isLeft && position.current.x + x > 0;
  const right = !isRight && position.current.x + x < position.max.x;
  return {
    top,
    bottom,
    left,
    right,
    x: left || right,
    y: top || bottom
  };
}
function isSVGElement(node) {
  return node instanceof getWindow(node).SVGElement;
}
function getComputedStyles(element) {
  return getWindow(element).getComputedStyle(element);
}
function isFixed(node, computedStyle = getComputedStyles(node)) {
  return computedStyle.position === "fixed" || computedStyle.position === "sticky";
}
function isScrollable(element, computedStyle = getComputedStyles(element)) {
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties = ["overflow", "overflowX", "overflowY"];
  return properties.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
var defaultOptions = {
  excludeElement: true
};
function getScrollableAncestors(element, options2 = defaultOptions) {
  const { limit, excludeElement } = options2;
  const scrollParents = /* @__PURE__ */ new Set();
  function findScrollableAncestors(node) {
    if (limit != null && scrollParents.size >= limit) {
      return scrollParents;
    }
    if (!node) {
      return scrollParents;
    }
    if (isDocument(node) && node.scrollingElement != null && !scrollParents.has(node.scrollingElement)) {
      scrollParents.add(node.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement(node)) {
      if (isSVGElement(node)) {
        return findScrollableAncestors(node.parentElement);
      }
      return scrollParents;
    }
    if (scrollParents.has(node)) {
      return scrollParents;
    }
    const computedStyle = getComputedStyles(node);
    if (excludeElement && node === element) ;
    else if (isScrollable(node, computedStyle)) {
      scrollParents.add(node);
    }
    if (isFixed(node, computedStyle)) {
      const { scrollingElement } = node.ownerDocument;
      if (scrollingElement) scrollParents.add(scrollingElement);
      return scrollParents;
    }
    return findScrollableAncestors(node.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
  const [firstScrollableAncestor] = getScrollableAncestors(node, { limit: 1 });
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getFrameElement(el) {
  const refWindow = el == null ? void 0 : el.ownerDocument.defaultView;
  if (refWindow && refWindow.self !== refWindow.parent) {
    return refWindow.frameElement;
  }
  return null;
}
function getFrameTransform(el, boundary = window.frameElement) {
  const transform = {
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1
  };
  if (!el) return transform;
  let frame = getFrameElement(el);
  while (frame) {
    if (frame === boundary) {
      return transform;
    }
    const rect = frame.getBoundingClientRect();
    const { x: scaleX, y: scaleY } = getScale(frame, rect);
    transform.x = transform.x + rect.left;
    transform.y = transform.y + rect.top;
    transform.scaleX = transform.scaleX * scaleX;
    transform.scaleY = transform.scaleY * scaleY;
    frame = getFrameElement(frame);
  }
  return transform;
}
function getScale(element, boundingRectangle = element.getBoundingClientRect()) {
  const width = Math.round(boundingRectangle.width);
  const height = Math.round(boundingRectangle.height);
  if (isHTMLElement(element)) {
    return {
      x: width / element.offsetWidth,
      y: height / element.offsetHeight
    };
  }
  const styles2 = getComputedStyles(element);
  return {
    x: (parseFloat(styles2.width) || width) / width,
    y: (parseFloat(styles2.height) || height) / height
  };
}
var ScrollDirection = ((ScrollDirection2) => {
  ScrollDirection2[ScrollDirection2["Idle"] = 0] = "Idle";
  ScrollDirection2[ScrollDirection2["Forward"] = 1] = "Forward";
  ScrollDirection2[ScrollDirection2["Reverse"] = -1] = "Reverse";
  return ScrollDirection2;
})(ScrollDirection || {});
var defaultThreshold = {
  x: 0.2,
  y: 0.2
};
var defaultTolerance = {
  x: 10,
  y: 10
};
function detectScrollIntent(scrollableElement, coordinates, intent, acceleration = 25, thresholdPercentage = defaultThreshold, tolerance = defaultTolerance) {
  const { x, y: y2 } = coordinates;
  const { rect, isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollableElement);
  const frameTransform = getFrameTransform(scrollableElement);
  const scrollContainerRect = new Rectangle(
    rect.left * frameTransform.scaleX + frameTransform.x,
    rect.top * frameTransform.scaleY + frameTransform.y,
    rect.width * frameTransform.scaleX,
    rect.height * frameTransform.scaleY
  );
  const direction = {
    x: 0,
    y: 0
    /* Idle */
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold2 = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && y2 <= scrollContainerRect.top + threshold2.height && (intent == null ? void 0 : intent.y) !== 1 && x >= scrollContainerRect.left - tolerance.x && x <= scrollContainerRect.right + tolerance.x) {
    direction.y = -1;
    speed.y = acceleration * Math.abs(
      (scrollContainerRect.top + threshold2.height - y2) / threshold2.height
    );
  } else if (!isBottom && y2 >= scrollContainerRect.bottom - threshold2.height && (intent == null ? void 0 : intent.y) !== -1 && x >= scrollContainerRect.left - tolerance.x && x <= scrollContainerRect.right + tolerance.x) {
    direction.y = 1;
    speed.y = acceleration * Math.abs(
      (scrollContainerRect.bottom - threshold2.height - y2) / threshold2.height
    );
  }
  if (!isRight && x >= scrollContainerRect.right - threshold2.width && (intent == null ? void 0 : intent.x) !== -1 && y2 >= scrollContainerRect.top - tolerance.y && y2 <= scrollContainerRect.bottom + tolerance.y) {
    direction.x = 1;
    speed.x = acceleration * Math.abs(
      (scrollContainerRect.right - threshold2.width - x) / threshold2.width
    );
  } else if (!isLeft && x <= scrollContainerRect.left + threshold2.width && (intent == null ? void 0 : intent.x) !== 1 && y2 >= scrollContainerRect.top - tolerance.y && y2 <= scrollContainerRect.bottom + tolerance.y) {
    direction.x = -1;
    speed.x = acceleration * Math.abs(
      (scrollContainerRect.left + threshold2.width - x) / threshold2.width
    );
  }
  return {
    direction,
    speed
  };
}
function supportsScrollIntoViewIfNeeded(element) {
  return "scrollIntoViewIfNeeded" in element && typeof element.scrollIntoViewIfNeeded === "function";
}
function scrollIntoViewIfNeeded(el, centerIfNeeded = false) {
  if (supportsScrollIntoViewIfNeeded(el)) {
    el.scrollIntoViewIfNeeded(centerIfNeeded);
    return;
  }
  if (!isHTMLElement(el)) {
    return el.scrollIntoView();
  }
  var parent = getFirstScrollableAncestor(el);
  if (!isHTMLElement(parent)) {
    return;
  }
  const parentComputedStyle = getComputedStyles(parent), parentBorderTopWidth = parseInt(
    parentComputedStyle.getPropertyValue("border-top-width")
  ), parentBorderLeftWidth = parseInt(
    parentComputedStyle.getPropertyValue("border-left-width")
  ), overTop = el.offsetTop - parent.offsetTop < parent.scrollTop, overBottom = el.offsetTop - parent.offsetTop + el.clientHeight - parentBorderTopWidth > parent.scrollTop + parent.clientHeight, overLeft = el.offsetLeft - parent.offsetLeft < parent.scrollLeft, overRight = el.offsetLeft - parent.offsetLeft + el.clientWidth - parentBorderLeftWidth > parent.scrollLeft + parent.clientWidth, alignWithTop = overTop && !overBottom;
  if ((overTop || overBottom) && centerIfNeeded) {
    parent.scrollTop = el.offsetTop - parent.offsetTop - parent.clientHeight / 2 - parentBorderTopWidth + el.clientHeight / 2;
  }
  if ((overLeft || overRight) && centerIfNeeded) {
    parent.scrollLeft = el.offsetLeft - parent.offsetLeft - parent.clientWidth / 2 - parentBorderLeftWidth + el.clientWidth / 2;
  }
  if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {
    el.scrollIntoView(alignWithTop);
  }
}
var Scheduler = class {
  constructor() {
    this.tasks = /* @__PURE__ */ new Set();
    this.flush = () => {
      const tasks = this.tasks;
      this.animationFrame = void 0;
      this.tasks = /* @__PURE__ */ new Set();
      for (const task of tasks) {
        task();
      }
    };
  }
  schedule(task) {
    this.tasks.add(task);
    if (!this.animationFrame) {
      this.animationFrame = requestAnimationFrame(this.flush);
    }
  }
};
var scheduler = new Scheduler();
function inverseTransform(rect, parsedTransform, transformOrigin) {
  const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;
  const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
  const y2 = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w2 = scaleX ? rect.width / scaleX : rect.width;
  const h2 = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w2,
    height: h2,
    top: y2,
    right: x + w2,
    bottom: y2 + h2,
    left: x
  };
}
function supportsStyle(element) {
  return "style" in element && element.style instanceof getWindow(element).CSSStyleDeclaration;
}
var Styles = class {
  constructor(element) {
    this.element = element;
    this.initial = /* @__PURE__ */ new Map();
  }
  set(properties, prefix2 = "") {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const [key, value] of Object.entries(properties)) {
      const property = `${prefix2}${key}`;
      if (!this.initial.has(property)) {
        this.initial.set(property, element.style.getPropertyValue(property));
      }
      element.style.setProperty(
        property,
        typeof value === "string" ? value : `${value}px`
      );
    }
  }
  remove(properties, prefix2 = "") {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const key of properties) {
      const property = `${prefix2}${key}`;
      element.style.removeProperty(property);
    }
  }
  reset() {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const [key, value] of this.initial) {
      element.style.setProperty(key, value);
    }
    if (element.getAttribute("style") === "") {
      element.removeAttribute("style");
    }
  }
};
function animateTransform({
  element,
  keyframes,
  options: options2,
  onReady,
  onFinish
}) {
  const styles2 = new Styles(element);
  const { transitionProperty } = getComputedStyles(element);
  const properties = transitionProperty.split(", ");
  styles2.set({
    "transition-property": properties.length ? properties.filter(
      (property) => !property.includes("transform") && !property.includes("translate")
    ).join(", ") : "none"
  });
  onReady == null ? void 0 : onReady();
  element.animate(keyframes, options2).finished.then(() => {
    onFinish == null ? void 0 : onFinish();
    styles2.reset();
  });
}
function parseTranslate(translate) {
  if (translate === "none") {
    return null;
  }
  const [x, y2, z = "0"] = translate.split(" ");
  const output = { x: parseFloat(x), y: parseFloat(y2), z: parseInt(z, 10) };
  if (isNaN(output.x) && isNaN(output.y)) {
    return null;
  }
  return {
    x: isNaN(output.x) ? 0 : output.x,
    y: isNaN(output.y) ? 0 : output.y,
    z: isNaN(output.z) ? 0 : output.z
  };
}
function getFinalKeyframe(element, match) {
  const { KeyframeEffect: KeyframeEffect2 } = getWindow(element);
  const animations = element.getAnimations();
  if (animations.length > 0) {
    for (const animation of animations) {
      const { effect } = animation;
      const keyframes = effect instanceof KeyframeEffect2 ? effect.getKeyframes() : [];
      const matchedKeyframes = keyframes.filter(match);
      if (matchedKeyframes.length > 0) {
        return matchedKeyframes[matchedKeyframes.length - 1];
      }
    }
  }
  return null;
}
function computeTranslate(element, translate = getComputedStyles(element).translate, projected = true) {
  if (projected) {
    const keyframe = getFinalKeyframe(
      element,
      (keyframe2) => "translate" in keyframe2
    );
    if (keyframe) {
      const { translate: translate2 = "" } = keyframe;
      if (typeof translate2 === "string") {
        const finalTranslate = parseTranslate(translate2);
        if (finalTranslate) {
          return finalTranslate;
        }
      }
    }
  }
  if (translate) {
    const finalTranslate = parseTranslate(translate);
    if (finalTranslate) {
      return finalTranslate;
    }
  }
  return { x: 0, y: 0, z: 0 };
}
function parseScale(scale) {
  if (scale === "none") {
    return null;
  }
  const values = scale.split(" ");
  const x = parseFloat(values[0]);
  const y2 = parseFloat(values[1]);
  if (isNaN(x) && isNaN(y2)) {
    return null;
  }
  return {
    x: isNaN(x) ? y2 : x,
    y: isNaN(y2) ? x : y2
  };
}
function parseTransform(computedStyles) {
  var _a3, _b2, _c4, _d2, _e, _f, _g, _h, _i;
  const { scale, transform, translate } = computedStyles;
  const parsedScale = parseScale(scale);
  const parsedTranslate = parseTranslate(translate);
  const parsedMatrix = parseTransformMatrix(transform);
  if (!parsedMatrix && !parsedScale && !parsedTranslate) {
    return null;
  }
  const normalizedScale = {
    x: (_a3 = parsedScale == null ? void 0 : parsedScale.x) != null ? _a3 : 1,
    y: (_b2 = parsedScale == null ? void 0 : parsedScale.y) != null ? _b2 : 1
  };
  const normalizedTranslate = {
    x: (_c4 = parsedTranslate == null ? void 0 : parsedTranslate.x) != null ? _c4 : 0,
    y: (_d2 = parsedTranslate == null ? void 0 : parsedTranslate.y) != null ? _d2 : 0
  };
  const normalizedMatrix = {
    x: (_e = parsedMatrix == null ? void 0 : parsedMatrix.x) != null ? _e : 0,
    y: (_f = parsedMatrix == null ? void 0 : parsedMatrix.y) != null ? _f : 0,
    scaleX: (_g = parsedMatrix == null ? void 0 : parsedMatrix.scaleX) != null ? _g : 1,
    scaleY: (_h = parsedMatrix == null ? void 0 : parsedMatrix.scaleY) != null ? _h : 1
  };
  return {
    x: normalizedTranslate.x + normalizedMatrix.x,
    y: normalizedTranslate.y + normalizedMatrix.y,
    z: (_i = parsedTranslate == null ? void 0 : parsedTranslate.z) != null ? _i : 0,
    scaleX: normalizedScale.x * normalizedMatrix.scaleX,
    scaleY: normalizedScale.y * normalizedMatrix.scaleY
  };
}
function parseTransformMatrix(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
var DOMRectangle = class extends Rectangle {
  constructor(element, options2 = {}) {
    var _a3, _b2;
    const {
      frameTransform = getFrameTransform(element),
      ignoreTransforms,
      getBoundingClientRect = getBoundingRectangle
    } = options2;
    const resetAnimations = forceFinishAnimations(element);
    const boundingRectangle = getBoundingClientRect(element);
    let { top, left, width, height } = boundingRectangle;
    const computedStyles = getComputedStyles(element);
    const parsedTransform = parseTransform(computedStyles);
    const scale = {
      x: (_a3 = parsedTransform == null ? void 0 : parsedTransform.scaleX) != null ? _a3 : 1,
      y: (_b2 = parsedTransform == null ? void 0 : parsedTransform.scaleY) != null ? _b2 : 1
    };
    resetAnimations == null ? void 0 : resetAnimations();
    const projectedTransform = getProjectedTransform(element);
    if (parsedTransform && (ignoreTransforms || projectedTransform)) {
      const updated = inverseTransform(
        boundingRectangle,
        parsedTransform,
        computedStyles.transformOrigin
      );
      top = updated.top;
      left = updated.left;
      width = updated.width;
      height = updated.height;
    }
    if (projectedTransform && !ignoreTransforms) {
      top = top + projectedTransform.y;
      left = left + projectedTransform.x;
      width = width * projectedTransform.scaleX;
      height = height * projectedTransform.scaleY;
      scale.x = projectedTransform.scaleX;
      scale.y = projectedTransform.scaleY;
    }
    if (frameTransform) {
      if (!ignoreTransforms) {
        left *= frameTransform.scaleX;
        width *= frameTransform.scaleX;
        top *= frameTransform.scaleY;
        height *= frameTransform.scaleY;
      }
      left += frameTransform.x;
      top += frameTransform.y;
    }
    super(left, top, width, height);
    this.scale = scale;
  }
};
function getProjectedTransform(element) {
  var _a3;
  const { KeyframeEffect: KeyframeEffect2 } = getWindow(element);
  const animations = element.getAnimations();
  let projectedTransform = null;
  if (!animations.length) return null;
  for (const animation of animations) {
    const keyframes = animation.effect instanceof KeyframeEffect2 ? animation.effect.getKeyframes() : [];
    const keyframe = keyframes[keyframes.length - 1];
    if (!keyframe) continue;
    const { transform = "", translate = "", scale = "" } = keyframe;
    if (transform || translate || scale) {
      const parsedTransform = parseTransform({
        transform: typeof transform === "string" ? transform : "",
        translate: typeof translate === "string" ? translate : "",
        scale: typeof scale === "string" ? scale : ""
      });
      if (parsedTransform) {
        projectedTransform = projectedTransform ? {
          x: projectedTransform.x + parsedTransform.x,
          y: projectedTransform.y + parsedTransform.y,
          z: (_a3 = projectedTransform.z) != null ? _a3 : parsedTransform.z,
          scaleX: projectedTransform.scaleX * parsedTransform.scaleX,
          scaleY: projectedTransform.scaleY * parsedTransform.scaleY
        } : parsedTransform;
      }
    }
  }
  return projectedTransform;
}
function forceFinishAnimations(element) {
  const { KeyframeEffect: KeyframeEffect2 } = getWindow(element);
  const animations = element.ownerDocument.getAnimations().filter((animation) => {
    if (animation.effect instanceof KeyframeEffect2) {
      const { target } = animation.effect;
      if (target !== element && (target == null ? void 0 : target.contains(element))) {
        return animation.effect.getKeyframes().some((keyframe) => {
          const { transform, translate, scale, width, height } = keyframe;
          return transform || translate || scale || width || height;
        });
      }
    }
  }).map((animation) => {
    const { effect, currentTime } = animation;
    const duration = effect == null ? void 0 : effect.getComputedTiming().duration;
    if (animation.pending) return;
    if (typeof duration == "number" && typeof currentTime == "number" && currentTime < duration) {
      animation.currentTime = duration;
      return () => {
        animation.currentTime = currentTime;
      };
    }
  });
  if (animations.length > 0) {
    return () => animations.forEach((reset) => reset == null ? void 0 : reset());
  }
}
function isElement(target) {
  return target instanceof getWindow(target).Element;
}
function isKeyboardEvent(event) {
  if (!event) return false;
  const { KeyboardEvent } = getWindow(event.target);
  return event instanceof KeyboardEvent;
}
function isPointerEvent(event) {
  if (!event) return false;
  const { PointerEvent: PointerEvent2 } = getWindow(event.target);
  return event instanceof PointerEvent2;
}
var ids = {};
function generateUniqueId(prefix2) {
  const id = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
  ids[prefix2] = id;
  return `${prefix2}-${id}`;
}

// node_modules/@dnd-kit/collision/dist/index.js
var pointerIntersection = ({
  dragOperation,
  droppable
}) => {
  const pointerCoordinates = dragOperation.position.current;
  if (!pointerCoordinates) {
    return null;
  }
  const { id } = droppable;
  if (!droppable.shape) {
    return null;
  }
  if (droppable.shape.containsPoint(pointerCoordinates)) {
    const distance = Point.distance(droppable.shape.center, pointerCoordinates);
    return {
      id,
      value: 1 / distance,
      type: CollisionType.PointerIntersection,
      priority: CollisionPriority.High
    };
  }
  return null;
};
var shapeIntersection = ({
  dragOperation,
  droppable
}) => {
  const { shape } = dragOperation;
  if (!droppable.shape || !(shape == null ? void 0 : shape.current)) {
    return null;
  }
  const intersectionArea = shape.current.intersectionArea(droppable.shape);
  if (intersectionArea) {
    const { position } = dragOperation;
    const distance = Point.distance(droppable.shape.center, position.current);
    const intersectionRatio = intersectionArea / (shape.current.area + droppable.shape.area - intersectionArea);
    const value = intersectionRatio / distance;
    return {
      id: droppable.id,
      value,
      type: CollisionType.ShapeIntersection,
      priority: CollisionPriority.Normal
    };
  }
  return null;
};
var defaultCollisionDetection = (args) => {
  var _a3;
  return (_a3 = pointerIntersection(args)) != null ? _a3 : shapeIntersection(args);
};
var closestCorners = (input) => {
  const { dragOperation, droppable } = input;
  const { shape, position } = dragOperation;
  if (!droppable.shape) {
    return null;
  }
  const { left, top, right, bottom } = droppable.shape.boundingRectangle;
  const corners = [
    {
      x: left,
      y: top
    },
    {
      x: right,
      y: top
    },
    {
      x: left,
      y: bottom
    },
    {
      x: right,
      y: bottom
    }
  ];
  const distance = corners.reduce(
    (acc, corner) => {
      var _a3;
      return acc + Point.distance(
        Point.from(corner),
        (_a3 = shape == null ? void 0 : shape.current.center) != null ? _a3 : position.current
      );
    },
    0
  );
  const value = distance / 4;
  return {
    id: droppable.id,
    value: 1 / value,
    type: CollisionType.Collision,
    priority: CollisionPriority.Normal
  };
};

// node_modules/@dnd-kit/dom/index.js
var __create4 = Object.create;
var __defProp4 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __knownSymbol3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp4.call(b2, prop))
      __defNormalProp4(a2, prop, b2[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b2)) {
      if (__propIsEnum4.call(b2, prop))
        __defNormalProp4(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps3 = (a2, b2) => __defProps3(a2, __getOwnPropDescs3(b2));
var __name3 = (target, value) => __defProp4(target, "name", { value, configurable: true });
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart3 = (base) => {
  var _a3;
  return [, , , __create4((_a3 = base == null ? void 0 : base[__knownSymbol3("metadata")]) != null ? _a3 : null)];
};
var __decoratorStrings3 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn3 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError5("Function expected") : fn;
var __decoratorContext3 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings3[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError5("Already initialized") : fns.push(__expectFn3(fn || null)) });
var __decoratorMetadata3 = (array, target) => __defNormalProp4(target, __knownSymbol3("metadata"), array[3]);
var __runInitializers3 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement3 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings3[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc4(k < 4 ? target : { get [name]() {
    return __privateGet5(this, extra);
  }, set [name](x) {
    return __privateSet5(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name3(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name3(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext3(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn3(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p2 ? (x) => (k ^ 1 ? __privateGet5 : __privateMethod4)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p2 ? (x, y2) => __privateSet5(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn3(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError5("Object expected");
    else __expectFn3(fn = it.get) && (desc.get = fn), __expectFn3(fn = it.set) && (desc.set = fn), __expectFn3(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata3(array, target), desc && __defProp4(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateIn3 = (member, obj) => Object(obj) !== obj ? __typeError5('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var defaultAttributes = {
  role: "button",
  roleDescription: "draggable",
  tabIndex: 0
};
var defaultDescriptionIdPrefix = `dnd-kit-description`;
var defaultAnnouncementIdPrefix = `dnd-kit-announcement`;
var defaultScreenReaderInstructions = {
  draggable: `To pick up a draggable item, press the space bar. While dragging, use the arrow keys to move the item in a given direction. Press space again to drop the item in its new position, or press escape to cancel.`
};
var defaultAnnouncements = {
  dragstart({ operation: { source } }) {
    if (!source) return;
    return `Picked up draggable item ${source.id}.`;
  },
  dragover({ operation: { source, target } }) {
    if (!source) return;
    if (target) {
      return `Draggable item ${source.id} was moved over droppable target ${target.id}.`;
    }
    return `Draggable item ${source.id} is no longer over a droppable target.`;
  },
  dragend({ operation: { source, target }, canceled }) {
    if (!source) return;
    if (canceled) {
      return `Dragging was cancelled. Draggable item ${source.id} was dropped.`;
    }
    if (target) {
      return `Draggable item ${source.id} was dropped over droppable target ${target.id}`;
    }
    return `Draggable item ${source.id} was dropped.`;
  }
};
function isFocusable(element) {
  const window2 = getWindow(element);
  return element instanceof window2.HTMLInputElement || element instanceof window2.HTMLSelectElement || element instanceof window2.HTMLTextAreaElement || element instanceof window2.HTMLAnchorElement || element instanceof window2.HTMLButtonElement || element instanceof window2.HTMLAreaElement;
}
function createHiddenText(id, value) {
  const element = document.createElement("div");
  element.id = id;
  element.style.setProperty("display", "none");
  element.innerText = value;
  return element;
}
function createLiveRegion(id) {
  const element = document.createElement("div");
  element.id = id;
  element.setAttribute("role", "status");
  element.setAttribute("aria-live", "polite");
  element.setAttribute("aria-atomic", "true");
  element.style.setProperty("position", "fixed");
  element.style.setProperty("width", "1px");
  element.style.setProperty("height", "1px");
  element.style.setProperty("margin", "-1px");
  element.style.setProperty("border", "0");
  element.style.setProperty("padding", "0");
  element.style.setProperty("overflow", "hidden");
  element.style.setProperty("clip", "rect(0 0 0 0)");
  element.style.setProperty("clip-path", "inset(100%)");
  element.style.setProperty("white-space", "nowrap");
  return element;
}
var Accessibility = class extends Plugin {
  constructor(manager, options2) {
    super(manager);
    const {
      id,
      idPrefix: {
        description: descriptionPrefix = defaultDescriptionIdPrefix,
        announcement: announcementPrefix = defaultAnnouncementIdPrefix
      } = {},
      announcements = defaultAnnouncements,
      screenReaderInstructions = defaultScreenReaderInstructions
    } = options2 != null ? options2 : {};
    const descriptionId = id ? `${descriptionPrefix}-${id}` : generateUniqueId(descriptionPrefix);
    const announcementId = id ? `${announcementPrefix}-${id}` : generateUniqueId(announcementPrefix);
    let hiddenTextElement;
    let liveRegionElement;
    const eventListeners = Object.entries(announcements).map(
      ([eventName, getAnnouncement]) => {
        return this.manager.monitor.addEventListener(
          eventName,
          (event, manager2) => {
            const announcement = getAnnouncement == null ? void 0 : getAnnouncement(event, manager2);
            if (announcement && liveRegionElement) {
              liveRegionElement.innerText = announcement;
            }
          }
        );
      }
    );
    const initialize = () => {
      hiddenTextElement = createHiddenText(
        descriptionId,
        screenReaderInstructions.draggable
      );
      liveRegionElement = createLiveRegion(announcementId);
      document.body.append(hiddenTextElement, liveRegionElement);
    };
    const cleanupEffects = effects(() => {
      for (const draggable of manager.registry.draggables.value) {
        const { element, handle } = draggable;
        const activator = handle != null ? handle : element;
        const window2 = getWindow(activator);
        if (activator) {
          if (!hiddenTextElement || !liveRegionElement) {
            initialize();
          }
          if ((!isFocusable(activator) || isSafari()) && !activator.hasAttribute("tabindex")) {
            activator.setAttribute("tabindex", "0");
          }
          if (!activator.hasAttribute("role") && !(activator instanceof window2.HTMLButtonElement)) {
            activator.setAttribute("role", defaultAttributes.role);
          }
          if (!activator.hasAttribute("role-description")) {
            activator.setAttribute(
              "aria-roledescription",
              defaultAttributes.roleDescription
            );
          }
          if (!activator.hasAttribute("aria-describedby")) {
            activator.setAttribute("aria-describedby", descriptionId);
          }
          for (const key of ["aria-pressed", "aria-grabbed"]) {
            activator.setAttribute(key, String(draggable.isDragSource));
          }
          activator.setAttribute("aria-disabled", String(draggable.disabled));
        }
      }
      this.destroy = () => {
        hiddenTextElement == null ? void 0 : hiddenTextElement.remove();
        liveRegionElement == null ? void 0 : liveRegionElement.remove();
        eventListeners.forEach((unsubscribe) => unsubscribe());
        cleanupEffects();
      };
    });
  }
};
var Cursor = class extends Plugin {
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.destroy = E(() => {
      var _a3;
      const { dragOperation } = this.manager;
      const { cursor = "grabbing" } = (_a3 = this.options) != null ? _a3 : {};
      if (dragOperation.status.initialized) {
        const style = document.createElement("style");
        style.innerText = `* { cursor: ${cursor} !important; }`;
        document.head.appendChild(style);
        return () => {
          style.remove();
        };
      }
    });
  }
};
var ATTR_PREFIX = "data-dnd-";
var CSS_PREFIX = "--dnd-";
var ATTRIBUTE = `${ATTR_PREFIX}dragging`;
var cssRules = `[${ATTRIBUTE}] {position: fixed !important;pointer-events: none !important;touch-action: none !important;z-index: calc(infinity);will-change: translate;top: var(${CSS_PREFIX}top, 0px) !important;left: var(${CSS_PREFIX}left, 0px) !important;right: unset !important;bottom: unset !important;width: var(${CSS_PREFIX}width, auto) !important;height: var(${CSS_PREFIX}height, auto) !important;box-sizing:border-box;}[${ATTRIBUTE}] *{pointer-events: none !important;}[${ATTRIBUTE}][style*="${CSS_PREFIX}translate"] {translate: var(${CSS_PREFIX}translate) !important;}[style*="${CSS_PREFIX}transition"] {transition: var(${CSS_PREFIX}transition) !important;}*:where([${ATTRIBUTE}][popover]){overflow:visible;background:var(${CSS_PREFIX}background);border:var(${CSS_PREFIX}border);margin:unset;padding:unset;color:inherit;}[${ATTRIBUTE}]::backdrop {display: none}html:has([${ATTRIBUTE}]) * {user-select:none;-webkit-user-select:none;}`;
var PLACEHOLDER_ATTRIBUTE = `${ATTR_PREFIX}placeholder`;
var IGNORED_ATTRIBUTES = [
  ATTRIBUTE,
  PLACEHOLDER_ATTRIBUTE,
  "popover",
  "aria-pressed",
  "aria-grabbing"
];
var IGNORED_STYLES = ["view-transition-name"];
var _Feedback = class _Feedback2 extends Plugin {
  constructor(manager, options2) {
    super(manager);
    const styleTags = /* @__PURE__ */ new Map();
    let initialSize;
    let initialCoordinates;
    let initialFrameTransform;
    let initialTranslate = { x: 0, y: 0 };
    let currentTranslate;
    let transformOrigin;
    let moved = false;
    const styleInjectionCleanup = E(() => {
      var _a3, _b2;
      const { status, source, target } = manager.dragOperation;
      if (status.initialized) {
        const sourceDocument = getDocument((_a3 = source == null ? void 0 : source.element) != null ? _a3 : null);
        const targetDocument = getDocument((_b2 = target == null ? void 0 : target.element) != null ? _b2 : null);
        const documents = /* @__PURE__ */ new Set([sourceDocument, targetDocument]);
        for (const doc of documents) {
          if (!styleTags.has(doc)) {
            const style = document.createElement("style");
            style.innerText = cssRules;
            doc.head.prepend(style);
            styleTags.set(doc, style);
          }
        }
        return styleInjectionCleanup;
      }
    });
    const cleanupEffect = E(() => {
      var _a3;
      const { dragOperation } = manager;
      const { position, source, status } = dragOperation;
      if (status.idle) {
        currentTranslate = void 0;
        initialCoordinates = void 0;
        initialSize = void 0;
        initialFrameTransform = void 0;
        initialTranslate = { x: 0, y: 0 };
        transformOrigin = void 0;
        return;
      }
      if (!source) return;
      const { element, feedback } = source;
      if (!element || feedback === "none") {
        return;
      }
      let cleanup;
      const frameTransform = getFrameTransform(element);
      const shape = new DOMRectangle(element, {
        frameTransform: null,
        ignoreTransforms: true
      });
      const { width, height, top, left } = shape;
      const styles2 = new Styles(element);
      const { background, border, transition, translate } = getComputedStyles(element);
      const clone = feedback === "clone";
      const placeholder = feedback !== "move" ? createPlaceholder(source) : null;
      const isKeyboardOperation = n(
        () => isKeyboardEvent(manager.dragOperation.activatorEvent)
      );
      if (translate !== "none") {
        const parsedTranslate = parseTranslate(translate);
        if (parsedTranslate) {
          initialTranslate = parsedTranslate;
        }
      }
      const relativeTop = top * frameTransform.scaleY + frameTransform.y;
      const relativeLeft = left * frameTransform.scaleX + frameTransform.x;
      if (!initialCoordinates) {
        initialCoordinates = { x: relativeLeft, y: relativeTop };
      }
      if (!initialSize) {
        initialSize = { width, height };
      }
      if (!initialFrameTransform) {
        initialFrameTransform = frameTransform;
      }
      if (!transformOrigin) {
        const current = n(() => position.current);
        transformOrigin = {
          x: (current.x - left * frameTransform.scaleX - frameTransform.x) / (width * frameTransform.scaleX),
          y: (current.y - top * frameTransform.scaleY - frameTransform.y) / (height * frameTransform.scaleY)
        };
      }
      const coordinatesDelta = {
        x: initialCoordinates.x - relativeLeft,
        y: initialCoordinates.y - relativeTop
      };
      const sizeDelta = {
        width: (initialSize.width * initialFrameTransform.scaleX - width * frameTransform.scaleX) * transformOrigin.x,
        height: (initialSize.height * initialFrameTransform.scaleY - height * frameTransform.scaleY) * transformOrigin.y
      };
      const delta = {
        x: coordinatesDelta.x / frameTransform.scaleX + sizeDelta.width,
        y: coordinatesDelta.y / frameTransform.scaleY + sizeDelta.height
      };
      const projected = {
        left: left + delta.x,
        top: top + delta.y
      };
      element.setAttribute(ATTRIBUTE, "true");
      const transform = n(() => dragOperation.transform);
      const translateString = `${transform.x * frameTransform.scaleX + initialTranslate.x}px ${transform.y * frameTransform.scaleY + initialTranslate.y}px 0`;
      styles2.set(
        {
          width,
          height,
          top: projected.top,
          left: projected.left,
          background,
          border,
          translate: translateString
        },
        CSS_PREFIX
      );
      if (placeholder) {
        element.insertAdjacentElement("afterend", placeholder);
        if (options2 == null ? void 0 : options2.rootElement) {
          const root = typeof options2.rootElement === "function" ? options2.rootElement(source) : options2.rootElement;
          root.appendChild(element);
        }
      }
      if (supportsPopover(element)) {
        if (!element.hasAttribute("popover")) {
          element.setAttribute("popover", "");
        }
        showPopover(element);
      }
      const actual = new DOMRectangle(element, {
        ignoreTransforms: true
      });
      const offset = {
        top: projected.top - actual.top,
        left: projected.left - actual.left
      };
      if (Math.abs(offset.left) > 0.01 || Math.abs(offset.top) > 0.01) {
        styles2.set(
          {
            top: actual.top + offset.top,
            left: actual.left + offset.left
          },
          CSS_PREFIX
        );
      } else {
        offset.left = 0;
        offset.top = 0;
      }
      const resizeObserver = new ResizeObserver(() => {
        if (!placeholder) return;
        const placeholderShape = new DOMRectangle(placeholder, {
          ignoreTransforms: true
        });
        const origin = transformOrigin != null ? transformOrigin : { x: 1, y: 1 };
        const dX = (width - placeholderShape.width) * origin.x + delta.x;
        const dY = (height - placeholderShape.height) * origin.y + delta.y;
        styles2.set(
          {
            width: placeholderShape.width,
            height: placeholderShape.height,
            top: top + dY,
            left: left + dX
          },
          CSS_PREFIX
        );
        const window2 = getWindow(element);
        if (element instanceof window2.HTMLTableRowElement && placeholder instanceof window2.HTMLTableRowElement) {
          const cells = Array.from(element.cells);
          const placeholderCells = Array.from(placeholder.cells);
          for (const [index, cell] of cells.entries()) {
            const placeholderCell = placeholderCells[index];
            cell.style.width = `${placeholderCell.offsetWidth}px`;
          }
        }
        dragOperation.shape = new DOMRectangle(element);
      });
      dragOperation.shape = new DOMRectangle(element);
      source.status = "dragging";
      let elementMutationObserver;
      let documentMutationObserver;
      if (placeholder) {
        resizeObserver.observe(placeholder);
        elementMutationObserver = new MutationObserver(() => {
          for (const attribute of Array.from(element.attributes)) {
            if (attribute.name.startsWith("aria-") || IGNORED_ATTRIBUTES.includes(attribute.name)) {
              continue;
            }
            if (attribute.name === "style") {
              if (supportsStyle(element) && supportsStyle(placeholder)) {
                placeholder.setAttribute("style", clone ? "" : "opacity: 0;");
                placeholder.style.setProperty("transition", "none");
                for (const key of Object.values(element.style)) {
                  if (key.startsWith(CSS_PREFIX) || IGNORED_STYLES.includes(key)) {
                    continue;
                  }
                  placeholder.style.setProperty(
                    key,
                    element.style.getPropertyValue(key)
                  );
                }
              }
              continue;
            }
            placeholder.setAttribute(attribute.name, attribute.value);
          }
          if (clone) {
            placeholder.innerHTML = element.innerHTML;
          }
        });
        elementMutationObserver.observe(element, {
          attributes: true,
          subtree: true
        });
        documentMutationObserver = new MutationObserver((entries) => {
          for (const entry of entries) {
            const { addedNodes } = entry;
            if (addedNodes.length > 0 && Array.from(addedNodes).some((node) => node.contains(element))) {
              element.insertAdjacentElement("afterend", placeholder);
              showPopover(element);
              return;
            }
          }
        });
        documentMutationObserver.observe(element.ownerDocument.body, {
          childList: true,
          subtree: true
        });
      }
      const cleanupEffect2 = E(function updateTransform() {
        const { transform: transform2, status: status2 } = dragOperation;
        if (!transform2.x && !transform2.y && !moved) {
          return;
        }
        if (!moved) {
          moved = true;
        }
        if (status2.dragging) {
          const translateTransition = isKeyboardOperation ? "250ms cubic-bezier(0.25, 1, 0.5, 1)" : "0ms linear";
          const x = transform2.x / frameTransform.scaleX + initialTranslate.x;
          const y2 = transform2.y / frameTransform.scaleY + initialTranslate.y;
          styles2.set(
            {
              transition: `${transition}, translate ${translateTransition}`,
              translate: `${x}px ${y2}px 0`
            },
            CSS_PREFIX
          );
          dragOperation.shape = new DOMRectangle(element);
          currentTranslate = {
            x,
            y: y2
          };
        }
      });
      const id = (_a3 = manager.dragOperation.source) == null ? void 0 : _a3.id;
      const restoreFocus = () => {
        var _a4;
        if (!isKeyboardOperation || id == null) {
          return;
        }
        const draggable = manager.registry.draggables.get(id);
        const element2 = (_a4 = draggable == null ? void 0 : draggable.handle) != null ? _a4 : draggable == null ? void 0 : draggable.element;
        if (element2 instanceof HTMLElement) {
          element2.focus();
        }
      };
      let dropEffectCleanup;
      cleanup = () => {
        elementMutationObserver == null ? void 0 : elementMutationObserver.disconnect();
        documentMutationObserver == null ? void 0 : documentMutationObserver.disconnect();
        resizeObserver.disconnect();
        styles2.reset();
        if (placeholder && (moved || placeholder.parentElement !== element.parentElement) && element.isConnected) {
          placeholder.replaceWith(element);
        }
        placeholder == null ? void 0 : placeholder.remove();
        element.removeAttribute(ATTRIBUTE);
        if (supportsPopover(element)) {
          element.removeAttribute("popover");
        }
        cleanupEffect2();
        dropEffectCleanup == null ? void 0 : dropEffectCleanup();
        source.status = "idle";
        moved = false;
      };
      dropEffectCleanup = E(function dropAnimation() {
        if (dragOperation.status.dropped) {
          const onComplete = cleanup;
          cleanup = void 0;
          source.status = "dropping";
          const transform2 = currentTranslate;
          if (!transform2) {
            onComplete == null ? void 0 : onComplete();
            return;
          }
          manager.renderer.rendering.then(() => {
            showPopover(element);
            const target = placeholder != null ? placeholder : element;
            const animations = element.getAnimations();
            if (animations.length) {
              animations.forEach((animation) => {
                const { effect: effect9 } = animation;
                if (effect9 instanceof KeyframeEffect) {
                  if (effect9.getKeyframes().some((keyframe) => keyframe.translate)) {
                    animation.finish();
                  }
                }
              });
            }
            const sameFrame = getFrameElement(element) === getFrameElement(target);
            const options22 = {
              frameTransform: sameFrame ? null : void 0
            };
            const current = new DOMRectangle(element, options22);
            const final = new DOMRectangle(target, options22);
            const delta2 = {
              x: current.center.x - final.center.x,
              y: current.center.y - final.center.y
            };
            const finalTransform = {
              x: transform2.x - delta2.x,
              y: transform2.y - delta2.y
            };
            const heightKeyframes = Math.round(current.height) !== Math.round(final.height) ? {
              minHeight: [`${current.height}px`, `${final.height}px`],
              maxHeight: [`${current.height}px`, `${final.height}px`]
            } : {};
            const widthKeyframes = Math.round(current.width) !== Math.round(final.width) ? {
              minWidth: [`${current.width}px`, `${final.width}px`],
              maxWidth: [`${current.width}px`, `${final.width}px`]
            } : {};
            animateTransform({
              element,
              keyframes: __spreadProps3(__spreadValues4(__spreadValues4({}, heightKeyframes), widthKeyframes), {
                translate: [
                  `${transform2.x}px ${transform2.y}px 0`,
                  `${finalTransform.x}px ${finalTransform.y}px 0`
                ]
              }),
              options: {
                duration: moved ? 250 : 0,
                easing: "ease"
              },
              onReady() {
                styles2.remove(["translate"], CSS_PREFIX);
              },
              onFinish() {
                requestAnimationFrame(restoreFocus);
                onComplete == null ? void 0 : onComplete();
              }
            });
          });
        }
      });
      return () => cleanup == null ? void 0 : cleanup();
    });
    this.destroy = () => {
      styleInjectionCleanup();
      cleanupEffect();
      styleTags.forEach((style) => style.remove());
    };
  }
};
_Feedback.configure = configurator(_Feedback);
var Feedback = _Feedback;
function createPlaceholder(source) {
  return n(() => {
    var _a3;
    const { element, manager } = source;
    if (!element || !manager) return;
    const { droppables } = manager.registry;
    const containedDroppables = /* @__PURE__ */ new Map();
    for (const droppable of droppables) {
      if (!droppable.element) continue;
      if (element === droppable.element || element.contains(droppable.element)) {
        const identifierAttribute = `${ATTR_PREFIX}${generateUniqueId("dom-id")}`;
        droppable.element.setAttribute(identifierAttribute, "");
        containedDroppables.set(droppable, identifierAttribute);
      }
    }
    const cleanup = [];
    const placeholder = cloneElement(element);
    const { remove: remove2 } = placeholder;
    for (const [droppable, identifierAttribute] of containedDroppables) {
      if (!droppable.element) continue;
      const selector = `[${identifierAttribute}]`;
      const clonedElement = placeholder.matches(selector) ? placeholder : placeholder.querySelector(selector);
      (_a3 = droppable.element) == null ? void 0 : _a3.removeAttribute(identifierAttribute);
      if (!clonedElement) continue;
      let current = droppable.element;
      droppable.proxy = clonedElement;
      clonedElement.removeAttribute(identifierAttribute);
      ProxiedElements.set(current, clonedElement);
      cleanup.push(() => {
        ProxiedElements.delete(current);
        droppable.proxy = void 0;
      });
    }
    placeholder.setAttribute("inert", "true");
    placeholder.setAttribute("tab-index", "-1");
    placeholder.setAttribute("aria-hidden", "true");
    placeholder.setAttribute(PLACEHOLDER_ATTRIBUTE, "");
    placeholder.remove = () => {
      cleanup.forEach((fn) => fn());
      remove2.call(placeholder);
    };
    return placeholder;
  });
}
var LOCKED = true;
var UNLOCKED = false;
var _dec;
var _a;
var _dec2;
var _b;
var _init5;
var __b;
var __a;
_b = (_dec2 = [reactive], ScrollDirection.Forward), _a = (_dec = [reactive], ScrollDirection.Reverse);
var ScrollLock = class {
  constructor() {
    __privateAdd5(this, __b, __runInitializers3(_init5, 8, this, LOCKED)), __runInitializers3(_init5, 11, this);
    __privateAdd5(this, __a, __runInitializers3(_init5, 12, this, LOCKED)), __runInitializers3(_init5, 15, this);
  }
  isLocked(direction) {
    if (direction === ScrollDirection.Idle) {
      return false;
    }
    if (direction == null) {
      return this[ScrollDirection.Forward] === LOCKED && this[ScrollDirection.Reverse] === LOCKED;
    }
    return this[direction] === LOCKED;
  }
  unlock(direction) {
    if (direction === ScrollDirection.Idle) {
      return;
    }
    this[direction] = UNLOCKED;
  }
};
_init5 = __decoratorStart3(null);
__b = /* @__PURE__ */ new WeakMap();
__a = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init5, 4, _b, _dec2, ScrollLock, __b);
__decorateElement3(_init5, 4, _a, _dec, ScrollLock, __a);
__decoratorMetadata3(_init5, ScrollLock);
var DIRECTIONS = [ScrollDirection.Forward, ScrollDirection.Reverse];
var ScrollIntent = class {
  constructor() {
    this.x = new ScrollLock();
    this.y = new ScrollLock();
  }
  isLocked() {
    return this.x.isLocked() && this.y.isLocked();
  }
};
var ScrollIntentTracker = class extends Plugin {
  constructor(manager) {
    super(manager);
    const scrollIntent = d(new ScrollIntent());
    let previousDelta = null;
    this.signal = scrollIntent;
    E(() => {
      const { status } = manager.dragOperation;
      if (!status.initialized) {
        previousDelta = null;
        scrollIntent.value = new ScrollIntent();
        return;
      }
      const { delta } = manager.dragOperation.position;
      if (previousDelta) {
        const directions = {
          x: getDirection(delta.x, previousDelta.x),
          y: getDirection(delta.y, previousDelta.y)
        };
        const intent = scrollIntent.peek();
        r(() => {
          for (const axis of Axes) {
            for (const direction of DIRECTIONS) {
              if (directions[axis] === direction) {
                intent[axis].unlock(direction);
              }
            }
          }
          scrollIntent.value = intent;
        });
      }
      previousDelta = delta;
    });
  }
  get current() {
    return this.signal.peek();
  }
};
function getDirection(a2, b2) {
  return Math.sign(a2 - b2);
}
var _autoScrolling_dec;
var _a2;
var _init23;
var _autoScrolling;
var _meta;
var _scroll;
var Scroller = class extends (_a2 = CorePlugin, _autoScrolling_dec = [reactive], _a2) {
  constructor(manager) {
    super(manager);
    __privateAdd5(this, _autoScrolling, __runInitializers3(_init23, 8, this, false)), __runInitializers3(_init23, 11, this);
    __privateAdd5(this, _meta);
    __privateAdd5(this, _scroll, () => {
      if (!__privateGet5(this, _meta)) {
        return;
      }
      const { element, by } = __privateGet5(this, _meta);
      if (by.y) element.scrollTop += by.y;
      if (by.x) element.scrollLeft += by.x;
    });
    this.scroll = (options2) => {
      var _a3;
      if (this.disabled) {
        return false;
      }
      const elements = this.getScrollableElements();
      if (!elements) {
        __privateSet5(this, _meta, void 0);
        return false;
      }
      const { position } = this.manager.dragOperation;
      const currentPosition = position == null ? void 0 : position.current;
      if (currentPosition) {
        const { by } = options2 != null ? options2 : {};
        const intent = by ? {
          x: getScrollIntent(by.x),
          y: getScrollIntent(by.y)
        } : void 0;
        const scrollIntent = intent ? void 0 : this.scrollIntentTracker.current;
        if (scrollIntent == null ? void 0 : scrollIntent.isLocked()) {
          return false;
        }
        for (const scrollableElement of elements) {
          const elementCanScroll = canScroll(scrollableElement, by);
          if (elementCanScroll.x || elementCanScroll.y) {
            const { speed, direction } = detectScrollIntent(
              scrollableElement,
              currentPosition,
              intent
            );
            if (scrollIntent) {
              for (const axis of Axes) {
                if (scrollIntent[axis].isLocked(direction[axis])) {
                  speed[axis] = 0;
                  direction[axis] = 0;
                }
              }
            }
            if (direction.x || direction.y) {
              const { x, y: y2 } = by != null ? by : direction;
              const scrollLeftBy = x * speed.x;
              const scrollTopBy = y2 * speed.y;
              if (scrollLeftBy || scrollTopBy) {
                const previousScrollBy = (_a3 = __privateGet5(this, _meta)) == null ? void 0 : _a3.by;
                if (this.autoScrolling && previousScrollBy) {
                  const scrollIntentMismatch = previousScrollBy.x && !scrollLeftBy || previousScrollBy.y && !scrollTopBy;
                  if (scrollIntentMismatch) continue;
                }
                __privateSet5(this, _meta, {
                  element: scrollableElement,
                  by: {
                    x: scrollLeftBy,
                    y: scrollTopBy
                  }
                });
                scheduler.schedule(__privateGet5(this, _scroll));
                return true;
              }
            }
          }
        }
      }
      __privateSet5(this, _meta, void 0);
      return false;
    };
    let previousElementFromPoint = null;
    let previousScrollableElements = null;
    const elementFromPoint = computed(() => {
      const { position } = manager.dragOperation;
      if (!position) {
        return null;
      }
      const element = getElementFromPoint(document, position.current);
      if (element) {
        previousElementFromPoint = element;
      }
      return element != null ? element : previousElementFromPoint;
    });
    const scrollableElements = computed(() => {
      const element = elementFromPoint.value;
      const { documentElement } = getDocument(element);
      if (!element || element === documentElement) {
        const { target } = manager.dragOperation;
        const targetElement = target == null ? void 0 : target.element;
        if (targetElement) {
          const elements = getScrollableAncestors(targetElement, {
            excludeElement: false
          });
          previousScrollableElements = elements;
          return elements;
        }
      }
      if (element) {
        const elements = getScrollableAncestors(element, {
          excludeElement: false
        });
        if (this.autoScrolling && previousScrollableElements && elements.size < (previousScrollableElements == null ? void 0 : previousScrollableElements.size)) {
          return previousScrollableElements;
        }
        previousScrollableElements = elements;
        return elements;
      }
      previousScrollableElements = null;
      return null;
    }, deepEqual);
    this.getScrollableElements = () => {
      return scrollableElements.value;
    };
    this.scrollIntentTracker = new ScrollIntentTracker(manager);
    this.destroy = manager.monitor.addEventListener("dragmove", (event) => {
      if (this.disabled || event.defaultPrevented || !isKeyboardEvent(manager.dragOperation.activatorEvent) || !event.by) {
        return;
      }
      if (this.scroll({ by: event.by })) {
        event.preventDefault();
      }
    });
  }
};
_init23 = __decoratorStart3(_a2);
_autoScrolling = /* @__PURE__ */ new WeakMap();
_meta = /* @__PURE__ */ new WeakMap();
_scroll = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init23, 4, "autoScrolling", _autoScrolling_dec, Scroller, _autoScrolling);
__decoratorMetadata3(_init23, Scroller);
function getScrollIntent(value) {
  if (value > 0) {
    return ScrollDirection.Forward;
  }
  if (value < 0) {
    return ScrollDirection.Reverse;
  }
  return ScrollDirection.Idle;
}
var AUTOSCROLL_INTERVAL = 10;
var AutoScroller = class extends Plugin {
  constructor(manager, _options) {
    super(manager);
    const scroller = manager.registry.plugins.get(Scroller);
    if (!scroller) {
      throw new Error("AutoScroller plugin depends on Scroller plugin");
    }
    this.destroy = E(() => {
      if (this.disabled) {
        return;
      }
      const { position: _2, status } = manager.dragOperation;
      if (status.dragging) {
        const canScroll2 = scroller.scroll();
        if (canScroll2) {
          scroller.autoScrolling = true;
          const interval = setInterval(scroller.scroll, AUTOSCROLL_INTERVAL);
          return () => {
            clearInterval(interval);
          };
        } else {
          scroller.autoScrolling = false;
        }
      }
    });
  }
};
var listenerOptions = {
  capture: true,
  passive: true
};
var _timeout;
var ScrollListener = class extends CorePlugin {
  constructor(manager) {
    super(manager);
    __privateAdd5(this, _timeout);
    this.handleScroll = () => {
      if (__privateGet5(this, _timeout) == null) {
        __privateSet5(this, _timeout, setTimeout(() => {
          this.manager.collisionObserver.forceUpdate(false);
          __privateSet5(this, _timeout, void 0);
        }, 50));
      }
    };
    const { dragOperation } = this.manager;
    this.destroy = E(() => {
      var _a3, _b2, _c32;
      const enabled = dragOperation.status.dragging;
      if (enabled) {
        const root = (_c32 = (_b2 = (_a3 = dragOperation.source) == null ? void 0 : _a3.element) == null ? void 0 : _b2.ownerDocument) != null ? _c32 : document;
        root.addEventListener("scroll", this.handleScroll, listenerOptions);
        return () => {
          root.removeEventListener(
            "scroll",
            this.handleScroll,
            listenerOptions
          );
        };
      }
    });
  }
};
_timeout = /* @__PURE__ */ new WeakMap();
var PreventSelection = class extends Plugin {
  constructor(manager) {
    super(manager);
    this.manager = manager;
    this.destroy = E(() => {
      const { dragOperation } = this.manager;
      if (dragOperation.status.initialized) {
        const style = document.createElement("style");
        style.innerText = `* { user-select: none !important;, -webkit-user-select: none !important; }`;
        document.head.appendChild(style);
        document.addEventListener("selectionchange", removeSelection, {
          capture: true
        });
        return () => {
          document.removeEventListener("selectionchange", removeSelection, {
            capture: true
          });
          style.remove();
        };
      }
    });
  }
};
function removeSelection() {
  var _a3;
  (_a3 = document.getSelection()) == null ? void 0 : _a3.removeAllRanges();
}
var DEFAULT_KEYBOARD_CODES = {
  start: ["Space", "Enter"],
  cancel: ["Escape"],
  end: ["Space", "Enter", "Tab"],
  up: ["ArrowUp"],
  down: ["ArrowDown"],
  left: ["ArrowLeft"],
  right: ["ArrowRight"]
};
var DEFAULT_OFFSET = 10;
var _cleanupFunctions;
var KeyboardSensor = class extends Sensor {
  constructor(manager, options2) {
    super(manager);
    this.manager = manager;
    this.options = options2;
    __privateAdd5(this, _cleanupFunctions, []);
    this.listeners = new Listeners();
    this.handleSourceKeyDown = (event, source, options3) => {
      if (this.disabled || event.defaultPrevented) {
        return;
      }
      if (!isElement(event.target)) {
        return;
      }
      if (source.disabled) {
        return;
      }
      if (!source.handle && source.element && event.target === source.element || source.handle && event.target === source.handle) {
        const { keyboardCodes = DEFAULT_KEYBOARD_CODES } = options3 != null ? options3 : {};
        if (!keyboardCodes.start.includes(event.code)) {
          return;
        }
        if (!this.manager.dragOperation.status.idle) {
          return;
        }
        this.handleStart(event, source, options3);
      }
    };
  }
  bind(source, options2 = this.options) {
    const unbind = E(() => {
      var _a3;
      const target = (_a3 = source.handle) != null ? _a3 : source.element;
      const listener = (event) => {
        if (isKeyboardEvent(event)) {
          this.handleSourceKeyDown(event, source, options2);
        }
      };
      if (target) {
        target.addEventListener("keydown", listener);
        return () => {
          target.removeEventListener("keydown", listener);
        };
      }
    });
    return unbind;
  }
  handleStart(event, source, options2) {
    const { element } = source;
    if (!element) {
      throw new Error("Source draggable does not have an associated element");
    }
    event.preventDefault();
    event.stopImmediatePropagation();
    scrollIntoViewIfNeeded(element);
    const { center } = new DOMRectangle(element);
    r(() => {
      this.manager.actions.setDragSource(source.id);
      this.manager.actions.start({
        event,
        coordinates: {
          x: center.x,
          y: center.y
        }
      });
    });
    this.sideEffects();
    const sourceDocument = getDocument(element);
    const sourceWindow = getWindow(sourceDocument);
    const listeners = [
      this.listeners.bind(sourceDocument, [
        {
          type: "keydown",
          listener: (event2) => this.handleKeyDown(event2, source, options2),
          options: { capture: true }
        }
      ]),
      this.listeners.bind(sourceWindow, [
        { type: "resize", listener: () => this.handleEnd(true) }
      ])
    ];
    __privateGet5(this, _cleanupFunctions).push(...listeners);
  }
  handleKeyDown(event, _source, options2) {
    const { keyboardCodes = DEFAULT_KEYBOARD_CODES } = options2 != null ? options2 : {};
    if (isKeycode(event, [...keyboardCodes.end, ...keyboardCodes.cancel])) {
      event.preventDefault();
      const canceled = isKeycode(event, keyboardCodes.cancel);
      this.handleEnd(canceled);
      return;
    }
    if (isKeycode(event, keyboardCodes.up)) {
      this.handleMove("up", event);
    } else if (isKeycode(event, keyboardCodes.down)) {
      this.handleMove("down", event);
    }
    if (isKeycode(event, keyboardCodes.left)) {
      this.handleMove("left", event);
    } else if (isKeycode(event, keyboardCodes.right)) {
      this.handleMove("right", event);
    }
  }
  handleEnd(canceled) {
    this.manager.actions.stop({
      canceled
    });
    this.cleanup();
  }
  handleMove(direction, event) {
    const { shape } = this.manager.dragOperation;
    const factor = event.shiftKey ? 5 : 1;
    let offset = {
      x: 0,
      y: 0
    };
    if (!shape) {
      return;
    }
    switch (direction) {
      case "up":
        offset = { x: 0, y: -DEFAULT_OFFSET * factor };
        break;
      case "down":
        offset = { x: 0, y: DEFAULT_OFFSET * factor };
        break;
      case "left":
        offset = { x: -DEFAULT_OFFSET * factor, y: 0 };
        break;
      case "right":
        offset = { x: DEFAULT_OFFSET * factor, y: 0 };
        break;
    }
    if ((offset == null ? void 0 : offset.x) || (offset == null ? void 0 : offset.y)) {
      event.preventDefault();
      this.manager.actions.move({
        by: offset
      });
    }
  }
  sideEffects() {
    const autoScroller = this.manager.registry.plugins.get(AutoScroller);
    if ((autoScroller == null ? void 0 : autoScroller.disabled) === false) {
      autoScroller.disable();
      __privateGet5(this, _cleanupFunctions).push(() => {
        autoScroller.enable();
      });
    }
  }
  cleanup() {
    __privateGet5(this, _cleanupFunctions).forEach((cleanup) => cleanup());
  }
  destroy() {
    this.cleanup();
    this.listeners.clear();
  }
};
_cleanupFunctions = /* @__PURE__ */ new WeakMap();
function isKeycode(event, codes) {
  return codes.includes(event.code);
}
var _clearTimeout;
var _PointerSensor = class _PointerSensor2 extends Sensor {
  constructor(manager, options2) {
    super(manager);
    this.manager = manager;
    this.options = options2;
    this.listeners = new Listeners();
    this.cleanup = /* @__PURE__ */ new Set();
    __privateAdd5(this, _clearTimeout);
    this.handleCancel = this.handleCancel.bind(this);
    this.handlePointerUp = this.handlePointerUp.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  bind(source, options2 = this.options) {
    const unbind = E(() => {
      var _a3;
      const target = (_a3 = source.handle) != null ? _a3 : source.element;
      const listener = (event) => {
        if (isPointerEvent(event)) {
          this.handlePointerDown(event, source, options2);
        }
      };
      if (target) {
        patchWindow(target.ownerDocument.defaultView);
        target.addEventListener("pointerdown", listener);
        return () => {
          target.removeEventListener("pointerdown", listener);
        };
      }
    });
    return unbind;
  }
  handlePointerDown(event, source, options2 = {}) {
    if (this.disabled || !event.isPrimary || event.button !== 0 || !isElement(event.target) || source.disabled || isCapturedBySensor(event)) {
      return;
    }
    const { target } = event;
    const isNativeDraggable = isHTMLElement(target) && target.draggable && target.getAttribute("draggable") === "true";
    const offset = getFrameTransform(source.element);
    this.initialCoordinates = {
      x: event.clientX * offset.scaleX + offset.x,
      y: event.clientY * offset.scaleY + offset.y
    };
    const { activationConstraints } = options2;
    const constraints = typeof activationConstraints === "function" ? activationConstraints(event, source) : activationConstraints;
    event.sensor = this;
    if (!(constraints == null ? void 0 : constraints.delay) && !(constraints == null ? void 0 : constraints.distance)) {
      this.handleStart(source, event);
    } else {
      const { delay } = constraints;
      if (delay) {
        const timeout3 = setTimeout(
          () => this.handleStart(source, event),
          delay.value
        );
        __privateSet5(this, _clearTimeout, () => {
          clearTimeout(timeout3);
          __privateSet5(this, _clearTimeout, void 0);
        });
      }
    }
    const ownerDocument = getDocument(event.target);
    const unbindListeners = this.listeners.bind(ownerDocument, [
      {
        type: "pointermove",
        listener: (event2) => this.handlePointerMove(event2, source, options2)
      },
      {
        type: "pointerup",
        listener: this.handlePointerUp,
        options: {
          capture: true
        }
      },
      {
        // Cancel activation if there is a competing Drag and Drop interaction
        type: "dragstart",
        listener: isNativeDraggable ? this.handleCancel : preventDefault
      }
    ]);
    const cleanup = () => {
      var _a3;
      setTimeout(unbindListeners);
      (_a3 = __privateGet5(this, _clearTimeout)) == null ? void 0 : _a3.call(this);
      this.initialCoordinates = void 0;
    };
    this.cleanup.add(cleanup);
  }
  handlePointerMove(event, source, options2) {
    const coordinates = {
      x: event.clientX,
      y: event.clientY
    };
    const offset = getFrameTransform(source.element);
    coordinates.x = coordinates.x * offset.scaleX + offset.x;
    coordinates.y = coordinates.y * offset.scaleY + offset.y;
    if (this.manager.dragOperation.status.dragging) {
      event.preventDefault();
      event.stopPropagation();
      this.manager.actions.move({ to: coordinates });
      return;
    }
    if (!this.initialCoordinates) {
      return;
    }
    const delta = {
      x: coordinates.x - this.initialCoordinates.x,
      y: coordinates.y - this.initialCoordinates.y
    };
    const { activationConstraints } = options2;
    const constraints = typeof activationConstraints === "function" ? activationConstraints(event, source) : activationConstraints;
    const { distance, delay } = constraints != null ? constraints : {};
    if (distance) {
      if (distance.tolerance != null && exceedsDistance(delta, distance.tolerance)) {
        return this.handleCancel();
      }
      if (exceedsDistance(delta, distance.value)) {
        return this.handleStart(source, event);
      }
    }
    if (delay) {
      if (exceedsDistance(delta, delay.tolerance)) {
        return this.handleCancel();
      }
    }
  }
  handlePointerUp(event) {
    const { status } = this.manager.dragOperation;
    if (!status.idle) {
      event.preventDefault();
      event.stopPropagation();
      const canceled = !status.initialized;
      this.manager.actions.stop({ canceled });
    }
    this.cleanup.forEach((cleanup) => cleanup());
    this.cleanup.clear();
  }
  handleKeyDown(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      this.handleCancel();
    }
  }
  handleStart(source, event) {
    var _a3;
    const { manager, initialCoordinates } = this;
    (_a3 = __privateGet5(this, _clearTimeout)) == null ? void 0 : _a3.call(this);
    if (!initialCoordinates || manager.dragOperation.status.initialized) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    event.preventDefault();
    r(() => {
      manager.actions.setDragSource(source.id);
      manager.actions.start({ coordinates: initialCoordinates, event });
    });
    const ownerDocument = getDocument(event.target);
    const unbind = this.listeners.bind(ownerDocument, [
      {
        // Prevent scrolling on touch devices
        type: "touchmove",
        listener: preventDefault,
        options: {
          passive: false
        }
      },
      {
        // Prevent click events
        type: "click",
        listener: preventDefault
      },
      {
        type: "keydown",
        listener: this.handleKeyDown
      }
    ]);
    ownerDocument.body.setPointerCapture(event.pointerId);
    this.cleanup.add(unbind);
  }
  handleCancel() {
    const { dragOperation } = this.manager;
    if (dragOperation.status.initialized) {
      this.manager.actions.stop({ canceled: true });
    }
    this.cleanup.forEach((cleanup) => cleanup());
    this.cleanup.clear();
  }
  destroy() {
    this.listeners.clear();
  }
};
_clearTimeout = /* @__PURE__ */ new WeakMap();
_PointerSensor.configure = configurator(_PointerSensor);
var PointerSensor = _PointerSensor;
function isCapturedBySensor(event) {
  return "sensor" in event;
}
function preventDefault(event) {
  event.preventDefault();
}
function noop() {
}
var windows = /* @__PURE__ */ new WeakSet();
function patchWindow(window2) {
  if (!window2 || windows.has(window2)) {
    return;
  }
  window2.addEventListener("touchmove", noop, {
    capture: false,
    passive: false
  });
  windows.add(window2);
}
var defaultPreset = {
  modifiers: [],
  plugins: [Accessibility, AutoScroller, Cursor, Feedback, PreventSelection],
  sensors: [
    PointerSensor.configure({
      activationConstraints(event, source) {
        var _a3;
        const { pointerType, target } = event;
        if (pointerType === "mouse" && isElement(target) && (source.handle === target || ((_a3 = source.handle) == null ? void 0 : _a3.contains(target)))) {
          return void 0;
        }
        return {
          delay: { value: 200, tolerance: 10 },
          distance: { value: 5 }
        };
      }
    }),
    KeyboardSensor
  ]
};
var DragDropManager2 = class extends DragDropManager {
  constructor(input = {}) {
    const {
      plugins = defaultPreset.plugins,
      sensors = defaultPreset.sensors,
      modifiers = []
    } = input;
    super(__spreadProps3(__spreadValues4({}, input), {
      plugins: [ScrollListener, Scroller, ...plugins],
      sensors,
      modifiers
    }));
  }
};
var _feedback_dec;
var _element_dec;
var _handle_dec;
var _c3;
var _init32;
var _handle;
var _element;
var _feedback;
var Draggable2 = class extends (_c3 = Draggable, _handle_dec = [reactive], _element_dec = [reactive], _feedback_dec = [reactive], _c3) {
  constructor(_a3, manager) {
    var _b2 = _a3, {
      element,
      effects: effects2 = () => [],
      handle,
      feedback = "default"
    } = _b2, input = __objRest3(_b2, [
      "element",
      "effects",
      "handle",
      "feedback"
    ]);
    super(
      __spreadValues4({
        effects: () => [
          ...effects2(),
          () => {
            var _a4, _b3;
            const { manager: manager2 } = this;
            if (!manager2) return;
            const sensors = (_b3 = (_a4 = this.sensors) == null ? void 0 : _a4.map(descriptor)) != null ? _b3 : [
              ...manager2.sensors
            ];
            const unbindFunctions = sensors.map((entry) => {
              const sensorInstance = entry instanceof Sensor ? entry : manager2.registry.register(entry.plugin);
              const options2 = entry instanceof Sensor ? void 0 : entry.options;
              const unbind = sensorInstance.bind(this, options2);
              return unbind;
            });
            return function cleanup() {
              unbindFunctions.forEach((unbind) => unbind());
            };
          }
        ]
      }, input),
      manager
    );
    __privateAdd5(this, _handle, __runInitializers3(_init32, 8, this)), __runInitializers3(_init32, 11, this);
    __privateAdd5(this, _element, __runInitializers3(_init32, 12, this)), __runInitializers3(_init32, 15, this);
    __privateAdd5(this, _feedback, __runInitializers3(_init32, 16, this)), __runInitializers3(_init32, 19, this);
    this.element = element;
    this.handle = handle;
    this.feedback = feedback;
  }
};
_init32 = __decoratorStart3(_c3);
_handle = /* @__PURE__ */ new WeakMap();
_element = /* @__PURE__ */ new WeakMap();
_feedback = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init32, 4, "handle", _handle_dec, Draggable2, _handle);
__decorateElement3(_init32, 4, "element", _element_dec, Draggable2, _element);
__decorateElement3(_init32, 4, "feedback", _feedback_dec, Draggable2, _feedback);
__decoratorMetadata3(_init32, Draggable2);
var _proxy_dec;
var _element_dec2;
var _c22;
var _init42;
var _element2;
var _d;
var element_get;
var element_set;
var _Droppable_instances;
var _proxy;
var Droppable2 = class extends (_c22 = Droppable, _element_dec2 = [reactive], _proxy_dec = [reactive], _c22) {
  constructor(_a3, manager) {
    var _b2 = _a3, { element, effects: effects2 = () => [] } = _b2, input = __objRest3(_b2, ["element", "effects"]);
    const { collisionDetector = defaultCollisionDetection } = input;
    const updateShape = (boundingClientRect) => {
      const { manager: manager2, element: element2 } = this;
      if (!element2 || boundingClientRect === null) {
        this.shape = void 0;
        return void 0;
      }
      if (!manager2) return;
      const updatedShape = new DOMRectangle(element2);
      const shape = n(() => this.shape);
      if (updatedShape && (shape == null ? void 0 : shape.equals(updatedShape))) {
        return shape;
      }
      this.shape = updatedShape;
      return updatedShape;
    };
    const observePosition = d(false);
    super(
      __spreadProps3(__spreadValues4({}, input), {
        collisionDetector,
        effects: () => [
          ...effects2(),
          () => {
            const { element: element2, manager: manager2 } = this;
            if (!manager2) return;
            const { dragOperation } = manager2;
            const { source } = dragOperation;
            observePosition.value = Boolean(
              source && dragOperation.status.initialized && element2 && !this.disabled && this.accepts(source)
            );
          },
          () => {
            const { element: element2 } = this;
            if (observePosition.value && element2) {
              const positionObserver = new PositionObserver(
                element2,
                updateShape
              );
              return () => {
                positionObserver.disconnect();
                this.shape = void 0;
              };
            }
          },
          () => {
            var _a4;
            if ((_a4 = this.manager) == null ? void 0 : _a4.dragOperation.status.initialized) {
              return () => {
                this.shape = void 0;
              };
            }
          }
        ]
      }),
      manager
    );
    __privateAdd5(this, _Droppable_instances);
    __privateAdd5(this, _element2, __runInitializers3(_init42, 8, this)), __runInitializers3(_init42, 11, this);
    __privateAdd5(this, _proxy, __runInitializers3(_init42, 12, this)), __runInitializers3(_init42, 15, this);
    this.element = element;
    this.refreshShape = () => updateShape();
  }
  set element(element) {
    __privateSet5(this, _Droppable_instances, element, element_set);
  }
  get element() {
    var _a3;
    return (_a3 = this.proxy) != null ? _a3 : __privateGet5(this, _Droppable_instances, element_get);
  }
};
_init42 = __decoratorStart3(_c22);
_element2 = /* @__PURE__ */ new WeakMap();
_Droppable_instances = /* @__PURE__ */ new WeakSet();
_proxy = /* @__PURE__ */ new WeakMap();
_d = __decorateElement3(_init42, 20, "#element", _element_dec2, _Droppable_instances, _element2), element_get = _d.get, element_set = _d.set;
__decorateElement3(_init42, 4, "proxy", _proxy_dec, Droppable2, _proxy);
__decoratorMetadata3(_init42, Droppable2);

// node_modules/@dnd-kit/react/hooks.js
var import_react2 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@dnd-kit/react/utilities.js
function isRef(value) {
  return value != null && typeof value === "object" && "current" in value;
}
function currentValue(value) {
  var _a3;
  if (value == null) {
    return void 0;
  }
  if (isRef(value)) {
    return (_a3 = value.current) != null ? _a3 : void 0;
  }
  return value;
}

// node_modules/@dnd-kit/react/hooks.js
function useConstant(initializer) {
  const ref = (0, import_react2.useRef)(null);
  if (!ref.current) {
    ref.current = initializer();
  }
  return ref.current;
}
var canUseDOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useIsomorphicLayoutEffect = canUseDOM2 ? import_react2.useLayoutEffect : import_react2.useEffect;
function useSignal(signal, sync = false) {
  let val = signal.peek();
  const read = (0, import_react2.useRef)(false);
  const update = (0, import_react2.useState)(val)[1];
  useIsomorphicLayoutEffect(
    () => E(() => {
      if (val !== (val = signal.value)) {
        if (!read.current) return;
        if (sync) {
          (0, import_react_dom.flushSync)(() => update(val));
        } else {
          update(val);
        }
      }
    }),
    [signal, sync]
  );
  return {
    get value() {
      read.current = true;
      return signal.value;
    }
  };
}
function useComputed(compute, dependencies = [], sync = false) {
  const $compute = (0, import_react2.useRef)(compute);
  $compute.current = compute;
  return useSignal(
    (0, import_react2.useMemo)(() => computed(() => $compute.current()), dependencies),
    sync
  );
}
function useImmediateEffect(callback, _2) {
  callback();
}
function useLatest(value) {
  const valueRef = (0, import_react2.useRef)(value);
  useIsomorphicLayoutEffect(() => {
    valueRef.current = value;
  }, [value]);
  return valueRef;
}
function useOnValueChange(value, onChange, effect2 = import_react2.useEffect, compare = Object.is) {
  const tracked = (0, import_react2.useRef)(value);
  effect2(() => {
    const oldValue = tracked.current;
    if (!compare(value, oldValue)) {
      tracked.current = value;
      onChange(value, oldValue);
    }
  }, [onChange, value]);
}
function useOnElementChange(value, onChange) {
  const previous = (0, import_react2.useRef)(currentValue(value));
  useIsomorphicLayoutEffect(() => {
    const current = currentValue(value);
    if (current !== previous.current) {
      previous.current = current;
      onChange(current);
    }
  });
}

// node_modules/@dnd-kit/react/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var __defProp5 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp5.call(b2, prop))
      __defNormalProp5(a2, prop, b2[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b2)) {
      if (__propIsEnum5.call(b2, prop))
        __defNormalProp5(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps4 = (a2, b2) => __defProps4(a2, __getOwnPropDescs4(b2));
var __objRest4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var defaultManager = new DragDropManager2();
var DragDropContext = (0, import_react3.createContext)(
  defaultManager
);
function useRenderer() {
  const [_2, startTransition2] = (0, import_react3.useTransition)();
  const [transitionCount, setTransitionCount] = (0, import_react3.useState)(0);
  const rendering = (0, import_react3.useRef)(null);
  const resolver = (0, import_react3.useRef)(null);
  const renderer = useConstant(() => ({
    get rendering() {
      var _a3;
      return (_a3 = rendering.current) != null ? _a3 : Promise.resolve();
    }
  }));
  useOnValueChange(
    transitionCount,
    () => {
      var _a3;
      (_a3 = resolver.current) == null ? void 0 : _a3.call(resolver);
      rendering.current = null;
    },
    import_react3.useLayoutEffect
  );
  return {
    renderer,
    trackRendering(callback) {
      if (!rendering.current) {
        rendering.current = new Promise((resolve) => {
          resolver.current = resolve;
        });
      }
      startTransition2(() => {
        callback();
        setTransitionCount((count) => count + 1);
      });
    }
  };
}
var options = [void 0, deepEqual];
function DragDropProvider(_a3) {
  var _b2 = _a3, {
    children,
    onCollision,
    onBeforeDragStart,
    onDragStart,
    onDragMove,
    onDragOver,
    onDragEnd
  } = _b2, input = __objRest4(_b2, [
    "children",
    "onCollision",
    "onBeforeDragStart",
    "onDragStart",
    "onDragMove",
    "onDragOver",
    "onDragEnd"
  ]);
  var _a22;
  const { renderer, trackRendering } = useRenderer();
  const [manager, setManager] = (0, import_react3.useState)(
    (_a22 = input.manager) != null ? _a22 : null
  );
  const { plugins, modifiers, sensors } = input;
  const handleBeforeDragStart = useLatest(onBeforeDragStart);
  const handleDragStart = useLatest(onDragStart);
  const handleDragOver = useLatest(onDragOver);
  const handleDragMove = useLatest(onDragMove);
  const handleDragEnd = useLatest(onDragEnd);
  const handleCollision = useLatest(onCollision);
  (0, import_react3.useEffect)(() => {
    var _a32;
    const manager2 = (_a32 = input.manager) != null ? _a32 : new DragDropManager2(input);
    manager2.renderer = renderer;
    manager2.monitor.addEventListener("beforedragstart", (event, manager3) => {
      const callback = handleBeforeDragStart.current;
      if (callback) {
        trackRendering(() => callback(event, manager3));
      }
    });
    manager2.monitor.addEventListener(
      "dragstart",
      (event, manager3) => {
        var _a4;
        return (_a4 = handleDragStart.current) == null ? void 0 : _a4.call(handleDragStart, event, manager3);
      }
    );
    manager2.monitor.addEventListener("dragover", (event, manager3) => {
      const callback = handleDragOver.current;
      if (callback) {
        trackRendering(() => callback(event, manager3));
      }
    });
    manager2.monitor.addEventListener("dragmove", (event, manager3) => {
      const callback = handleDragMove.current;
      if (callback) {
        trackRendering(() => callback(event, manager3));
      }
    });
    manager2.monitor.addEventListener("dragend", (event, manager3) => {
      const callback = handleDragEnd.current;
      if (callback) {
        trackRendering(() => callback(event, manager3));
      }
    });
    manager2.monitor.addEventListener(
      "collision",
      (event, manager3) => {
        var _a4;
        return (_a4 = handleCollision.current) == null ? void 0 : _a4.call(handleCollision, event, manager3);
      }
    );
    (0, import_react3.startTransition)(() => setManager(manager2));
    return manager2.destroy;
  }, [renderer, input.manager]);
  useOnValueChange(
    plugins,
    () => manager && (manager.plugins = plugins != null ? plugins : defaultPreset.plugins),
    ...options
  );
  useOnValueChange(
    sensors,
    () => manager && (manager.sensors = sensors != null ? sensors : defaultPreset.sensors),
    ...options
  );
  useOnValueChange(
    modifiers,
    () => manager && (manager.modifiers = modifiers != null ? modifiers : defaultPreset.modifiers),
    ...options
  );
  return (0, import_jsx_runtime.jsx)(DragDropContext.Provider, { value: manager, children });
}
function useDragDropManager() {
  return (0, import_react3.useContext)(DragDropContext);
}
function useInstance(initializer) {
  var _a3;
  const manager = (_a3 = useDragDropManager()) != null ? _a3 : void 0;
  const [instance] = (0, import_react3.useState)(() => initializer(void 0));
  if (instance.manager !== manager) {
    instance.manager = manager;
  }
  useIsomorphicLayoutEffect(instance.register, [manager, instance]);
  return instance;
}
function useDraggable(input) {
  const { disabled, data, element, handle, id, modifiers, sensors } = input;
  const draggable = useInstance(
    (manager) => new Draggable2(
      __spreadProps4(__spreadValues5({}, input), {
        handle: currentValue(handle),
        element: currentValue(element)
      }),
      manager
    )
  );
  const isDragSource = useComputed(() => draggable.isDragSource, [draggable]);
  const status = useComputed(() => draggable.status, [draggable]);
  useOnValueChange(id, () => draggable.id = id);
  useOnElementChange(handle, (handle2) => draggable.handle = handle2);
  useOnElementChange(element, (element2) => draggable.element = element2);
  useOnValueChange(data, () => data && (draggable.data = data));
  useOnValueChange(disabled, () => draggable.disabled = disabled === true);
  useOnValueChange(sensors, () => draggable.sensors = sensors);
  useOnValueChange(
    modifiers,
    () => draggable.modifiers = modifiers,
    void 0,
    deepEqual
  );
  useOnValueChange(
    input.feedback,
    () => {
      var _a3;
      return draggable.feedback = (_a3 = input.feedback) != null ? _a3 : "default";
    }
  );
  return {
    draggable,
    get isDragSource() {
      return isDragSource.value;
    },
    get status() {
      return status.value;
    },
    handleRef: (0, import_react3.useCallback)(
      (element2) => {
        draggable.handle = element2 != null ? element2 : void 0;
      },
      [draggable]
    ),
    ref: (0, import_react3.useCallback)(
      (element2) => {
        var _a3, _b2;
        if (!element2 && ((_a3 = draggable.element) == null ? void 0 : _a3.isConnected) && !((_b2 = draggable.manager) == null ? void 0 : _b2.dragOperation.status.idle)) {
          return;
        }
        draggable.element = element2 != null ? element2 : void 0;
      },
      [draggable]
    )
  };
}
function useDroppable(input) {
  const { collisionDetector, data, disabled, element, id, accept, type } = input;
  const droppable = useInstance(
    (manager) => new Droppable2(
      __spreadProps4(__spreadValues5({}, input), {
        element: currentValue(element)
      }),
      manager
    )
  );
  const isDropTarget = useComputed(() => droppable.isDropTarget, [droppable]);
  useOnValueChange(id, () => droppable.id = id);
  useOnElementChange(element, (element2) => droppable.element = element2);
  useOnValueChange(accept, () => droppable.id = id, void 0, deepEqual);
  useOnValueChange(collisionDetector, () => droppable.id = id);
  useOnValueChange(data, () => data && (droppable.data = data));
  useOnValueChange(disabled, () => droppable.disabled = disabled === true);
  useOnValueChange(type, () => droppable.id = id);
  return {
    get isDropTarget() {
      return isDropTarget.value;
    },
    ref: (0, import_react3.useCallback)(
      (element2) => {
        var _a3, _b2;
        if (!element2 && ((_a3 = droppable.element) == null ? void 0 : _a3.isConnected) && !((_b2 = droppable.manager) == null ? void 0 : _b2.dragOperation.status.idle)) {
          return;
        }
        droppable.element = element2 != null ? element2 : void 0;
      },
      [droppable]
    ),
    droppable
  };
}

// node_modules/@measured/puck/dist/index.mjs
var import_react19 = __toESM(require_react(), 1);

// node_modules/@dnd-kit/react/sortable.js
var import_react4 = __toESM(require_react());

// node_modules/@dnd-kit/dom/sortable.js
var __create5 = Object.create;
var __defProp6 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __knownSymbol4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp6.call(b2, prop))
      __defNormalProp6(a2, prop, b2[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b2)) {
      if (__propIsEnum6.call(b2, prop))
        __defNormalProp6(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps5 = (a2, b2) => __defProps5(a2, __getOwnPropDescs5(b2));
var __objRest5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart4 = (base) => {
  var _a3;
  return [, , , __create5((_a3 = void 0) != null ? _a3 : null)];
};
var __decoratorStrings4 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn4 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError6("Function expected") : fn;
var __decoratorContext4 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings4[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError6("Already initialized") : fns.push(__expectFn4(fn || null)) });
var __decoratorMetadata4 = (array, target) => __defNormalProp6(target, __knownSymbol4("metadata"), array[3]);
var __runInitializers4 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement4 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = array.length + 1, key = __decoratorStrings4[k + 5];
  var initializers = array[j - 1] = [], extraInitializers = array[j] || (array[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc5({ get [name]() {
    return __privateGet6(this, extra);
  }, set [name](x) {
    return __privateSet6(this, extra, x);
  } }, name));
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext4(k, name, done = {}, array[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
      access.set = (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])({ get: desc.get, set: desc.set }, ctx), done._ = 1;
    if (it === void 0) __expectFn4(it) && (desc[key] = it);
    else if (typeof it !== "object" || it === null) __typeError6("Object expected");
    else __expectFn4(fn = it.get) && (desc.get = fn), __expectFn4(fn = it.set) && (desc.set = fn), __expectFn4(fn = it.init) && initializers.unshift(fn);
  }
  return desc && __defProp6(target, name, desc), target;
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), member.get(obj));
var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), member.set(obj, value), value);
function isSortable(element) {
  return element instanceof SortableDroppable || element instanceof SortableDraggable;
}
var TOLERANCE = 10;
var SortableKeyboardPlugin = class extends Plugin {
  constructor(manager) {
    super(manager);
    const cleanupEffect = E(() => {
      const { dragOperation } = manager;
      if (!isKeyboardEvent(dragOperation.activatorEvent)) {
        return;
      }
      if (!isSortable(dragOperation.source)) {
        return;
      }
      if (dragOperation.status.initialized) {
        const scroller = manager.registry.plugins.get(Scroller);
        if (scroller) {
          scroller.disable();
          return () => scroller.enable();
        }
      }
    });
    const unsubscribe = manager.monitor.addEventListener(
      "dragmove",
      (event, manager2) => {
        queueMicrotask(() => {
          if (this.disabled || event.defaultPrevented) {
            return;
          }
          const { dragOperation } = manager2;
          if (!isKeyboardEvent(dragOperation.activatorEvent)) {
            return;
          }
          if (!isSortable(dragOperation.source)) {
            return;
          }
          if (!dragOperation.shape) {
            return;
          }
          const { actions, collisionObserver, registry } = manager2;
          const { by } = event;
          if (!by) {
            return;
          }
          const direction = getDirection2(by);
          const { source, target } = dragOperation;
          const { center } = dragOperation.shape.current;
          const potentialTargets = [];
          const cleanup = [];
          r(() => {
            for (const droppable of registry.droppables) {
              const { id: id2 } = droppable;
              if (!droppable.accepts(source) || id2 === (target == null ? void 0 : target.id) && isSortable(droppable) || !droppable.element) {
                continue;
              }
              let previousShape = droppable.shape;
              const shape = new DOMRectangle(droppable.element, {
                getBoundingClientRect: (element) => getVisibleBoundingRectangle(element, void 0, 0.2)
              });
              if (!shape.height || !shape.width) continue;
              if (direction == "down" && center.y + TOLERANCE < shape.center.y || direction == "up" && center.y - TOLERANCE > shape.center.y || direction == "left" && center.x - TOLERANCE > shape.center.x || direction == "right" && center.x + TOLERANCE < shape.center.x) {
                potentialTargets.push(droppable);
                droppable.shape = shape;
                cleanup.push(() => droppable.shape = previousShape);
              }
            }
          });
          event.preventDefault();
          collisionObserver.disable();
          const collisions = collisionObserver.computeCollisions(
            potentialTargets,
            closestCorners
          );
          r(() => cleanup.forEach((clean) => clean()));
          const [firstCollision] = collisions;
          if (!firstCollision) {
            return;
          }
          const { id } = firstCollision;
          const { index, group } = source.sortable;
          actions.setDropTarget(id).then((defaultPrevented) => {
            if (defaultPrevented) return;
            const { source: source2, target: target2 } = dragOperation;
            if (!source2 || !isSortable(source2)) {
              return;
            }
            const {
              index: newIndex,
              group: newGroup,
              target: targetElement
            } = source2.sortable;
            const updated = index !== newIndex || group !== newGroup;
            const element = updated ? targetElement : target2 == null ? void 0 : target2.element;
            if (!element) return;
            scrollIntoViewIfNeeded(element);
            const shape = new DOMRectangle(element);
            if (!shape) {
              return;
            }
            actions.move({
              to: {
                x: shape.center.x,
                y: shape.center.y
              }
            });
            if (updated) {
              actions.setDropTarget(source2.id).then(() => collisionObserver.enable());
            } else {
              collisionObserver.enable();
            }
          });
        });
      }
    );
    this.destroy = () => {
      unsubscribe();
      cleanupEffect();
    };
  }
};
function getDirection2(delta) {
  const { x, y: y2 } = delta;
  if (x > 0) {
    return "right";
  } else if (x < 0) {
    return "left";
  } else if (y2 > 0) {
    return "down";
  } else if (y2 < 0) {
    return "up";
  }
}
var __defProp22 = Object.defineProperty;
var __defProps22 = Object.defineProperties;
var __getOwnPropDescs22 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols22 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues22 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp22.call(b2, prop))
      __defNormalProp22(a2, prop, b2[prop]);
  if (__getOwnPropSymbols22)
    for (var prop of __getOwnPropSymbols22(b2)) {
      if (__propIsEnum22.call(b2, prop))
        __defNormalProp22(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps22 = (a2, b2) => __defProps22(a2, __getOwnPropDescs22(b2));
function arrayMove(array, from, to) {
  if (from === to) {
    return array;
  }
  const newArray = array.slice();
  newArray.splice(to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}
function mutate(items, event, mutation) {
  var _a3, _b2;
  const { source, target, canceled } = event.operation;
  if (!source || !target || canceled) {
    if ("preventDefault" in event) event.preventDefault();
    return items;
  }
  const findIndex = (item, id) => item === id || typeof item === "object" && "id" in item && item.id === id;
  if (Array.isArray(items)) {
    const sourceIndex2 = items.findIndex((item) => findIndex(item, source.id));
    const targetIndex2 = items.findIndex((item) => findIndex(item, target.id));
    if (sourceIndex2 === -1 || targetIndex2 === -1) {
      return items;
    }
    if (!canceled && "index" in source && typeof source.index === "number") {
      const projectedSourceIndex = source.index;
      if (projectedSourceIndex !== sourceIndex2) {
        return mutation(items, sourceIndex2, projectedSourceIndex);
      }
    }
    return mutation(items, sourceIndex2, targetIndex2);
  }
  const entries = Object.entries(items);
  let sourceIndex = -1;
  let sourceParent;
  let targetIndex = -1;
  let targetParent;
  for (const [id, children] of entries) {
    if (sourceIndex === -1) {
      sourceIndex = children.findIndex((item) => findIndex(item, source.id));
      if (sourceIndex !== -1) {
        sourceParent = id;
      }
    }
    if (targetIndex === -1) {
      targetIndex = children.findIndex((item) => findIndex(item, target.id));
      if (targetIndex !== -1) {
        targetParent = id;
      }
    }
    if (sourceIndex !== -1 && targetIndex !== -1) {
      break;
    }
  }
  if (!source.manager) return items;
  const { dragOperation } = source.manager;
  const position = (_b2 = (_a3 = dragOperation.shape) == null ? void 0 : _a3.current.center) != null ? _b2 : dragOperation.position.current;
  if (targetParent == null) {
    if (target.id in items) {
      const insertionIndex = target.shape && position.y > target.shape.center.y ? items[target.id].length : 0;
      targetParent = target.id;
      targetIndex = insertionIndex;
    }
  }
  if (sourceParent == null || targetParent == null || sourceParent === targetParent && sourceIndex === targetIndex) {
    if ("preventDefault" in event) event.preventDefault();
    return items;
  }
  if (sourceParent === targetParent) {
    return __spreadProps22(__spreadValues22({}, items), {
      [sourceParent]: mutation(items[sourceParent], sourceIndex, targetIndex)
    });
  }
  const isBelowTarget = target.shape && Math.round(position.y) > Math.round(target.shape.center.y);
  const modifier = isBelowTarget ? 1 : 0;
  const sourceItem = items[sourceParent][sourceIndex];
  return __spreadProps22(__spreadValues22({}, items), {
    [sourceParent]: [
      ...items[sourceParent].slice(0, sourceIndex),
      ...items[sourceParent].slice(sourceIndex + 1)
    ],
    [targetParent]: [
      ...items[targetParent].slice(0, targetIndex + modifier),
      sourceItem,
      ...items[targetParent].slice(targetIndex + modifier)
    ]
  });
}
function move(items, event) {
  return mutate(items, event, arrayMove);
}
var defaultGroup = "__default__";
var OptimisticSortingPlugin = class extends Plugin {
  constructor(manager) {
    super(manager);
    const getSortableInstances = () => {
      const sortableInstances = /* @__PURE__ */ new Map();
      for (const droppable of manager.registry.droppables) {
        if (droppable instanceof SortableDroppable) {
          const { sortable } = droppable;
          const { group } = sortable;
          let instances = sortableInstances.get(group);
          if (!instances) {
            instances = /* @__PURE__ */ new Set();
            sortableInstances.set(group, instances);
          }
          instances.add(sortable);
        }
      }
      for (const [group, instances] of sortableInstances) {
        sortableInstances.set(group, new Set(sort(instances)));
      }
      return sortableInstances;
    };
    const unsubscribe = [
      manager.monitor.addEventListener("dragover", (event, manager2) => {
        queueMicrotask(() => {
          if (this.disabled || event.defaultPrevented) {
            return;
          }
          const { dragOperation } = manager2;
          const { source, target } = dragOperation;
          if (!isSortable(source) || !isSortable(target)) {
            return;
          }
          if (source.sortable === target.sortable) {
            return;
          }
          const instances = getSortableInstances();
          const sameGroup = source.sortable.group === target.sortable.group;
          const sourceInstances = instances.get(source.sortable.group);
          const targetInstances = sameGroup ? sourceInstances : instances.get(target.sortable.group);
          if (!sourceInstances || !targetInstances) return;
          manager2.renderer.rendering.then(() => {
            var _a3, _b2, _c4;
            const newInstances = getSortableInstances();
            for (const [group, sortableInstances] of instances.entries()) {
              const entries = Array.from(sortableInstances).entries();
              for (const [index, sortable] of entries) {
                if (sortable.index !== index || sortable.group !== group || !((_a3 = newInstances.get(group)) == null ? void 0 : _a3.has(sortable))) {
                  return;
                }
              }
            }
            const sourceElement = source.sortable.element;
            const targetElement = target.sortable.element;
            if (!targetElement || !sourceElement) {
              return;
            }
            if (!sameGroup && target.id === source.sortable.group) {
              return;
            }
            const orderedSourceSortables = sort(sourceInstances);
            const orderedTargetSortables = sameGroup ? orderedSourceSortables : sort(targetInstances);
            const sourceGroup = (_b2 = source.sortable.group) != null ? _b2 : defaultGroup;
            const targetGroup = (_c4 = target.sortable.group) != null ? _c4 : defaultGroup;
            const state = {
              [sourceGroup]: orderedSourceSortables,
              [targetGroup]: orderedTargetSortables
            };
            const newState = move(state, event);
            if (state === newState) return;
            const sourceIndex = newState[targetGroup].indexOf(source.sortable);
            const targetIndex = newState[targetGroup].indexOf(target.sortable);
            reorder(sourceElement, sourceIndex, targetElement, targetIndex);
            manager2.collisionObserver.disable();
            r(() => {
              for (const [index, sortable] of newState[sourceGroup].entries()) {
                sortable.index = index;
              }
              if (!sameGroup) {
                for (const [index, sortable] of newState[targetGroup].entries()) {
                  sortable.group = target.sortable.group;
                  sortable.index = index;
                }
              }
            });
            manager2.actions.setDropTarget(source.id).then(() => manager2.collisionObserver.enable());
          });
        });
      }),
      manager.monitor.addEventListener("dragend", (event, manager2) => {
        if (!event.canceled) {
          return;
        }
        const { dragOperation } = manager2;
        const { source } = dragOperation;
        if (!isSortable(source)) {
          return;
        }
        if (source.sortable.initialIndex === source.sortable.index && source.sortable.initialGroup === source.sortable.group) {
          return;
        }
        queueMicrotask(() => {
          const instances = getSortableInstances();
          const initialGroupInstances = instances.get(
            source.sortable.initialGroup
          );
          if (!initialGroupInstances) return;
          manager2.renderer.rendering.then(() => {
            var _a3;
            for (const [group, sortableInstances] of instances.entries()) {
              const entries = Array.from(sortableInstances).entries();
              for (const [index, sortable] of entries) {
                if (sortable.index !== index || sortable.group !== group) {
                  return;
                }
              }
            }
            const initialGroup = sort(initialGroupInstances);
            const sourceElement = source.sortable.element;
            const targetElement = (_a3 = initialGroup[source.sortable.initialIndex]) == null ? void 0 : _a3.element;
            if (!targetElement || !sourceElement) {
              return;
            }
            reorder(
              sourceElement,
              source.sortable.initialIndex,
              targetElement,
              source.sortable.initialIndex
            );
            r(() => {
              for (const [_2, sortableInstances] of instances.entries()) {
                const entries = Array.from(sortableInstances).values();
                for (const sortable of entries) {
                  sortable.index = sortable.initialIndex;
                  sortable.group = sortable.initialGroup;
                }
              }
            });
          });
        });
      })
    ];
    this.destroy = () => {
      for (const unsubscribeListener of unsubscribe) {
        unsubscribeListener();
      }
    };
  }
};
function reorder(sourceElement, sourceIndex, targetElement, targetIndex) {
  const position = targetIndex < sourceIndex ? "afterend" : "beforebegin";
  targetElement.insertAdjacentElement(position, sourceElement);
}
function sortByIndex(a2, b2) {
  return a2.index - b2.index;
}
function sort(instances) {
  return Array.from(instances).sort(sortByIndex);
}
var defaultPlugins = [
  SortableKeyboardPlugin,
  OptimisticSortingPlugin
];
var defaultSortableTransition = {
  duration: 250,
  easing: "cubic-bezier(0.25, 1, 0.5, 1)",
  idle: false
};
var _group_dec;
var _index_dec;
var _init6;
var _index;
var _group;
var _element3;
_index_dec = [reactive], _group_dec = [reactive];
var Sortable2 = class {
  constructor(_a3, manager) {
    __privateAdd6(this, _index, __runInitializers4(_init6, 8, this)), __runInitializers4(_init6, 11, this);
    __privateAdd6(this, _group, __runInitializers4(_init6, 12, this)), __runInitializers4(_init6, 15, this);
    __privateAdd6(this, _element3);
    this.register = () => {
      r(() => {
        var _a4, _b3;
        (_a4 = this.manager) == null ? void 0 : _a4.registry.register(this.droppable);
        (_b3 = this.manager) == null ? void 0 : _b3.registry.register(this.draggable);
      });
      return () => this.unregister();
    };
    this.unregister = () => {
      r(() => {
        var _a4, _b3;
        (_a4 = this.manager) == null ? void 0 : _a4.registry.unregister(this.droppable);
        (_b3 = this.manager) == null ? void 0 : _b3.registry.unregister(this.draggable);
      });
    };
    this.destroy = () => {
      r(() => {
        this.droppable.destroy();
        this.draggable.destroy();
      });
    };
    var _b2 = _a3, {
      effects: inputEffects = () => [],
      group,
      index,
      sensors,
      type,
      transition = defaultSortableTransition,
      plugins = defaultPlugins
    } = _b2, input = __objRest5(_b2, [
      "effects",
      "group",
      "index",
      "sensors",
      "type",
      "transition",
      "plugins"
    ]);
    let previousGroup = group;
    this.droppable = new SortableDroppable(input, manager, this);
    this.draggable = new SortableDraggable(
      __spreadProps5(__spreadValues6({}, input), {
        effects: () => [
          () => {
            var _a22;
            return (_a22 = this.manager) == null ? void 0 : _a22.monitor.addEventListener("dragstart", () => {
              this.initialIndex = this.index;
              this.initialGroup = this.group;
              this.previousIndex = this.index;
            });
          },
          () => {
            const { index: index2, group: group2, previousIndex, manager: _2 } = this;
            if (index2 !== previousIndex || group2 !== previousGroup) {
              this.previousIndex = index2;
              previousGroup = group2;
              this.animate();
            }
          },
          () => {
            const { target } = this;
            const { feedback, isDragSource } = this.draggable;
            if (feedback == "move" && isDragSource) {
              this.droppable.disabled = !target;
            }
          },
          () => {
            const { manager: manager2 } = this;
            for (const plugin of plugins) {
              manager2 == null ? void 0 : manager2.registry.register(plugin);
            }
          },
          ...inputEffects()
        ],
        type,
        sensors
      }),
      manager,
      this
    );
    __privateSet6(this, _element3, input.element);
    this.manager = manager;
    this.index = index;
    this.previousIndex = index;
    this.initialIndex = index;
    this.group = group;
    this.type = type;
    this.transition = transition;
  }
  animate() {
    n(() => {
      const { manager, transition } = this;
      const { shape } = this.droppable;
      if (!manager) return;
      const { idle } = manager.dragOperation.status;
      if (!shape || !transition || idle && !transition.idle) {
        return;
      }
      manager.renderer.rendering.then(() => {
        const { element } = this;
        if (!element) {
          return;
        }
        const updatedShape = this.refreshShape();
        if (!updatedShape) {
          return;
        }
        queueMicrotask(() => {
          const delta = {
            x: shape.boundingRectangle.left - updatedShape.boundingRectangle.left,
            y: shape.boundingRectangle.top - updatedShape.boundingRectangle.top
          };
          const { translate } = getComputedStyles(element);
          const currentTranslate = computeTranslate(element, translate, false);
          const finalTranslate = computeTranslate(element, translate);
          if (delta.x || delta.y) {
            animateTransform({
              element,
              keyframes: {
                translate: [
                  `${currentTranslate.x + delta.x}px ${currentTranslate.y + delta.y}px ${currentTranslate.z}`,
                  `${finalTranslate.x}px ${finalTranslate.y}px ${finalTranslate.z}`
                ]
              },
              options: transition,
              onFinish: () => {
                if (!manager.dragOperation.status.dragging) {
                  this.droppable.shape = void 0;
                }
              }
            });
          }
        });
      });
    });
  }
  get manager() {
    return this.draggable.manager;
  }
  set manager(manager) {
    r(() => {
      this.draggable.manager = manager;
      this.droppable.manager = manager;
    });
  }
  set element(element) {
    r(() => {
      const previousElement = __privateGet6(this, _element3);
      const droppableElement = this.droppable.element;
      const draggableElement = this.draggable.element;
      if (!droppableElement || droppableElement === previousElement) {
        this.droppable.element = element;
      }
      if (!draggableElement || draggableElement === previousElement) {
        this.draggable.element = element;
      }
      __privateSet6(this, _element3, element);
    });
  }
  get element() {
    var _a3, _b2;
    const element = __privateGet6(this, _element3);
    if (!element) return;
    return (_b2 = (_a3 = ProxiedElements.get(element)) != null ? _a3 : element) != null ? _b2 : this.droppable.element;
  }
  set target(target) {
    this.droppable.element = target;
  }
  get target() {
    return this.droppable.element;
  }
  set source(source) {
    this.draggable.element = source;
  }
  get source() {
    return this.draggable.element;
  }
  get disabled() {
    return this.draggable.disabled && this.droppable.disabled;
  }
  set feedback(value) {
    this.draggable.feedback = value;
  }
  set disabled(value) {
    r(() => {
      this.droppable.disabled = value;
      this.draggable.disabled = value;
    });
  }
  set data(data) {
    r(() => {
      this.droppable.data = data;
      this.draggable.data = data;
    });
  }
  set handle(handle) {
    this.draggable.handle = handle;
  }
  set id(id) {
    r(() => {
      this.droppable.id = id;
      this.draggable.id = id;
    });
  }
  get id() {
    return this.droppable.id;
  }
  set sensors(value) {
    this.draggable.sensors = value;
  }
  set modifiers(value) {
    this.draggable.modifiers = value;
  }
  set collisionPriority(value) {
    this.droppable.collisionPriority = value;
  }
  set collisionDetector(value) {
    this.droppable.collisionDetector = value != null ? value : defaultCollisionDetection;
  }
  set type(type) {
    r(() => {
      this.droppable.type = type;
      this.draggable.type = type;
    });
  }
  get type() {
    return this.draggable.type;
  }
  set accept(value) {
    this.droppable.accept = value;
  }
  get accept() {
    return this.droppable.accept;
  }
  get isDropTarget() {
    return this.droppable.isDropTarget;
  }
  /**
   * A boolean indicating whether the sortable item is the source of a drag operation.
   */
  get isDragSource() {
    return this.draggable.isDragSource;
  }
  get status() {
    return this.draggable.status;
  }
  refreshShape() {
    return this.droppable.refreshShape();
  }
  accepts(draggable) {
    return this.droppable.accepts(draggable);
  }
};
_init6 = __decoratorStart4();
_index = /* @__PURE__ */ new WeakMap();
_group = /* @__PURE__ */ new WeakMap();
_element3 = /* @__PURE__ */ new WeakMap();
__decorateElement4(_init6, 4, "index", _index_dec, Sortable2, _index);
__decorateElement4(_init6, 4, "group", _group_dec, Sortable2, _group);
__decoratorMetadata4(_init6, Sortable2);
var SortableDraggable = class extends Draggable2 {
  constructor(input, manager, sortable) {
    super(input, manager);
    this.sortable = sortable;
  }
  get index() {
    return this.sortable.index;
  }
};
var SortableDroppable = class extends Droppable2 {
  constructor(input, manager, sortable) {
    super(input, manager);
    this.sortable = sortable;
  }
};

// node_modules/@dnd-kit/react/sortable.js
var __defProp7 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp7.call(b2, prop))
      __defNormalProp7(a2, prop, b2[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b2)) {
      if (__propIsEnum7.call(b2, prop))
        __defNormalProp7(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps6 = (a2, b2) => __defProps6(a2, __getOwnPropDescs6(b2));
function useSortable(input) {
  const {
    accept,
    collisionDetector,
    collisionPriority,
    id,
    data,
    element,
    handle,
    index,
    group,
    disabled,
    feedback,
    modifiers,
    sensors,
    target,
    transition = defaultSortableTransition,
    type
  } = input;
  const sortable = useInstance((manager) => {
    return new Sortable2(
      __spreadProps6(__spreadValues7({}, input), {
        handle: currentValue(handle),
        element: currentValue(element),
        target: currentValue(target),
        feedback
      }),
      manager
    );
  });
  const isDropTarget = useComputed(() => sortable.isDropTarget, [sortable]);
  const isDragSource = useComputed(() => sortable.isDragSource, [sortable]);
  const status = useComputed(() => sortable.status, [sortable]);
  useOnValueChange(id, () => sortable.id = id);
  useIsomorphicLayoutEffect(() => {
    r(() => {
      sortable.group = group;
      sortable.index = index;
    });
  }, [sortable, group, index]);
  useOnValueChange(type, () => sortable.type = type);
  useOnValueChange(
    accept,
    () => sortable.accept = accept,
    void 0,
    deepEqual
  );
  useOnValueChange(data, () => data && (sortable.data = data));
  useOnValueChange(
    index,
    () => {
      var _a3;
      if (((_a3 = sortable.manager) == null ? void 0 : _a3.dragOperation.status.idle) && (transition == null ? void 0 : transition.idle)) {
        sortable.refreshShape();
      }
    },
    useImmediateEffect
  );
  useOnElementChange(handle, (handle2) => sortable.handle = handle2);
  useOnElementChange(element, (element2) => sortable.element = element2);
  useOnElementChange(target, (target2) => sortable.target = target2);
  useOnValueChange(disabled, () => sortable.disabled = disabled === true);
  useOnValueChange(sensors, () => sortable.sensors = sensors);
  useOnValueChange(
    collisionDetector,
    () => sortable.collisionDetector = collisionDetector
  );
  useOnValueChange(
    collisionPriority,
    () => sortable.collisionPriority = collisionPriority
  );
  useOnValueChange(feedback, () => sortable.feedback = feedback != null ? feedback : "default");
  useOnValueChange(transition, () => sortable.transition = transition);
  useOnValueChange(
    modifiers,
    () => sortable.modifiers = modifiers,
    void 0,
    deepEqual
  );
  return {
    get isDragSource() {
      return isDragSource.value;
    },
    get isDropTarget() {
      return isDropTarget.value;
    },
    get status() {
      return status.value;
    },
    handleRef: (0, import_react4.useCallback)(
      (element2) => {
        sortable.handle = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    ref: (0, import_react4.useCallback)(
      (element2) => {
        var _a3, _b2;
        if (!element2 && ((_a3 = sortable.element) == null ? void 0 : _a3.isConnected) && !((_b2 = sortable.manager) == null ? void 0 : _b2.dragOperation.status.idle)) {
          return;
        }
        sortable.element = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    sourceRef: (0, import_react4.useCallback)(
      (element2) => {
        var _a3, _b2;
        if (!element2 && ((_a3 = sortable.source) == null ? void 0 : _a3.isConnected) && !((_b2 = sortable.manager) == null ? void 0 : _b2.dragOperation.status.idle)) {
          return;
        }
        sortable.source = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    targetRef: (0, import_react4.useCallback)(
      (element2) => {
        var _a3, _b2;
        if (!element2 && ((_a3 = sortable.target) == null ? void 0 : _a3.isConnected) && !((_b2 = sortable.manager) == null ? void 0 : _b2.dragOperation.status.idle)) {
          return;
        }
        sortable.target = element2 != null ? element2 : void 0;
      },
      [sortable]
    )
  };
}

// node_modules/@measured/puck/dist/index.mjs
var import_react21 = __toESM(require_react(), 1);

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/@dnd-kit/abstract/modifiers.js
var __defProp8 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp8.call(b2, prop))
      __defNormalProp8(a2, prop, b2[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b2)) {
      if (__propIsEnum8.call(b2, prop))
        __defNormalProp8(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps7 = (a2, b2) => __defProps7(a2, __getOwnPropDescs7(b2));
var _AxisModifier = class _AxisModifier2 extends Modifier {
  apply({ transform }) {
    if (!this.options) {
      return transform;
    }
    const { axis, value } = this.options;
    return __spreadProps7(__spreadValues8({}, transform), {
      [axis]: value
    });
  }
};
_AxisModifier.configure = configurator(_AxisModifier);
var AxisModifier = _AxisModifier;
var RestrictToVerticalAxis = AxisModifier.configure({
  axis: "x",
  value: 0
});
var RestrictToHorizontalAxis = AxisModifier.configure({
  axis: "y",
  value: 0
});
function restrictShapeToBoundingRectangle(shape, transform, boundingRect) {
  const value = __spreadValues8({}, transform);
  if (shape.boundingRectangle.top + transform.y <= boundingRect.top) {
    value.y = boundingRect.top - shape.boundingRectangle.top;
  } else if (shape.boundingRectangle.bottom + transform.y >= boundingRect.top + boundingRect.height) {
    value.y = boundingRect.top + boundingRect.height - shape.boundingRectangle.bottom;
  }
  if (shape.boundingRectangle.left + transform.x <= boundingRect.left) {
    value.x = boundingRect.left - shape.boundingRectangle.left;
  } else if (shape.boundingRectangle.right + transform.x >= boundingRect.left + boundingRect.width) {
    value.x = boundingRect.left + boundingRect.width - shape.boundingRectangle.right;
  }
  return value;
}
var _SnapModifier = class _SnapModifier2 extends Modifier {
  apply({ transform }) {
    var _a3;
    const { size = 20 } = (_a3 = this.options) != null ? _a3 : {};
    const x = typeof size === "number" ? size : size.x;
    const y2 = typeof size === "number" ? size : size.y;
    return __spreadProps7(__spreadValues8({}, transform), {
      x: Math.ceil(transform.x / x) * x,
      y: Math.ceil(transform.y / y2) * y2
    });
  }
};
_SnapModifier.configure = configurator(_SnapModifier);

// node_modules/@dnd-kit/dom/modifiers.js
var _RestrictToElement = class _RestrictToElement2 extends Modifier {
  constructor(manager, options2) {
    super(manager, options2);
    this.boundingRectangle = d(null);
    this.destroy = E(() => {
      if (!this.options) {
        return;
      }
      const { dragOperation } = manager;
      const { status } = dragOperation;
      if (status.initialized) {
        const { element } = this.options;
        const target = typeof element === "function" ? element(dragOperation) : element;
        if (!target) {
          return;
        }
        let timeout3;
        const updateBoundingRectangle = () => {
          this.boundingRectangle.value = getBoundingRectangle(target);
        };
        const handleScroll = () => {
          if (timeout3) {
            return;
          }
          timeout3 = setTimeout(() => {
            updateBoundingRectangle();
            timeout3 = void 0;
          }, 25);
        };
        const resizeObserver = new ResizeObserver(updateBoundingRectangle);
        resizeObserver.observe(target);
        document.addEventListener("scroll", handleScroll, {
          passive: true,
          capture: true
        });
        return () => {
          document.removeEventListener("scroll", handleScroll, {
            capture: true
          });
          resizeObserver.disconnect();
          this.boundingRectangle.value = null;
        };
      }
    });
  }
  apply(operation) {
    const { shape, transform } = operation;
    if (!shape) {
      return transform;
    }
    const boundingRectangle = this.boundingRectangle.value;
    if (!boundingRectangle) {
      return transform;
    }
    const { initial, current } = shape;
    const { height, width } = current.boundingRectangle;
    const left = initial.center.x - width / 2;
    const top = initial.center.y - height / 2;
    const restrictedTransform = restrictShapeToBoundingRectangle(
      new Rectangle(left, top, width, height),
      transform,
      boundingRectangle
    );
    return restrictedTransform;
  }
};
_RestrictToElement.configure = configurator(_RestrictToElement);
var RestrictToElement = _RestrictToElement;

// node_modules/@measured/puck/dist/index.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
var import_react24 = __toESM(require_react(), 1);
var import_react25 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react27 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);

// node_modules/use-debounce/dist/index.module.js
var import_react6 = __toESM(require_react());
function c2(u3, e3, c3) {
  var i2 = this, a2 = (0, import_react6.useRef)(null), o2 = (0, import_react6.useRef)(0), f2 = (0, import_react6.useRef)(null), l2 = (0, import_react6.useRef)([]), m = (0, import_react6.useRef)(), v2 = (0, import_react6.useRef)(), d2 = (0, import_react6.useRef)(u3), p2 = (0, import_react6.useRef)(true);
  (0, import_react6.useEffect)(function() {
    d2.current = u3;
  }, [u3]);
  var g2 = !e3 && 0 !== e3 && "undefined" != typeof window;
  if ("function" != typeof u3) throw new TypeError("Expected a function");
  e3 = +e3 || 0;
  var w2 = !!(c3 = c3 || {}).leading, s2 = !("trailing" in c3) || !!c3.trailing, x = "maxWait" in c3, y2 = x ? Math.max(+c3.maxWait || 0, e3) : null;
  (0, import_react6.useEffect)(function() {
    return p2.current = true, function() {
      p2.current = false;
    };
  }, []);
  var h2 = (0, import_react6.useMemo)(function() {
    var r3 = function(r4) {
      var n4 = l2.current, t4 = m.current;
      return l2.current = m.current = null, o2.current = r4, v2.current = d2.current.apply(t4, n4);
    }, n3 = function(r4, n4) {
      g2 && cancelAnimationFrame(f2.current), f2.current = g2 ? requestAnimationFrame(r4) : setTimeout(r4, n4);
    }, t3 = function(r4) {
      if (!p2.current) return false;
      var n4 = r4 - a2.current;
      return !a2.current || n4 >= e3 || n4 < 0 || x && r4 - o2.current >= y2;
    }, u4 = function(n4) {
      return f2.current = null, s2 && l2.current ? r3(n4) : (l2.current = m.current = null, v2.current);
    }, c4 = function r4() {
      var c5 = Date.now();
      if (t3(c5)) return u4(c5);
      if (p2.current) {
        var i3 = e3 - (c5 - a2.current), f3 = x ? Math.min(i3, y2 - (c5 - o2.current)) : i3;
        n3(r4, f3);
      }
    }, h3 = function() {
      var u5 = Date.now(), d3 = t3(u5);
      if (l2.current = [].slice.call(arguments), m.current = i2, a2.current = u5, d3) {
        if (!f2.current && p2.current) return o2.current = a2.current, n3(c4, e3), w2 ? r3(a2.current) : v2.current;
        if (x) return n3(c4, e3), r3(a2.current);
      }
      return f2.current || n3(c4, e3), v2.current;
    };
    return h3.cancel = function() {
      f2.current && (g2 ? cancelAnimationFrame(f2.current) : clearTimeout(f2.current)), o2.current = 0, l2.current = a2.current = m.current = f2.current = null;
    }, h3.isPending = function() {
      return !!f2.current;
    }, h3.flush = function() {
      return f2.current ? u4(Date.now()) : v2.current;
    }, h3;
  }, [w2, x, e3, y2, s2, g2]);
  return h2;
}

// node_modules/@measured/puck/dist/index.mjs
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react29 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);
var import_react32 = __toESM(require_react(), 1);
var import_react33 = __toESM(require_react(), 1);
var import_react34 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_react35 = __toESM(require_react(), 1);

// node_modules/zustand/esm/react.mjs
var import_react7 = __toESM(require_react(), 1);
var identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = import_react7.default.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  import_react7.default.useDebugValue(slice);
  return slice;
}

// node_modules/@measured/puck/dist/index.mjs
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);

// node_modules/zustand/esm/react/shallow.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/zustand/esm/vanilla/shallow.mjs
var isIterable = (obj) => Symbol.iterator in obj;
var hasIterableEntries = (value) => (
  // HACK: avoid checking entries type
  "entries" in value
);
var compareEntries = (valueA, valueB) => {
  const mapA = valueA instanceof Map ? valueA : new Map(valueA.entries());
  const mapB = valueB instanceof Map ? valueB : new Map(valueB.entries());
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value] of mapA) {
    if (!Object.is(value, mapB.get(key))) {
      return false;
    }
  }
  return true;
};
var compareIterables = (valueA, valueB) => {
  const iteratorA = valueA[Symbol.iterator]();
  const iteratorB = valueB[Symbol.iterator]();
  let nextA = iteratorA.next();
  let nextB = iteratorB.next();
  while (!nextA.done && !nextB.done) {
    if (!Object.is(nextA.value, nextB.value)) {
      return false;
    }
    nextA = iteratorA.next();
    nextB = iteratorB.next();
  }
  return !!nextA.done && !!nextB.done;
};
function shallow(valueA, valueB) {
  if (Object.is(valueA, valueB)) {
    return true;
  }
  if (typeof valueA !== "object" || valueA === null || typeof valueB !== "object" || valueB === null) {
    return false;
  }
  if (!isIterable(valueA) || !isIterable(valueB)) {
    return compareEntries(
      { entries: () => Object.entries(valueA) },
      { entries: () => Object.entries(valueB) }
    );
  }
  if (hasIterableEntries(valueA) && hasIterableEntries(valueB)) {
    return compareEntries(valueA, valueB);
  }
  return compareIterables(valueA, valueB);
}

// node_modules/zustand/esm/react/shallow.mjs
function useShallow(selector) {
  const prev = import_react8.default.useRef(void 0);
  return (state) => {
    const next = selector(state);
    return shallow(prev.current, next) ? prev.current : prev.current = next;
  };
}

// node_modules/@measured/puck/dist/index.mjs
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react37 = __toESM(require_react(), 1);
var import_react38 = __toESM(require_react(), 1);
var import_react40 = __toESM(require_react(), 1);
var import_react41 = __toESM(require_react(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react42 = __toESM(require_react(), 1);
var import_react43 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);
var import_react45 = __toESM(require_react(), 1);
var import_react46 = __toESM(require_react(), 1);
var import_react47 = __toESM(require_react(), 1);
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);
var import_react51 = __toESM(require_react(), 1);
var import_object_hash = __toESM(require_object_hash(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);

// node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js
var import_react9 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n3) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t3 = arguments[e3];
      for (var r3 in t3) ({}).hasOwnProperty.call(t3, r3) && (n3[r3] = t3[r3]);
    }
    return n3;
  }, _extends.apply(null, arguments);
}
var reservedModifierKeywords = ["shift", "alt", "meta", "mod", "ctrl"];
var mappedKeys = {
  esc: "escape",
  "return": "enter",
  ".": "period",
  ",": "comma",
  "-": "slash",
  " ": "space",
  "`": "backquote",
  "#": "backslash",
  "+": "bracketright",
  ShiftLeft: "shift",
  ShiftRight: "shift",
  AltLeft: "alt",
  AltRight: "alt",
  MetaLeft: "meta",
  MetaRight: "meta",
  OSLeft: "meta",
  OSRight: "meta",
  ControlLeft: "ctrl",
  ControlRight: "ctrl"
};
function mapKey(key) {
  return (key && mappedKeys[key] || key || "").trim().toLowerCase().replace(/key|digit|numpad|arrow/, "");
}
function isHotkeyModifier(key) {
  return reservedModifierKeywords.includes(key);
}
function parseKeysHookInput(keys, splitKey) {
  if (splitKey === void 0) {
    splitKey = ",";
  }
  return keys.split(splitKey);
}
function parseHotkey(hotkey, combinationKey, description) {
  if (combinationKey === void 0) {
    combinationKey = "+";
  }
  var keys = hotkey.toLocaleLowerCase().split(combinationKey).map(function(k) {
    return mapKey(k);
  });
  var modifiers = {
    alt: keys.includes("alt"),
    ctrl: keys.includes("ctrl") || keys.includes("control"),
    shift: keys.includes("shift"),
    meta: keys.includes("meta"),
    mod: keys.includes("mod")
  };
  var singleCharKeys = keys.filter(function(k) {
    return !reservedModifierKeywords.includes(k);
  });
  return _extends({}, modifiers, {
    keys: singleCharKeys,
    description,
    hotkey
  });
}
(function() {
  if (typeof document !== "undefined") {
    document.addEventListener("keydown", function(e3) {
      if (e3.key === void 0) {
        return;
      }
      pushToCurrentlyPressedKeys([mapKey(e3.key), mapKey(e3.code)]);
    });
    document.addEventListener("keyup", function(e3) {
      if (e3.key === void 0) {
        return;
      }
      removeFromCurrentlyPressedKeys([mapKey(e3.key), mapKey(e3.code)]);
    });
  }
  if (typeof window !== "undefined") {
    window.addEventListener("blur", function() {
      currentlyPressedKeys.clear();
    });
  }
})();
var currentlyPressedKeys = /* @__PURE__ */ new Set();
function isReadonlyArray(value) {
  return Array.isArray(value);
}
function isHotkeyPressed(key, splitKey) {
  if (splitKey === void 0) {
    splitKey = ",";
  }
  var hotkeyArray = isReadonlyArray(key) ? key : key.split(splitKey);
  return hotkeyArray.every(function(hotkey) {
    return currentlyPressedKeys.has(hotkey.trim().toLowerCase());
  });
}
function pushToCurrentlyPressedKeys(key) {
  var hotkeyArray = Array.isArray(key) ? key : [key];
  if (currentlyPressedKeys.has("meta")) {
    currentlyPressedKeys.forEach(function(key2) {
      return !isHotkeyModifier(key2) && currentlyPressedKeys["delete"](key2.toLowerCase());
    });
  }
  hotkeyArray.forEach(function(hotkey) {
    return currentlyPressedKeys.add(hotkey.toLowerCase());
  });
}
function removeFromCurrentlyPressedKeys(key) {
  var hotkeyArray = Array.isArray(key) ? key : [key];
  if (key === "meta") {
    currentlyPressedKeys.clear();
  } else {
    hotkeyArray.forEach(function(hotkey) {
      return currentlyPressedKeys["delete"](hotkey.toLowerCase());
    });
  }
}
function maybePreventDefault(e3, hotkey, preventDefault3) {
  if (typeof preventDefault3 === "function" && preventDefault3(e3, hotkey) || preventDefault3 === true) {
    e3.preventDefault();
  }
}
function isHotkeyEnabled(e3, hotkey, enabled) {
  if (typeof enabled === "function") {
    return enabled(e3, hotkey);
  }
  return enabled === true || enabled === void 0;
}
function isKeyboardEventTriggeredByInput(ev) {
  return isHotkeyEnabledOnTag(ev, ["input", "textarea", "select"]);
}
function isHotkeyEnabledOnTag(event, enabledOnTags) {
  if (enabledOnTags === void 0) {
    enabledOnTags = false;
  }
  var target = event.target, composed = event.composed;
  var targetTagName = null;
  if (isCustomElement(target) && composed) {
    targetTagName = event.composedPath()[0] && event.composedPath()[0].tagName;
  } else {
    targetTagName = target && target.tagName;
  }
  if (isReadonlyArray(enabledOnTags)) {
    return Boolean(targetTagName && enabledOnTags && enabledOnTags.some(function(tag) {
      var _targetTagName;
      return tag.toLowerCase() === ((_targetTagName = targetTagName) == null ? void 0 : _targetTagName.toLowerCase());
    }));
  }
  return Boolean(targetTagName && enabledOnTags && enabledOnTags);
}
function isCustomElement(element) {
  return !!element.tagName && !element.tagName.startsWith("-") && element.tagName.includes("-");
}
function isScopeActive(activeScopes, scopes) {
  if (activeScopes.length === 0 && scopes) {
    console.warn('A hotkey has the "scopes" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>');
    return true;
  }
  if (!scopes) {
    return true;
  }
  return activeScopes.some(function(scope) {
    return scopes.includes(scope);
  }) || activeScopes.includes("*");
}
var isHotkeyMatchingKeyboardEvent = function isHotkeyMatchingKeyboardEvent2(e3, hotkey, ignoreModifiers) {
  if (ignoreModifiers === void 0) {
    ignoreModifiers = false;
  }
  var alt = hotkey.alt, meta = hotkey.meta, mod = hotkey.mod, shift = hotkey.shift, ctrl = hotkey.ctrl, keys = hotkey.keys;
  var pressedKeyUppercase = e3.key, code = e3.code, ctrlKey = e3.ctrlKey, metaKey = e3.metaKey, shiftKey = e3.shiftKey, altKey = e3.altKey;
  var keyCode = mapKey(code);
  var pressedKey = pressedKeyUppercase.toLowerCase();
  if (!(keys != null && keys.includes(keyCode)) && !(keys != null && keys.includes(pressedKey)) && !["ctrl", "control", "unknown", "meta", "alt", "shift", "os"].includes(keyCode)) {
    return false;
  }
  if (!ignoreModifiers) {
    if (alt === !altKey && pressedKey !== "alt") {
      return false;
    }
    if (shift === !shiftKey && pressedKey !== "shift") {
      return false;
    }
    if (mod) {
      if (!metaKey && !ctrlKey) {
        return false;
      }
    } else {
      if (meta === !metaKey && pressedKey !== "meta" && pressedKey !== "os") {
        return false;
      }
      if (ctrl === !ctrlKey && pressedKey !== "ctrl" && pressedKey !== "control") {
        return false;
      }
    }
  }
  if (keys && keys.length === 1 && (keys.includes(pressedKey) || keys.includes(keyCode))) {
    return true;
  } else if (keys) {
    return isHotkeyPressed(keys);
  } else if (!keys) {
    return true;
  }
  return false;
};
var BoundHotkeysProxyProvider = (0, import_react9.createContext)(void 0);
var useBoundHotkeysProxy = function useBoundHotkeysProxy2() {
  return (0, import_react9.useContext)(BoundHotkeysProxyProvider);
};
function deepEqual2(x, y2) {
  return x && y2 && typeof x === "object" && typeof y2 === "object" ? Object.keys(x).length === Object.keys(y2).length && //@ts-ignore
  Object.keys(x).reduce(function(isEqual, key) {
    return isEqual && deepEqual2(x[key], y2[key]);
  }, true) : x === y2;
}
var HotkeysContext = (0, import_react9.createContext)({
  hotkeys: [],
  enabledScopes: [],
  toggleScope: function toggleScope() {
  },
  enableScope: function enableScope() {
  },
  disableScope: function disableScope() {
  }
});
var useHotkeysContext = function useHotkeysContext2() {
  return (0, import_react9.useContext)(HotkeysContext);
};
function useDeepEqualMemo(value) {
  var ref = (0, import_react9.useRef)(void 0);
  if (!deepEqual2(ref.current, value)) {
    ref.current = value;
  }
  return ref.current;
}
var stopPropagation = function stopPropagation2(e3) {
  e3.stopPropagation();
  e3.preventDefault();
  e3.stopImmediatePropagation();
};
var useSafeLayoutEffect = typeof window !== "undefined" ? import_react9.useLayoutEffect : import_react9.useEffect;
function useHotkeys(keys, callback, options2, dependencies) {
  var _useState = (0, import_react9.useState)(null), ref = _useState[0], setRef = _useState[1];
  var hasTriggeredRef = (0, import_react9.useRef)(false);
  var _options = !(options2 instanceof Array) ? options2 : !(dependencies instanceof Array) ? dependencies : void 0;
  var _keys = isReadonlyArray(keys) ? keys.join(_options == null ? void 0 : _options.splitKey) : keys;
  var _deps = options2 instanceof Array ? options2 : dependencies instanceof Array ? dependencies : void 0;
  var memoisedCB = (0, import_react9.useCallback)(callback, _deps != null ? _deps : []);
  var cbRef = (0, import_react9.useRef)(memoisedCB);
  if (_deps) {
    cbRef.current = memoisedCB;
  } else {
    cbRef.current = callback;
  }
  var memoisedOptions = useDeepEqualMemo(_options);
  var _useHotkeysContext = useHotkeysContext(), enabledScopes = _useHotkeysContext.enabledScopes;
  var proxy = useBoundHotkeysProxy();
  useSafeLayoutEffect(function() {
    if ((memoisedOptions == null ? void 0 : memoisedOptions.enabled) === false || !isScopeActive(enabledScopes, memoisedOptions == null ? void 0 : memoisedOptions.scopes)) {
      return;
    }
    var listener = function listener2(e3, isKeyUp) {
      var _e$target;
      if (isKeyUp === void 0) {
        isKeyUp = false;
      }
      if (isKeyboardEventTriggeredByInput(e3) && !isHotkeyEnabledOnTag(e3, memoisedOptions == null ? void 0 : memoisedOptions.enableOnFormTags)) {
        return;
      }
      if (ref !== null) {
        var rootNode = ref.getRootNode();
        if ((rootNode instanceof Document || rootNode instanceof ShadowRoot) && rootNode.activeElement !== ref && !ref.contains(rootNode.activeElement)) {
          stopPropagation(e3);
          return;
        }
      }
      if ((_e$target = e3.target) != null && _e$target.isContentEditable && !(memoisedOptions != null && memoisedOptions.enableOnContentEditable)) {
        return;
      }
      parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {
        var _hotkey$keys;
        var hotkey = parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey);
        if (isHotkeyMatchingKeyboardEvent(e3, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.ignoreModifiers) || (_hotkey$keys = hotkey.keys) != null && _hotkey$keys.includes("*")) {
          if (memoisedOptions != null && memoisedOptions.ignoreEventWhen != null && memoisedOptions.ignoreEventWhen(e3)) {
            return;
          }
          if (isKeyUp && hasTriggeredRef.current) {
            return;
          }
          maybePreventDefault(e3, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.preventDefault);
          if (!isHotkeyEnabled(e3, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.enabled)) {
            stopPropagation(e3);
            return;
          }
          cbRef.current(e3, hotkey);
          if (!isKeyUp) {
            hasTriggeredRef.current = true;
          }
        }
      });
    };
    var handleKeyDown = function handleKeyDown2(event) {
      if (event.key === void 0) {
        return;
      }
      pushToCurrentlyPressedKeys(mapKey(event.code));
      if ((memoisedOptions == null ? void 0 : memoisedOptions.keydown) === void 0 && (memoisedOptions == null ? void 0 : memoisedOptions.keyup) !== true || memoisedOptions != null && memoisedOptions.keydown) {
        listener(event);
      }
    };
    var handleKeyUp = function handleKeyUp2(event) {
      if (event.key === void 0) {
        return;
      }
      removeFromCurrentlyPressedKeys(mapKey(event.code));
      hasTriggeredRef.current = false;
      if (memoisedOptions != null && memoisedOptions.keyup) {
        listener(event, true);
      }
    };
    var domNode = ref || (_options == null ? void 0 : _options.document) || document;
    domNode.addEventListener("keyup", handleKeyUp);
    domNode.addEventListener("keydown", handleKeyDown);
    if (proxy) {
      parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {
        return proxy.addHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey, memoisedOptions == null ? void 0 : memoisedOptions.description));
      });
    }
    return function() {
      domNode.removeEventListener("keyup", handleKeyUp);
      domNode.removeEventListener("keydown", handleKeyDown);
      if (proxy) {
        parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {
          return proxy.removeHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey, memoisedOptions == null ? void 0 : memoisedOptions.description));
        });
      }
    };
  }, [ref, _keys, memoisedOptions, enabledScopes]);
  return setRef;
}

// node_modules/@measured/puck/dist/index.mjs
var import_react54 = __toESM(require_react(), 1);
var import_react55 = __toESM(require_react(), 1);
var import_react56 = __toESM(require_react(), 1);
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react57 = __toESM(require_react(), 1);
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react58 = __toESM(require_react(), 1);
var import_react59 = __toESM(require_react(), 1);
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var require_classnames = __commonJS2({
  "../../node_modules/classnames/index.js"(exports, module) {
    "use strict";
    init_react_import();
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var overrideKeys = [
  "header",
  "headerActions",
  "fields",
  "fieldLabel",
  "components",
  "componentItem",
  "outline",
  "puck",
  "preview"
];
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var import_classnames = __toESM2(require_classnames());
var getClassNameFactory = (rootClass, styles2, config = { baseClass: "" }) => (options2 = {}) => {
  if (typeof options2 === "string") {
    const descendant = options2;
    const style = styles2[`${rootClass}-${descendant}`];
    if (style) {
      return config.baseClass + styles2[`${rootClass}-${descendant}`] || "";
    }
    return "";
  } else if (typeof options2 === "object") {
    const modifiers = options2;
    const prefixedModifiers = {};
    for (let modifier in modifiers) {
      prefixedModifiers[styles2[`${rootClass}--${modifier}`]] = modifiers[modifier];
    }
    const c3 = styles2[rootClass];
    return config.baseClass + (0, import_classnames.default)(__spreadValues({
      [c3]: !!c3
    }, prefixedModifiers));
  } else {
    return config.baseClass + styles2[rootClass] || "";
  }
};
var get_class_name_factory_default = getClassNameFactory;
init_react_import();
var styles_module_default = { "ActionBar": "_ActionBar_rvadt_1", "ActionBar-label": "_ActionBar-label_rvadt_18", "ActionBar-action": "_ActionBar-action_rvadt_30", "ActionBar-group": "_ActionBar-group_rvadt_38" };
var getClassName = get_class_name_factory_default("ActionBar", styles_module_default);
var ActionBar = ({
  label,
  children
}) => (0, import_jsx_runtime3.jsxs)(
  "div",
  {
    className: getClassName(),
    onClick: (e3) => {
      e3.stopPropagation();
    },
    children: [
      label && (0, import_jsx_runtime3.jsx)(ActionBar.Group, { children: (0, import_jsx_runtime3.jsx)("div", { className: getClassName("label"), children: label }) }),
      children
    ]
  }
);
var Action = ({
  children,
  label,
  onClick
}) => (0, import_jsx_runtime3.jsx)(
  "button",
  {
    type: "button",
    className: getClassName("action"),
    onClick,
    title: label,
    children
  }
);
var Group = ({ children }) => (0, import_jsx_runtime3.jsx)("div", { className: getClassName("group"), children });
var Label = ({ label }) => (0, import_jsx_runtime3.jsx)("div", { className: getClassName("label"), children: label });
ActionBar.Action = Action;
ActionBar.Label = Label;
ActionBar.Group = Group;
init_react_import();
init_react_import();
var styles_module_default2 = { "InputWrapper": "_InputWrapper_g5w3n_1", "Input-label": "_Input-label_g5w3n_5", "Input-labelIcon": "_Input-labelIcon_g5w3n_14", "Input-disabledIcon": "_Input-disabledIcon_g5w3n_21", "Input-input": "_Input-input_g5w3n_26", "Input": "_Input_g5w3n_1", "Input--readOnly": "_Input--readOnly_g5w3n_74", "Input-radioGroupItems": "_Input-radioGroupItems_g5w3n_85", "Input-radio": "_Input-radio_g5w3n_85", "Input-radioInner": "_Input-radioInner_g5w3n_102", "Input-radioInput": "_Input-radioInput_g5w3n_147" };
init_react_import();
init_react_import();
init_react_import();
var styles_module_default3 = { "ArrayField": "_ArrayField_14u8o_5", "ArrayField--isDraggingFrom": "_ArrayField--isDraggingFrom_14u8o_13", "ArrayField-addButton": "_ArrayField-addButton_14u8o_18", "ArrayField--hasItems": "_ArrayField--hasItems_14u8o_33", "ArrayField-inner": "_ArrayField-inner_14u8o_59", "ArrayFieldItem": "_ArrayFieldItem_14u8o_67", "ArrayFieldItem--isDragging": "_ArrayFieldItem--isDragging_14u8o_78", "ArrayFieldItem--isExpanded": "_ArrayFieldItem--isExpanded_14u8o_82", "ArrayFieldItem-summary": "_ArrayFieldItem-summary_14u8o_97", "ArrayField--addDisabled": "_ArrayField--addDisabled_14u8o_127", "ArrayFieldItem-body": "_ArrayFieldItem-body_14u8o_166", "ArrayFieldItem-fieldset": "_ArrayFieldItem-fieldset_14u8o_175", "ArrayFieldItem-rhs": "_ArrayFieldItem-rhs_14u8o_183", "ArrayFieldItem-actions": "_ArrayFieldItem-actions_14u8o_189" };
init_react_import();
init_react_import();
init_react_import();
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var mergeClasses = (...classes) => classes.filter((className, index, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
}).join(" ").trim();
init_react_import();
init_react_import();
var defaultAttributes2 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
var Icon = (0, import_react12.forwardRef)(
  (_a3, ref) => {
    var _b2 = _a3, {
      color = "currentColor",
      size = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode
    } = _b2, rest = __objRest(_b2, [
      "color",
      "size",
      "strokeWidth",
      "absoluteStrokeWidth",
      "className",
      "children",
      "iconNode"
    ]);
    return (0, import_react12.createElement)(
      "svg",
      __spreadValues(__spreadProps(__spreadValues({
        ref
      }, defaultAttributes2), {
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className)
      }), rest),
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react12.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
var createLucideIcon = (iconName, iconNode) => {
  const Component = (0, import_react11.forwardRef)(
    (_a3, ref) => {
      var _b2 = _a3, { className } = _b2, props = __objRest(_b2, ["className"]);
      return (0, import_react11.createElement)(Icon, __spreadValues({
        ref,
        iconNode,
        className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className)
      }, props));
    }
  );
  Component.displayName = `${iconName}`;
  return Component;
};
init_react_import();
var ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
init_react_import();
var ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
init_react_import();
var ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
init_react_import();
var CircleCheckBig = createLucideIcon("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
init_react_import();
var Copy = createLucideIcon("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
init_react_import();
var CornerLeftUp = createLucideIcon("CornerLeftUp", [
  ["polyline", { points: "14 9 9 4 4 9", key: "m9oyvo" }],
  ["path", { d: "M20 20h-7a4 4 0 0 1-4-4V4", key: "1blwi3" }]
]);
init_react_import();
var EllipsisVertical = createLucideIcon("EllipsisVertical", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
]);
init_react_import();
var Globe = createLucideIcon("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
init_react_import();
var Hash = createLucideIcon("Hash", [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
]);
init_react_import();
var Layers = createLucideIcon("Layers", [
  [
    "path",
    {
      d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
      key: "zw3jo"
    }
  ],
  [
    "path",
    {
      d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
      key: "1wduqc"
    }
  ],
  [
    "path",
    {
      d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
      key: "kqbvx6"
    }
  ]
]);
init_react_import();
var LayoutGrid = createLucideIcon("LayoutGrid", [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
]);
init_react_import();
var Link = createLucideIcon("Link", [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
]);
init_react_import();
var List = createLucideIcon("List", [
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M3 18h.01", key: "1tta3j" }],
  ["path", { d: "M3 6h.01", key: "1rqtza" }],
  ["path", { d: "M8 12h13", key: "1za7za" }],
  ["path", { d: "M8 18h13", key: "1lx6n3" }],
  ["path", { d: "M8 6h13", key: "ik3vkj" }]
]);
init_react_import();
var LockOpen = createLucideIcon("LockOpen", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 9.9-1", key: "1mm8w8" }]
]);
init_react_import();
var Lock = createLucideIcon("Lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
init_react_import();
var Monitor2 = createLucideIcon("Monitor", [
  ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2", key: "48i651" }],
  ["line", { x1: "8", x2: "16", y1: "21", y2: "21", key: "1svkeh" }],
  ["line", { x1: "12", x2: "12", y1: "17", y2: "21", key: "vw1qmm" }]
]);
init_react_import();
var PanelLeft = createLucideIcon("PanelLeft", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);
init_react_import();
var PanelRight = createLucideIcon("PanelRight", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }]
]);
init_react_import();
var Plus = createLucideIcon("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
init_react_import();
var Redo2 = createLucideIcon("Redo2", [
  ["path", { d: "m15 14 5-5-5-5", key: "12vg1m" }],
  ["path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13", key: "6uklza" }]
]);
init_react_import();
var Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
init_react_import();
var SlidersHorizontal = createLucideIcon("SlidersHorizontal", [
  ["line", { x1: "21", x2: "14", y1: "4", y2: "4", key: "obuewd" }],
  ["line", { x1: "10", x2: "3", y1: "4", y2: "4", key: "1q6298" }],
  ["line", { x1: "21", x2: "12", y1: "12", y2: "12", key: "1iu8h1" }],
  ["line", { x1: "8", x2: "3", y1: "12", y2: "12", key: "ntss68" }],
  ["line", { x1: "21", x2: "16", y1: "20", y2: "20", key: "14d8ph" }],
  ["line", { x1: "12", x2: "3", y1: "20", y2: "20", key: "m0wm8r" }],
  ["line", { x1: "14", x2: "14", y1: "2", y2: "6", key: "14e1ph" }],
  ["line", { x1: "8", x2: "8", y1: "10", y2: "14", key: "1i6ji0" }],
  ["line", { x1: "16", x2: "16", y1: "18", y2: "22", key: "1lctlv" }]
]);
init_react_import();
var Smartphone = createLucideIcon("Smartphone", [
  ["rect", { width: "14", height: "20", x: "5", y: "2", rx: "2", ry: "2", key: "1yt0o3" }],
  ["path", { d: "M12 18h.01", key: "mhygvu" }]
]);
init_react_import();
var Tablet = createLucideIcon("Tablet", [
  ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2", ry: "2", key: "76otgf" }],
  ["line", { x1: "12", x2: "12.01", y1: "18", y2: "18", key: "1dp563" }]
]);
init_react_import();
var Trash = createLucideIcon("Trash", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
init_react_import();
var Type = createLucideIcon("Type", [
  ["polyline", { points: "4 7 4 4 20 4 20 7", key: "1nosan" }],
  ["line", { x1: "9", x2: "15", y1: "20", y2: "20", key: "swin9y" }],
  ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]
]);
init_react_import();
var Undo2 = createLucideIcon("Undo2", [
  ["path", { d: "M9 14 4 9l5-5", key: "102s5s" }],
  ["path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11", key: "f3b9sd" }]
]);
init_react_import();
var ZoomIn = createLucideIcon("ZoomIn", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
init_react_import();
var ZoomOut = createLucideIcon("ZoomOut", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
init_react_import();
init_react_import();
init_react_import();
var IconButton_module_default = { "IconButton": "_IconButton_swpni_1", "IconButton--disabled": "_IconButton--disabled_swpni_20", "IconButton-title": "_IconButton-title_swpni_33" };
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var reorder2 = (list, startIndex, endIndex) => {
  const result = Array.from(list);
  const [removed] = result.splice(startIndex, 1);
  result.splice(endIndex, 0, removed);
  return result;
};
init_react_import();
var replace = (list, index, newItem) => {
  const result = Array.from(list);
  result.splice(index, 1);
  result.splice(index, 0, newItem);
  return result;
};
init_react_import();
var styles_module_default4 = { "Loader": "_Loader_nacdm_13", "loader-animation": "_loader-animation_nacdm_1" };
var getClassName2 = get_class_name_factory_default("Loader", styles_module_default4);
var Loader = (_a3) => {
  var _b2 = _a3, {
    color,
    size = 16
  } = _b2, props = __objRest(_b2, [
    "color",
    "size"
  ]);
  return (0, import_jsx_runtime4.jsx)(
    "span",
    __spreadValues({
      className: getClassName2(),
      style: {
        width: size,
        height: size,
        color
      },
      "aria-label": "loading"
    }, props)
  );
};
var getClassName3 = get_class_name_factory_default("IconButton", IconButton_module_default);
var IconButton = ({
  children,
  href,
  onClick,
  variant = "primary",
  type,
  disabled,
  tabIndex,
  newTab,
  fullWidth,
  title
}) => {
  const [loading, setLoading] = (0, import_react13.useState)(false);
  const ElementType = href ? "a" : "button";
  const el = (0, import_jsx_runtime5.jsxs)(
    ElementType,
    {
      className: getClassName3({
        primary: variant === "primary",
        secondary: variant === "secondary",
        disabled,
        fullWidth
      }),
      onClick: (e3) => {
        if (!onClick) return;
        setLoading(true);
        Promise.resolve(onClick(e3)).then(() => {
          setLoading(false);
        });
      },
      type,
      disabled: disabled || loading,
      tabIndex,
      target: newTab ? "_blank" : void 0,
      rel: newTab ? "noreferrer" : void 0,
      href,
      title,
      children: [
        (0, import_jsx_runtime5.jsx)("span", { className: getClassName3("title"), children: title }),
        children,
        loading && (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
          "  ",
          (0, import_jsx_runtime5.jsx)(Loader, { size: 14 })
        ] })
      ]
    }
  );
  return el;
};
init_react_import();
init_react_import();
var styles_module_default5 = { "DragIcon": "_DragIcon_17p8x_1", "DragIcon--disabled": "_DragIcon--disabled_17p8x_8" };
var getClassName4 = get_class_name_factory_default("DragIcon", styles_module_default5);
var DragIcon = ({ isDragDisabled }) => (0, import_jsx_runtime6.jsx)("div", { className: getClassName4({ disabled: isDragDisabled }), children: (0, import_jsx_runtime6.jsx)("svg", { viewBox: "0 0 20 20", width: "12", fill: "currentColor", children: (0, import_jsx_runtime6.jsx)("path", { d: "M7 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 2zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 14zm6-8a2 2 0 1 0-.001-4.001A2 2 0 0 0 13 6zm0 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 14z" }) }) });
init_react_import();
init_react_import();
function getItem(selector, data, dynamicProps = {}) {
  if (!selector.zone || selector.zone === rootDroppableId) {
    const item2 = data.content[selector.index];
    return (item2 == null ? void 0 : item2.props) ? __spreadProps(__spreadValues({}, item2), { props: dynamicProps[item2.props.id] || item2.props }) : void 0;
  }
  const item = setupZone(data, selector.zone).zones[selector.zone][selector.index];
  return (item == null ? void 0 : item.props) ? __spreadProps(__spreadValues({}, item), { props: dynamicProps[item.props.id] || item.props }) : void 0;
}
init_react_import();
var defaultViewports = [
  { width: 360, height: "auto", icon: "Smartphone", label: "Small" },
  { width: 768, height: "auto", icon: "Tablet", label: "Medium" },
  { width: 1280, height: "auto", icon: "Monitor", label: "Large" }
];
init_react_import();
init_react_import();
var flattenData = (data) => {
  return Object.keys(data.zones || {}).reduce(
    (acc, zone) => [...acc, ...data.zones[zone]],
    data.content
  );
};
var useResolvedPermissions = (config, appState, globalPermissions, setComponentLoading, unsetComponentLoading) => {
  const [cache3, setCache] = (0, import_react16.useState)({});
  const [resolvedPermissions, setResolvedPermissions] = (0, import_react16.useState)({});
  const resolveDataForItem = (0, import_react16.useCallback)(
    (item, force = false) => __async(void 0, null, function* () {
      var _a3, _b2, _c4;
      const componentConfig = item.type === "root" ? config.root : config.components[item.type];
      if (!componentConfig) {
        return;
      }
      const initialPermissions = __spreadValues(__spreadValues({}, globalPermissions), componentConfig.permissions);
      if (componentConfig.resolvePermissions) {
        const changed = getChanged(item, (_a3 = cache3[item.props.id]) == null ? void 0 : _a3.lastData);
        if (Object.values(changed).some((el) => el === true) || force) {
          setComponentLoading == null ? void 0 : setComponentLoading(item.props.id);
          const resolvedPermissions2 = yield componentConfig.resolvePermissions(
            item,
            {
              changed,
              lastPermissions: ((_b2 = cache3[item.props.id]) == null ? void 0 : _b2.lastPermissions) || null,
              permissions: initialPermissions,
              appState,
              lastData: ((_c4 = cache3[item.props.id]) == null ? void 0 : _c4.lastData) || null
            }
          );
          setCache((_cache) => __spreadProps(__spreadValues({}, _cache), {
            [item.props.id]: {
              lastData: item,
              lastPermissions: resolvedPermissions2
            }
          }));
          setResolvedPermissions((p2) => __spreadProps(__spreadValues({}, p2), {
            [item.props.id]: resolvedPermissions2
          }));
          unsetComponentLoading == null ? void 0 : unsetComponentLoading(item.props.id);
        }
      }
    }),
    [config, globalPermissions, appState, cache3]
  );
  const resolveDataForRoot = (force = false) => {
    resolveDataForItem(
      // Shim the root data in by conforming to component data shape
      {
        type: "root",
        props: __spreadProps(__spreadValues({}, appState.data.root.props), { id: "puck-root" })
      },
      force
    );
  };
  const resolvePermissions = (0, import_react16.useCallback)(
    (..._0) => __async(void 0, [..._0], function* ({ item, type, root } = {}, force = false) {
      if (item) {
        yield resolveDataForItem(item, force);
      } else if (type) {
        flattenData(appState.data).filter((item2) => item2.type === type).map((item2) => __async(void 0, null, function* () {
          yield resolveDataForItem(item2, force);
        }));
      } else if (root) {
        resolveDataForRoot(force);
      } else {
        resolveDataForRoot(force);
        flattenData(appState.data).map((item2) => __async(void 0, null, function* () {
          yield resolveDataForItem(item2, force);
        }));
      }
    }),
    [config, appState]
  );
  const refreshPermissions = (0, import_react16.useCallback)(
    (params) => __async(void 0, null, function* () {
      resolvePermissions(params, true);
    }),
    [config, appState]
  );
  (0, import_react16.useEffect)(() => {
    resolvePermissions();
  }, [config, appState.data]);
  const getPermissions = (0, import_react16.useCallback)(
    ({ item, type, root } = {}) => {
      if (item) {
        const componentConfig = config.components[item.type];
        const initialPermissions = __spreadValues(__spreadValues({}, globalPermissions), componentConfig == null ? void 0 : componentConfig.permissions);
        const resolvedForItem = resolvedPermissions[item.props.id];
        return resolvedForItem ? __spreadValues(__spreadValues({}, globalPermissions), resolvedForItem) : initialPermissions;
      } else if (type) {
        const componentConfig = config.components[type];
        return __spreadValues(__spreadValues({}, globalPermissions), componentConfig == null ? void 0 : componentConfig.permissions);
      } else if (root) {
        const rootConfig = config.root;
        const initialPermissions = __spreadValues(__spreadValues({}, globalPermissions), rootConfig == null ? void 0 : rootConfig.permissions);
        const resolvedForItem = resolvedPermissions["puck-root"];
        return resolvedForItem ? __spreadValues(__spreadValues({}, globalPermissions), resolvedForItem) : initialPermissions;
      }
      return globalPermissions;
    },
    [config, resolvedPermissions]
  );
  return {
    getPermissions,
    refreshPermissions
  };
};
init_react_import();
init_react_import();
var applyDynamicProps = (data, dynamicProps, rootData) => {
  return __spreadProps(__spreadValues({}, data), {
    root: __spreadValues(__spreadValues({}, data.root), rootData ? rootData : {}),
    content: data.content.map((item) => {
      return dynamicProps[item.props.id] ? __spreadValues(__spreadValues({}, item), dynamicProps[item.props.id]) : item;
    }),
    zones: Object.keys(data.zones || {}).reduce((acc, zoneKey) => {
      return __spreadProps(__spreadValues({}, acc), {
        [zoneKey]: data.zones[zoneKey].map((item) => {
          return dynamicProps[item.props.id] ? __spreadValues(__spreadValues({}, item), dynamicProps[item.props.id]) : item;
        })
      });
    }, {})
  });
};
var useResolvedData = (appState, config, dispatch, setComponentLoading, unsetComponentLoading, refreshPermissions) => {
  const [{ resolverKey, newAppState }, setResolverState] = (0, import_react17.useState)({
    resolverKey: 0,
    newAppState: appState
  });
  const deferredSetStates = {};
  const _setComponentLoading = (0, import_react17.useCallback)(
    (id, loading, defer2 = 0) => {
      if (deferredSetStates[id]) {
        clearTimeout(deferredSetStates[id]);
        delete deferredSetStates[id];
      }
      deferredSetStates[id] = setTimeout(() => {
        if (loading) {
          setComponentLoading(id);
        } else {
          unsetComponentLoading(id);
        }
        delete deferredSetStates[id];
      }, defer2);
    },
    []
  );
  const runResolvers = () => __async(void 0, null, function* () {
    const newData = newAppState.data;
    const flatContent = flattenData(newData).filter(
      (item) => {
        var _a3;
        return !!((_a3 = config.components[item.type]) == null ? void 0 : _a3.resolveData);
      }
    );
    const applyIfChange = (dynamicDataMap, dynamicRoot) => {
      const processed = applyDynamicProps(
        appState.data,
        dynamicDataMap,
        dynamicRoot
      );
      const processedAppState = __spreadProps(__spreadValues({}, appState), { data: processed });
      const containsChanges = JSON.stringify(appState) !== JSON.stringify(processedAppState);
      if (containsChanges) {
        dispatch({
          type: "set",
          state: (prev) => __spreadProps(__spreadValues({}, prev), {
            data: applyDynamicProps(prev.data, dynamicDataMap, dynamicRoot),
            ui: resolverKey > 0 ? __spreadValues(__spreadValues({}, prev.ui), newAppState.ui) : prev.ui
          }),
          recordHistory: resolverKey > 0
        });
      }
    };
    const promises = [];
    promises.push(
      (() => __async(void 0, null, function* () {
        _setComponentLoading("puck-root", true, 50);
        const dynamicRoot = yield resolveRootData(newData, config);
        applyIfChange({}, dynamicRoot);
        _setComponentLoading("puck-root", false);
      }))()
    );
    flatContent.forEach((item) => {
      promises.push(
        (() => __async(void 0, null, function* () {
          refreshPermissions({ item });
          const dynamicData = yield resolveComponentData(
            item,
            config,
            (item2) => {
              _setComponentLoading(item2.props.id, true, 50);
            },
            (item2) => {
              deferredSetStates[item2.props.id];
              _setComponentLoading(item2.props.id, false);
            }
          );
          const dynamicDataMap = { [item.props.id]: dynamicData };
          applyIfChange(dynamicDataMap);
        }))()
      );
    });
    yield Promise.all(promises);
  });
  (0, import_react17.useEffect)(() => {
    runResolvers();
  }, [resolverKey]);
  const resolveData = (0, import_react17.useCallback)((newAppState2 = appState) => {
    setResolverState((curr) => ({
      resolverKey: curr.resolverKey + 1,
      newAppState: newAppState2
    }));
  }, []);
  return {
    resolveData
  };
};
var defaultAppState = {
  data: { content: [], root: {} },
  ui: {
    leftSideBarVisible: true,
    rightSideBarVisible: true,
    arrayState: {},
    itemSelector: null,
    componentList: {},
    isDragging: false,
    previewMode: "edit",
    viewports: {
      current: {
        width: defaultViewports[0].width,
        height: defaultViewports[0].height || "auto"
      },
      options: [],
      controlsVisible: true
    },
    field: { focus: null }
  }
};
var defaultContext = {
  state: defaultAppState,
  dispatch: () => null,
  config: { components: {} },
  componentState: {},
  setComponentState: () => {
  },
  resolveData: () => {
  },
  plugins: [],
  overrides: {},
  history: {},
  viewports: defaultViewports,
  zoomConfig: {
    autoZoom: 1,
    rootHeight: 0,
    zoom: 1
  },
  setZoomConfig: () => null,
  status: "LOADING",
  setStatus: () => null,
  iframe: {},
  globalPermissions: {},
  getPermissions: () => ({}),
  refreshPermissions: () => null
};
var appContext = (0, import_react15.createContext)(defaultContext);
var AppProvider = ({
  children,
  value
}) => {
  const [zoomConfig, setZoomConfig] = (0, import_react15.useState)(defaultContext.zoomConfig);
  const [status, setStatus] = (0, import_react15.useState)("LOADING");
  (0, import_react15.useEffect)(() => {
    setStatus("MOUNTED");
  }, []);
  const selectedItem = value.state.ui.itemSelector ? getItem(value.state.ui.itemSelector, value.state.data) : void 0;
  const [componentState, setComponentState] = (0, import_react15.useState)({});
  const setComponentLoading = (id) => {
    setComponentState((prev) => {
      var _a3;
      return __spreadProps(__spreadValues({}, prev), {
        [id]: __spreadProps(__spreadValues({}, prev[id]), {
          loadingCount: (((_a3 = prev[id]) == null ? void 0 : _a3.loadingCount) || 0) + 1
        })
      });
    });
  };
  const unsetComponentLoading = (id) => {
    setComponentState((prev) => {
      var _a3;
      return __spreadProps(__spreadValues({}, prev), {
        [id]: __spreadProps(__spreadValues({}, prev[id]), {
          loadingCount: Math.max((((_a3 = prev[id]) == null ? void 0 : _a3.loadingCount) || 0) - 1, 0)
        })
      });
    });
  };
  const { getPermissions, refreshPermissions } = useResolvedPermissions(
    value.config,
    value.state,
    value.globalPermissions || {},
    setComponentLoading,
    unsetComponentLoading
  );
  const { resolveData } = useResolvedData(
    value.state,
    value.config,
    value.dispatch,
    setComponentLoading,
    unsetComponentLoading,
    refreshPermissions
  );
  return (0, import_jsx_runtime7.jsx)(
    appContext.Provider,
    {
      value: __spreadProps(__spreadValues({}, value), {
        selectedItem,
        zoomConfig,
        setZoomConfig,
        status,
        setStatus,
        getPermissions,
        refreshPermissions,
        componentState,
        setComponentState,
        resolveData
      }),
      children
    }
  );
};
function useAppContext() {
  const mainContext = (0, import_react15.useContext)(appContext);
  return __spreadProps(__spreadValues({}, mainContext), {
    // Helpers
    setUi: (ui, recordHistory) => {
      return mainContext.dispatch({
        type: "setUi",
        ui,
        recordHistory
      });
    }
  });
}
init_react_import();
init_react_import();
function useDroppableSafe(input) {
  if (typeof window === "undefined") {
    return { ref: () => {
    } };
  }
  return useDroppable(input);
}
function useDraggableSafe(input) {
  if (typeof window === "undefined") {
    return { ref: () => {
    } };
  }
  return useDraggable(input);
}
function useSortableSafe(input) {
  if (typeof window === "undefined") {
    return { ref: () => {
    }, status: "idle" };
  }
  return useSortable(input);
}
init_react_import();
init_react_import();
var _clearTimeout2;
var _PointerSensor3 = class _PointerSensor4 extends Sensor {
  constructor(manager, options2) {
    super(manager);
    this.manager = manager;
    this.options = options2;
    this.listeners = new Listeners();
    this.cleanup = /* @__PURE__ */ new Set();
    this.source = void 0;
    __privateAdd(this, _clearTimeout2);
    this.handleCancel = this.handleCancel.bind(this);
    this.handlePointerUp = this.handlePointerUp.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
    E(() => {
      const unbindGlobal = this.bindGlobal(options2 != null ? options2 : {});
      return () => {
        unbindGlobal();
      };
    });
  }
  bind(source, options2 = this.options) {
    const unbind = E(() => {
      var _a3;
      const target = (_a3 = source.handle) != null ? _a3 : source.element;
      const listener = (event) => {
        if (isPointerEvent(event)) {
          this.handlePointerDown(event, source, options2);
        }
      };
      if (target) {
        patchWindow2(target.ownerDocument.defaultView);
        target.addEventListener("pointerdown", listener);
        return () => {
          target.removeEventListener("pointerdown", listener);
        };
      }
    });
    return unbind;
  }
  bindGlobal(options2) {
    const documents = /* @__PURE__ */ new Set();
    for (const draggable of this.manager.registry.draggables.value) {
      if (draggable.element) {
        documents.add(getDocument(draggable.element));
      }
    }
    for (const droppable of this.manager.registry.droppables.value) {
      if (droppable.element) {
        documents.add(getDocument(droppable.element));
      }
    }
    const unbindFns = Array.from(documents).map(
      (doc) => this.listeners.bind(doc, [
        {
          type: "pointermove",
          listener: (event) => this.handlePointerMove(event, doc, options2)
        },
        {
          type: "pointerup",
          listener: this.handlePointerUp,
          options: {
            capture: true
          }
        },
        {
          // Cancel activation if there is a competing Drag and Drop interaction
          type: "dragstart",
          listener: this.handleDragStart
        }
      ])
    );
    return () => {
      unbindFns.forEach((unbind) => unbind());
    };
  }
  handlePointerDown(event, source, options2 = {}) {
    if (this.disabled || !event.isPrimary || event.button !== 0 || !isElement(event.target) || source.disabled) {
      return;
    }
    const offset = getFrameTransform(source.element);
    this.initialCoordinates = {
      x: event.clientX * offset.scaleX + offset.x,
      y: event.clientY * offset.scaleY + offset.y
    };
    this.source = source;
    const { activationConstraints } = options2;
    const constraints = typeof activationConstraints === "function" ? activationConstraints(event, source) : activationConstraints;
    event.stopImmediatePropagation();
    if (!(constraints == null ? void 0 : constraints.delay) && !(constraints == null ? void 0 : constraints.distance)) {
      this.handleStart(source, event);
    } else {
      const { delay } = constraints;
      if (delay) {
        const timeout3 = setTimeout(
          () => this.handleStart(source, event),
          delay.value
        );
        __privateSet(this, _clearTimeout2, () => {
          clearTimeout(timeout3);
          __privateSet(this, _clearTimeout2, void 0);
        });
      }
    }
    const cleanup = () => {
      var _a3;
      (_a3 = __privateGet(this, _clearTimeout2)) == null ? void 0 : _a3.call(this);
      this.initialCoordinates = void 0;
      this.source = void 0;
    };
    this.cleanup.add(cleanup);
  }
  handlePointerMove(event, doc, options2) {
    if (!this.source) {
      return;
    }
    const ownerDocument = this.source.element && getDocument(this.source.element);
    if (doc !== ownerDocument) {
      return;
    }
    const coordinates = {
      x: event.clientX,
      y: event.clientY
    };
    const offset = getFrameTransform(this.source.element);
    coordinates.x = coordinates.x * offset.scaleX + offset.x;
    coordinates.y = coordinates.y * offset.scaleY + offset.y;
    if (this.manager.dragOperation.status.dragging) {
      event.preventDefault();
      event.stopPropagation();
      this.manager.actions.move({ to: coordinates });
      return;
    }
    if (!this.initialCoordinates) {
      return;
    }
    const delta = {
      x: coordinates.x - this.initialCoordinates.x,
      y: coordinates.y - this.initialCoordinates.y
    };
    const { activationConstraints } = options2;
    const constraints = typeof activationConstraints === "function" ? activationConstraints(event, this.source) : activationConstraints;
    const { distance, delay } = constraints != null ? constraints : {};
    if (distance) {
      if (distance.tolerance != null && exceedsDistance(delta, distance.tolerance)) {
        return this.handleCancel();
      }
      if (exceedsDistance(delta, distance.value)) {
        return this.handleStart(this.source, event);
      }
    }
    if (delay) {
      if (exceedsDistance(delta, delay.tolerance)) {
        return this.handleCancel();
      }
    }
  }
  handlePointerUp(event) {
    if (!this.source) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    const { status } = this.manager.dragOperation;
    if (!status.idle) {
      const canceled = !status.initialized;
      this.manager.actions.stop({ canceled });
    }
    this.cleanup.forEach((cleanup) => cleanup());
    this.cleanup.clear();
  }
  handleKeyDown(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      this.handleCancel();
    }
  }
  handleStart(source, event) {
    var _a3;
    const { manager, initialCoordinates } = this;
    (_a3 = __privateGet(this, _clearTimeout2)) == null ? void 0 : _a3.call(this);
    if (!initialCoordinates || manager.dragOperation.status.initialized) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    event.preventDefault();
    r(() => {
      manager.actions.setDragSource(source.id);
      manager.actions.start({ coordinates: initialCoordinates, event });
    });
    const ownerDocument = getDocument(event.target);
    const unbind = this.listeners.bind(ownerDocument, [
      {
        // Prevent scrolling on touch devices
        type: "touchmove",
        listener: preventDefault2,
        options: {
          passive: false
        }
      },
      {
        // Prevent click events
        type: "click",
        listener: preventDefault2
      },
      {
        type: "keydown",
        listener: this.handleKeyDown
      }
    ]);
    ownerDocument.body.setPointerCapture(event.pointerId);
    this.cleanup.add(unbind);
  }
  handleDragStart(event) {
    const { target } = event;
    if (!isElement(target)) {
      return;
    }
    const isNativeDraggable = isHTMLElement(target) && target.draggable && target.getAttribute("draggable") === "true";
    if (isNativeDraggable) {
      this.handleCancel();
    } else {
      preventDefault2(event);
    }
  }
  handleCancel() {
    const { dragOperation } = this.manager;
    if (dragOperation.status.initialized) {
      this.manager.actions.stop({ canceled: true });
    }
    this.cleanup.forEach((cleanup) => cleanup());
    this.cleanup.clear();
  }
  destroy() {
    this.listeners.clear();
  }
};
_clearTimeout2 = /* @__PURE__ */ new WeakMap();
_PointerSensor3.configure = configurator(_PointerSensor3);
var PointerSensor2 = _PointerSensor3;
function preventDefault2(event) {
  event.preventDefault();
}
function noop2() {
}
var windows2 = /* @__PURE__ */ new WeakSet();
function patchWindow2(window2) {
  if (!window2 || windows2.has(window2)) {
    return;
  }
  window2.addEventListener("touchmove", noop2, {
    capture: false,
    passive: false
  });
  windows2.add(window2);
}
var useSensors = () => {
  const [sensors] = (0, import_react21.useState)(() => [
    PointerSensor2.configure({
      activationConstraints(event, source) {
        var _a3;
        const { pointerType, target } = event;
        if (pointerType === "mouse" && isElement(target) && (source.handle === target || ((_a3 = source.handle) == null ? void 0 : _a3.contains(target)))) {
          return void 0;
        }
        const delay = { value: 200, tolerance: 10 };
        if (pointerType === "touch") {
          return { delay };
        }
        return {
          delay,
          distance: { value: 5 }
        };
      }
    })
  ]);
  return sensors;
};
init_react_import();
init_react_import();
init_react_import();
var DEBUG = false;
var debugElements = {};
var timeout2;
var collisionDebug = (a2, b2, id, color, label) => {
  if (!DEBUG) return;
  const debugId = `${id}-debug`;
  clearTimeout(timeout2);
  timeout2 = setTimeout(() => {
    Object.entries(debugElements).forEach(([id2, { svg }]) => {
      svg.remove();
      delete debugElements[id2];
    });
  }, 1e3);
  requestAnimationFrame(() => {
    var _a3, _b2;
    const existingEl = debugElements[debugId];
    let line = (_a3 = debugElements[debugId]) == null ? void 0 : _a3.line;
    let text = (_b2 = debugElements[debugId]) == null ? void 0 : _b2.text;
    if (!existingEl) {
      const svgNs = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNs, "svg");
      line = document.createElementNS(svgNs, "line");
      text = document.createElementNS(svgNs, "text");
      svg.setAttribute("id", debugId);
      svg.setAttribute(
        "style",
        "position: fixed; height: 100%; width: 100%; pointer-events: none;"
      );
      svg.appendChild(line);
      svg.appendChild(text);
      text.setAttribute("fill", `black`);
      document.body.appendChild(svg);
      debugElements[debugId] = { svg, line, text };
    }
    line.setAttribute("x1", a2.x.toString());
    line.setAttribute("x2", b2.x.toString());
    line.setAttribute("y1", a2.y.toString());
    line.setAttribute("y2", b2.y.toString());
    line.setAttribute("style", `stroke:${color};stroke-width:2`);
    text.setAttribute("x", (a2.x - (a2.x - b2.x) / 2).toString());
    text.setAttribute("y", (a2.y - (a2.y - b2.y) / 2).toString());
    if (label) {
      text.innerHTML = label;
    }
  });
};
var distanceChange = "increasing";
var directionalCollision = (input, previous) => {
  var _a3;
  const { dragOperation, droppable } = input;
  const { shape: dropShape } = droppable;
  const { position } = dragOperation;
  const dragShape = (_a3 = dragOperation.shape) == null ? void 0 : _a3.current;
  if (!dragShape || !dropShape) return null;
  const dropCenter = dropShape.center;
  const distanceToPrevious = Math.sqrt(
    Math.pow(dropCenter.x - previous.x, 2) + Math.pow(dropCenter.y - previous.y, 2)
  );
  const distanceToCurrent = Math.sqrt(
    Math.pow(dropCenter.x - position.current.x, 2) + Math.pow(dropCenter.y - position.current.y, 2)
  );
  distanceChange = distanceToCurrent === distanceToPrevious ? distanceChange : distanceToCurrent < distanceToPrevious ? "decreasing" : "increasing";
  collisionDebug(
    dragShape.center,
    dropCenter,
    droppable.id.toString(),
    "rebeccapurple"
  );
  if (distanceChange === "decreasing") {
    return {
      id: droppable.id,
      value: 1,
      type: CollisionType.Collision
    };
  }
  return null;
};
init_react_import();
var getDirection3 = (dragAxis, delta) => {
  if (dragAxis === "dynamic") {
    if (Math.abs(delta.y) > Math.abs(delta.x)) {
      return delta.y === 0 ? null : delta.y > 0 ? "down" : "up";
    } else {
      return delta.x === 0 ? null : delta.x > 0 ? "right" : "left";
    }
  } else if (dragAxis === "x") {
    return delta.x === 0 ? null : delta.x > 0 ? "right" : "left";
  }
  return delta.y === 0 ? null : delta.y > 0 ? "down" : "up";
};
init_react_import();
var getMidpointImpact = (dragShape, dropShape, direction, offsetMultiplier = 0) => {
  const dragRect = dragShape.boundingRectangle;
  const dropCenter = dropShape.center;
  if (direction === "down") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.height;
    return dragRect.bottom >= dropCenter.y + offset2;
  } else if (direction === "up") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.height;
    return dragRect.top < dropCenter.y - offset2;
  } else if (direction === "left") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.width;
    return dropCenter.x - offset2 >= dragRect.left;
  }
  const offset = offsetMultiplier * dropShape.boundingRectangle.width;
  return dragRect.right - offset >= dropCenter.x;
};
init_react_import();
var INTERVAL_SENSITIVITY = 10;
var intervalCache = {
  current: { x: 0, y: 0 },
  delta: { x: 0, y: 0 },
  previous: { x: 0, y: 0 },
  direction: null
};
var trackMovementInterval = (point, dragAxis = "dynamic") => {
  intervalCache.current = point;
  intervalCache.delta = {
    x: point.x - intervalCache.previous.x,
    y: point.y - intervalCache.previous.y
  };
  intervalCache.direction = getDirection3(dragAxis, intervalCache.delta) || intervalCache.direction;
  if (Math.abs(intervalCache.delta.x) > INTERVAL_SENSITIVITY || Math.abs(intervalCache.delta.y) > INTERVAL_SENSITIVITY) {
    intervalCache.previous = Point.from(point);
  }
  return intervalCache;
};
init_react_import();
var pointerIntersection2 = ({
  dragOperation,
  droppable
}) => {
  const pointerCoordinates = dragOperation.position.current;
  if (!pointerCoordinates) {
    return null;
  }
  const { id } = droppable;
  if (!droppable.shape) {
    return null;
  }
  if (droppable.shape.containsPoint(pointerCoordinates)) {
    const distance = Point.distance(droppable.shape.center, pointerCoordinates);
    return {
      id,
      value: 1 / distance,
      type: CollisionType.PointerIntersection,
      priority: CollisionPriority.High
    };
  }
  return null;
};
var closestCorners2 = (input) => {
  const { dragOperation, droppable } = input;
  const { shape, position } = dragOperation;
  if (!droppable.shape) {
    return null;
  }
  const { left, top, right, bottom } = droppable.shape.boundingRectangle;
  const corners = [
    {
      x: left,
      y: top
    },
    {
      x: right,
      y: top
    },
    {
      x: left,
      y: bottom
    },
    {
      x: right,
      y: bottom
    }
  ];
  const distance = corners.reduce(
    (acc, corner) => {
      var _a3;
      return acc + Point.distance(
        Point.from(corner),
        (_a3 = shape == null ? void 0 : shape.current.center) != null ? _a3 : position.current
      );
    },
    0
  );
  const value = distance / 4;
  return {
    id: droppable.id,
    value: 1 / value,
    type: CollisionType.Collision,
    priority: CollisionPriority.Normal
  };
};
init_react_import();
var collisionStore = createStore(() => ({
  fallbackEnabled: false
}));
var flushNext = "";
var createDynamicCollisionDetector = (dragAxis, midpointOffset = 0.05) => (input) => {
  var _a3, _b2, _c4, _d2, _e;
  const { dragOperation, droppable } = input;
  const { position } = dragOperation;
  const dragShape = (_a3 = dragOperation.shape) == null ? void 0 : _a3.current;
  const { shape: dropShape } = droppable;
  if (!dragShape || !dropShape) {
    return null;
  }
  const { center: dragCenter } = dragShape;
  const { fallbackEnabled } = collisionStore.getState();
  const interval = trackMovementInterval(position.current, dragAxis);
  dragOperation.data = __spreadProps(__spreadValues({}, dragOperation.data), {
    direction: interval.direction
  });
  const collisionMap = dragOperation.data.collisionMap || {};
  dragOperation.data.collisionMap = collisionMap;
  collisionMap[droppable.id] = {
    direction: interval.direction
  };
  const { center: dropCenter } = dropShape;
  const overMidpoint = getMidpointImpact(
    dragShape,
    dropShape,
    interval.direction,
    midpointOffset
  );
  if (((_b2 = dragOperation.source) == null ? void 0 : _b2.id) === droppable.id) {
    const collision = directionalCollision(input, interval.previous);
    collisionDebug(dragCenter, dropCenter, droppable.id.toString(), "yellow");
    if (collision) {
      return __spreadProps(__spreadValues({}, collision), {
        priority: CollisionPriority.Highest
      });
    }
  }
  const intersectionArea = dragShape.intersectionArea(dropShape);
  const intersectionRatio = intersectionArea / dropShape.area;
  if (intersectionArea && overMidpoint) {
    collisionDebug(
      dragCenter,
      dropCenter,
      droppable.id.toString(),
      "green",
      interval.direction
    );
    const collision = {
      id: droppable.id,
      value: intersectionRatio,
      priority: CollisionPriority.High,
      type: CollisionType.Collision
    };
    const shouldFlushId = flushNext === droppable.id;
    flushNext = "";
    return __spreadProps(__spreadValues({}, collision), { id: shouldFlushId ? "flush" : collision.id });
  }
  if (fallbackEnabled && ((_c4 = dragOperation.source) == null ? void 0 : _c4.id) !== droppable.id) {
    const xAxisIntersection = dropShape.boundingRectangle.right > dragShape.boundingRectangle.left && dropShape.boundingRectangle.left < dragShape.boundingRectangle.right;
    const yAxisIntersection = dropShape.boundingRectangle.bottom > dragShape.boundingRectangle.top && dropShape.boundingRectangle.top < dragShape.boundingRectangle.bottom;
    if (dragAxis === "y" && xAxisIntersection || yAxisIntersection) {
      const fallbackCollision = closestCorners2(input);
      if (fallbackCollision) {
        const direction = getDirection3(dragAxis, {
          x: dragShape.center.x - (((_d2 = droppable.shape) == null ? void 0 : _d2.center.x) || 0),
          y: dragShape.center.y - (((_e = droppable.shape) == null ? void 0 : _e.center.y) || 0)
        });
        collisionMap[droppable.id] = {
          direction
        };
        if (intersectionArea) {
          collisionDebug(
            dragCenter,
            dropCenter,
            droppable.id.toString(),
            "red",
            direction || ""
          );
          flushNext = droppable.id;
          return __spreadProps(__spreadValues({}, fallbackCollision), {
            priority: CollisionPriority.Low
          });
        }
        collisionDebug(
          dragCenter,
          dropCenter,
          droppable.id.toString(),
          "orange",
          direction || ""
        );
        return __spreadProps(__spreadValues({}, fallbackCollision), { priority: CollisionPriority.Lowest });
      }
    }
  }
  collisionDebug(dragCenter, dropCenter, droppable.id.toString(), "hotpink");
  delete collisionMap[droppable.id];
  return null;
};
var SortableProvider = ({
  children,
  onDragStart,
  onDragEnd,
  onMove
}) => {
  const [move2, setMove] = (0, import_react19.useState)({ source: -1, target: -1 });
  const sensors = useSensors();
  return (0, import_jsx_runtime8.jsx)(
    DragDropProvider,
    {
      sensors,
      modifiers: [
        RestrictToElement.configure({
          element() {
            return document.querySelector("[data-dnd-container]");
          }
        })
      ],
      onDragStart,
      onDragOver: (event, manager) => {
        var _a3, _b2;
        const { operation } = event;
        const { source, target } = operation;
        if (!source || !target) return;
        let sourceIndex = source.data.index;
        let targetIndex = target.data.index;
        const collisionData = (_b2 = (_a3 = manager.dragOperation.data) == null ? void 0 : _a3.collisionMap) == null ? void 0 : _b2[target.id];
        if (sourceIndex !== targetIndex && source.id !== target.id) {
          const collisionPosition = (collisionData == null ? void 0 : collisionData.direction) === "up" ? "before" : "after";
          if (targetIndex >= sourceIndex) {
            targetIndex = targetIndex - 1;
          }
          if (collisionPosition === "after") {
            targetIndex = targetIndex + 1;
          }
          setMove({
            source: sourceIndex,
            target: targetIndex
          });
        }
      },
      onDragEnd: () => {
        setTimeout(() => {
          if (move2.source !== -1 && move2.target !== -1) {
            onMove(move2);
          }
          onDragEnd();
        }, 250);
        setMove({ source: -1, target: -1 });
      },
      children
    }
  );
};
var Sortable = ({
  id,
  index,
  disabled,
  children,
  type = "item"
}) => {
  const { ref: sortableRef, status } = useSortableSafe({
    id,
    type,
    index,
    disabled,
    data: { index },
    collisionDetector: createDynamicCollisionDetector("y")
  });
  return children({ status, ref: sortableRef });
};
init_react_import();
var NestedFieldContext = (0, import_react22.createContext)({});
var useNestedFieldContext = () => {
  const context = (0, import_react22.useContext)(NestedFieldContext);
  return __spreadProps(__spreadValues({}, context), {
    readOnlyFields: context.readOnlyFields || {}
  });
};
var NestedFieldProvider = ({
  children,
  name,
  subName,
  wildcardName = name,
  readOnlyFields
}) => {
  const subPath = `${name}.${subName}`;
  const wildcardSubPath = `${wildcardName}.${subName}`;
  const subReadOnlyFields = (0, import_react22.useMemo)(
    () => Object.keys(readOnlyFields).reduce((acc, readOnlyKey) => {
      const isLocal = readOnlyKey.indexOf(subPath) > -1 || readOnlyKey.indexOf(wildcardSubPath) > -1;
      if (isLocal) {
        const subPathPattern = new RegExp(
          `^(${name}|${wildcardName}).`.replace(/\[/g, "\\[").replace(/\]/g, "\\]").replace(/\./g, "\\.").replace(/\*/g, "\\*")
        );
        const localName = readOnlyKey.replace(subPathPattern, "");
        return __spreadProps(__spreadValues({}, acc), {
          [localName]: readOnlyFields[readOnlyKey]
        });
      }
      return acc;
    }, {}),
    [name, subName, wildcardName, readOnlyFields]
  );
  return (0, import_jsx_runtime9.jsx)(
    NestedFieldContext.Provider,
    {
      value: { readOnlyFields: subReadOnlyFields, localName: subName },
      children
    }
  );
};
var getClassName5 = get_class_name_factory_default("ArrayField", styles_module_default3);
var getClassNameItem = get_class_name_factory_default("ArrayFieldItem", styles_module_default3);
var ArrayField = ({
  field,
  onChange,
  value: _value,
  name,
  label,
  readOnly,
  id,
  Label: Label2 = (props) => (0, import_jsx_runtime10.jsx)("div", __spreadValues({}, props))
}) => {
  const { state, setUi, selectedItem, getPermissions } = useAppContext();
  const { readOnlyFields, localName = name } = useNestedFieldContext();
  const value = _value;
  const arrayState = state.ui.arrayState[id] || {
    items: Array.from(value || []).map((item, idx) => {
      return {
        _originalIndex: idx,
        _arrayId: `${id}-${idx}`
      };
    }),
    openId: ""
  };
  const [localState, setLocalState] = (0, import_react14.useState)({ arrayState, value });
  (0, import_react14.useEffect)(() => {
    setLocalState({ arrayState, value });
  }, [value, state.ui.arrayState[id]]);
  const mapArrayStateToUi = (0, import_react14.useCallback)(
    (partialArrayState) => {
      return {
        arrayState: __spreadProps(__spreadValues({}, state.ui.arrayState), {
          [id]: __spreadValues(__spreadValues({}, arrayState), partialArrayState)
        })
      };
    },
    [arrayState]
  );
  const getHighestIndex = (0, import_react14.useCallback)(() => {
    return arrayState.items.reduce(
      (acc, item) => item._originalIndex > acc ? item._originalIndex : acc,
      -1
    );
  }, [arrayState]);
  const regenerateArrayState = (0, import_react14.useCallback)(
    (value2) => {
      let highestIndex = getHighestIndex();
      const newItems = Array.from(value2 || []).map((item, idx) => {
        var _a3;
        const arrayStateItem = arrayState.items[idx];
        const newItem = {
          _originalIndex: typeof (arrayStateItem == null ? void 0 : arrayStateItem._originalIndex) !== "undefined" ? arrayStateItem._originalIndex : highestIndex + 1,
          _arrayId: ((_a3 = arrayState.items[idx]) == null ? void 0 : _a3._arrayId) || `${id}-${highestIndex + 1}`
        };
        if (newItem._originalIndex > highestIndex) {
          highestIndex = newItem._originalIndex;
        }
        return newItem;
      });
      return __spreadProps(__spreadValues({}, arrayState), { items: newItems });
    },
    [arrayState]
  );
  (0, import_react14.useEffect)(() => {
    if (arrayState.items.length > 0) {
      setUi(mapArrayStateToUi(arrayState));
    }
  }, []);
  const [isDragging, setIsDragging] = (0, import_react14.useState)(false);
  const forceReadOnly = getPermissions({ item: selectedItem }).edit === false;
  if (field.type !== "array" || !field.arrayFields) {
    return null;
  }
  const addDisabled = field.max !== void 0 && localState.arrayState.items.length >= field.max || readOnly;
  return (0, import_jsx_runtime10.jsx)(
    Label2,
    {
      label: label || name,
      icon: (0, import_jsx_runtime10.jsx)(List, { size: 16 }),
      el: "div",
      readOnly,
      children: (0, import_jsx_runtime10.jsx)(
        SortableProvider,
        {
          onDragStart: () => setIsDragging(true),
          onDragEnd: () => setIsDragging(false),
          onMove: (move2) => {
            const newValue = reorder2(value, move2.source, move2.target);
            const newArrayStateItems = reorder2(
              arrayState.items,
              move2.source,
              move2.target
            );
            const newUi = {
              arrayState: __spreadProps(__spreadValues({}, state.ui.arrayState), {
                [id]: __spreadProps(__spreadValues({}, arrayState), { items: newArrayStateItems })
              })
            };
            setUi(newUi, false);
            onChange(newValue, newUi);
            setLocalState({
              value: newValue,
              arrayState: __spreadProps(__spreadValues({}, arrayState), { items: newArrayStateItems })
            });
          },
          children: (0, import_jsx_runtime10.jsxs)(
            "div",
            {
              className: getClassName5({
                hasItems: Array.isArray(value) && value.length > 0,
                addDisabled
              }),
              onClick: (e3) => {
                e3.preventDefault();
              },
              children: [
                (0, import_jsx_runtime10.jsx)("div", { className: getClassName5("inner"), "data-dnd-container": true, children: localState.arrayState.items.map((item, i2) => {
                  const { _arrayId = `${id}-${i2}`, _originalIndex = i2 } = item;
                  const data = Array.from(localState.value || [])[i2] || {};
                  return (0, import_jsx_runtime10.jsx)(
                    Sortable,
                    {
                      id: _arrayId,
                      index: i2,
                      disabled: readOnly,
                      children: ({ status, ref }) => (0, import_jsx_runtime10.jsxs)(
                        "div",
                        {
                          ref,
                          className: getClassNameItem({
                            isExpanded: arrayState.openId === _arrayId,
                            isDragging: status === "dragging",
                            readOnly
                          }),
                          children: [
                            (0, import_jsx_runtime10.jsxs)(
                              "div",
                              {
                                onClick: (e3) => {
                                  if (isDragging) return;
                                  e3.preventDefault();
                                  e3.stopPropagation();
                                  if (arrayState.openId === _arrayId) {
                                    setUi(
                                      mapArrayStateToUi({
                                        openId: ""
                                      })
                                    );
                                  } else {
                                    setUi(
                                      mapArrayStateToUi({
                                        openId: _arrayId
                                      })
                                    );
                                  }
                                },
                                className: getClassNameItem("summary"),
                                children: [
                                  field.getItemSummary ? field.getItemSummary(data, i2) : `Item #${_originalIndex}`,
                                  (0, import_jsx_runtime10.jsxs)("div", { className: getClassNameItem("rhs"), children: [
                                    !readOnly && (0, import_jsx_runtime10.jsxs)("div", { className: getClassNameItem("actions"), children: [
                                      (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("action"), children: (0, import_jsx_runtime10.jsx)(
                                        IconButton,
                                        {
                                          type: "button",
                                          disabled: !!addDisabled,
                                          onClick: (e3) => {
                                            e3.stopPropagation();
                                            const existingValue = [...value || []];
                                            existingValue.splice(
                                              i2,
                                              0,
                                              existingValue[i2]
                                            );
                                            onChange(
                                              existingValue,
                                              mapArrayStateToUi(
                                                regenerateArrayState(existingValue)
                                              )
                                            );
                                          },
                                          title: "Duplicate",
                                          children: (0, import_jsx_runtime10.jsx)(Copy, { size: 16 })
                                        }
                                      ) }),
                                      (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("action"), children: (0, import_jsx_runtime10.jsx)(
                                        IconButton,
                                        {
                                          type: "button",
                                          disabled: field.min !== void 0 && field.min >= localState.arrayState.items.length,
                                          onClick: (e3) => {
                                            e3.stopPropagation();
                                            const existingValue = [...value || []];
                                            const existingItems = [
                                              ...arrayState.items || []
                                            ];
                                            existingValue.splice(i2, 1);
                                            existingItems.splice(i2, 1);
                                            onChange(
                                              existingValue,
                                              mapArrayStateToUi({
                                                items: existingItems
                                              })
                                            );
                                          },
                                          title: "Delete",
                                          children: (0, import_jsx_runtime10.jsx)(Trash, { size: 16 })
                                        }
                                      ) })
                                    ] }),
                                    (0, import_jsx_runtime10.jsx)("div", { children: (0, import_jsx_runtime10.jsx)(DragIcon, {}) })
                                  ] })
                                ]
                              }
                            ),
                            (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("body"), children: (0, import_jsx_runtime10.jsx)(
                              "fieldset",
                              {
                                className: getClassNameItem("fieldset"),
                                onPointerDownCapture: (e3) => {
                                  e3.stopPropagation();
                                },
                                children: Object.keys(field.arrayFields).map((subName) => {
                                  const subField = field.arrayFields[subName];
                                  const indexName = `${name}[${i2}]`;
                                  const subPath = `${indexName}.${subName}`;
                                  const localIndexName = `${localName}[${i2}]`;
                                  const localWildcardName = `${localName}[*]`;
                                  const localSubPath = `${localIndexName}.${subName}`;
                                  const localWildcardSubPath = `${localWildcardName}.${subName}`;
                                  const subReadOnly = forceReadOnly ? forceReadOnly : typeof readOnlyFields[subPath] !== "undefined" ? readOnlyFields[localSubPath] : readOnlyFields[localWildcardSubPath];
                                  const label2 = subField.label || subName;
                                  return (0, import_jsx_runtime10.jsx)(
                                    NestedFieldProvider,
                                    {
                                      name: localIndexName,
                                      wildcardName: localWildcardName,
                                      subName,
                                      readOnlyFields,
                                      children: (0, import_jsx_runtime10.jsx)(
                                        AutoFieldPrivate,
                                        {
                                          name: subPath,
                                          label: label2,
                                          id: `${_arrayId}_${subName}`,
                                          readOnly: subReadOnly,
                                          field: __spreadProps(__spreadValues({}, subField), {
                                            label: label2
                                            // May be used by custom fields
                                          }),
                                          value: data[subName],
                                          onChange: (val, ui) => {
                                            onChange(
                                              replace(value, i2, __spreadProps(__spreadValues({}, data), {
                                                [subName]: val
                                              })),
                                              ui
                                            );
                                          }
                                        }
                                      )
                                    },
                                    subPath
                                  );
                                })
                              }
                            ) })
                          ]
                        }
                      )
                    },
                    _arrayId
                  );
                }) }),
                !addDisabled && (0, import_jsx_runtime10.jsx)(
                  "button",
                  {
                    type: "button",
                    className: getClassName5("addButton"),
                    onClick: () => {
                      if (isDragging) return;
                      const existingValue = value || [];
                      const newValue = [
                        ...existingValue,
                        field.defaultItemProps || {}
                      ];
                      const newArrayState = regenerateArrayState(newValue);
                      onChange(newValue, mapArrayStateToUi(newArrayState));
                    },
                    children: (0, import_jsx_runtime10.jsx)(Plus, { size: 21 })
                  }
                )
              ]
            }
          )
        }
      )
    }
  );
};
init_react_import();
var getClassName6 = get_class_name_factory_default("Input", styles_module_default2);
var DefaultField = ({
  field,
  onChange,
  readOnly,
  value: _value,
  name,
  label,
  Label: Label2,
  id
}) => {
  const value = _value;
  return (0, import_jsx_runtime11.jsx)(
    Label2,
    {
      label: label || name,
      icon: (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
        field.type === "text" && (0, import_jsx_runtime11.jsx)(Type, { size: 16 }),
        field.type === "number" && (0, import_jsx_runtime11.jsx)(Hash, { size: 16 })
      ] }),
      readOnly,
      children: (0, import_jsx_runtime11.jsx)(
        "input",
        {
          className: getClassName6("input"),
          autoComplete: "off",
          type: field.type,
          title: label || name,
          name,
          value: (value == null ? void 0 : value.toString) ? value.toString() : "",
          onChange: (e3) => {
            if (field.type === "number") {
              const numberValue = Number(e3.currentTarget.value);
              if (typeof field.min !== "undefined" && numberValue < field.min) {
                return;
              }
              if (typeof field.max !== "undefined" && numberValue > field.max) {
                return;
              }
              onChange(numberValue);
            } else {
              onChange(e3.currentTarget.value);
            }
          },
          readOnly,
          tabIndex: readOnly ? -1 : void 0,
          id,
          min: field.type === "number" ? field.min : void 0,
          max: field.type === "number" ? field.max : void 0
        }
      )
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default6 = { "ExternalInput-actions": "_ExternalInput-actions_91ls0_1", "ExternalInput-button": "_ExternalInput-button_91ls0_5", "ExternalInput--dataSelected": "_ExternalInput--dataSelected_91ls0_24", "ExternalInput--readOnly": "_ExternalInput--readOnly_91ls0_31", "ExternalInput-detachButton": "_ExternalInput-detachButton_91ls0_35", "ExternalInput": "_ExternalInput_91ls0_1", "ExternalInputModal": "_ExternalInputModal_91ls0_79", "ExternalInputModal-grid": "_ExternalInputModal-grid_91ls0_89", "ExternalInputModal--filtersToggled": "_ExternalInputModal--filtersToggled_91ls0_100", "ExternalInputModal-filters": "_ExternalInputModal-filters_91ls0_105", "ExternalInputModal-masthead": "_ExternalInputModal-masthead_91ls0_124", "ExternalInputModal-tableWrapper": "_ExternalInputModal-tableWrapper_91ls0_133", "ExternalInputModal-table": "_ExternalInputModal-table_91ls0_133", "ExternalInputModal-thead": "_ExternalInputModal-thead_91ls0_149", "ExternalInputModal-th": "_ExternalInputModal-th_91ls0_149", "ExternalInputModal-td": "_ExternalInputModal-td_91ls0_164", "ExternalInputModal-tr": "_ExternalInputModal-tr_91ls0_169", "ExternalInputModal-tbody": "_ExternalInputModal-tbody_91ls0_176", "ExternalInputModal--hasData": "_ExternalInputModal--hasData_91ls0_202", "ExternalInputModal-loadingBanner": "_ExternalInputModal-loadingBanner_91ls0_206", "ExternalInputModal--isLoading": "_ExternalInputModal--isLoading_91ls0_223", "ExternalInputModal-searchForm": "_ExternalInputModal-searchForm_91ls0_227", "ExternalInputModal-search": "_ExternalInputModal-search_91ls0_227", "ExternalInputModal-searchIcon": "_ExternalInputModal-searchIcon_91ls0_264", "ExternalInputModal-searchIconText": "_ExternalInputModal-searchIconText_91ls0_289", "ExternalInputModal-searchInput": "_ExternalInputModal-searchInput_91ls0_299", "ExternalInputModal-searchActions": "_ExternalInputModal-searchActions_91ls0_313", "ExternalInputModal-searchActionIcon": "_ExternalInputModal-searchActionIcon_91ls0_326", "ExternalInputModal-footerContainer": "_ExternalInputModal-footerContainer_91ls0_330", "ExternalInputModal-footer": "_ExternalInputModal-footer_91ls0_330", "ExternalInputModal-field": "_ExternalInputModal-field_91ls0_343" };
init_react_import();
init_react_import();
var styles_module_default7 = { "Modal": "_Modal_ikbaj_1", "Modal--isOpen": "_Modal--isOpen_ikbaj_15", "Modal-inner": "_Modal-inner_ikbaj_19" };
var getClassName7 = get_class_name_factory_default("Modal", styles_module_default7);
var Modal = ({
  children,
  onClose,
  isOpen
}) => {
  const [rootEl, setRootEl] = (0, import_react25.useState)(null);
  (0, import_react25.useEffect)(() => {
    setRootEl(document.getElementById("puck-portal-root"));
  }, []);
  if (!rootEl) {
    return (0, import_jsx_runtime12.jsx)("div", {});
  }
  return (0, import_react_dom2.createPortal)(
    (0, import_jsx_runtime12.jsx)("div", { className: getClassName7({ isOpen }), onClick: onClose, children: (0, import_jsx_runtime12.jsx)(
      "div",
      {
        className: getClassName7("inner"),
        onClick: (e3) => e3.stopPropagation(),
        children
      }
    ) }),
    rootEl
  );
};
init_react_import();
init_react_import();
var styles_module_default8 = { "Heading": "_Heading_qxrry_1", "Heading--xxxxl": "_Heading--xxxxl_qxrry_12", "Heading--xxxl": "_Heading--xxxl_qxrry_18", "Heading--xxl": "_Heading--xxl_qxrry_22", "Heading--xl": "_Heading--xl_qxrry_26", "Heading--l": "_Heading--l_qxrry_30", "Heading--m": "_Heading--m_qxrry_34", "Heading--s": "_Heading--s_qxrry_38", "Heading--xs": "_Heading--xs_qxrry_42" };
var getClassName8 = get_class_name_factory_default("Heading", styles_module_default8);
var Heading = ({ children, rank, size = "m" }) => {
  const Tag = rank ? `h${rank}` : "span";
  return (0, import_jsx_runtime13.jsx)(
    Tag,
    {
      className: getClassName8({
        [size]: true
      }),
      children
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var Button_module_default = { "Button": "_Button_10byl_1", "Button--medium": "_Button--medium_10byl_29", "Button--large": "_Button--large_10byl_37", "Button-icon": "_Button-icon_10byl_44", "Button--primary": "_Button--primary_10byl_48", "Button--secondary": "_Button--secondary_10byl_67", "Button--flush": "_Button--flush_10byl_84", "Button--disabled": "_Button--disabled_10byl_88", "Button--fullWidth": "_Button--fullWidth_10byl_95", "Button-spinner": "_Button-spinner_10byl_100" };
init_react_import();
var dataAttrRe = /^(data-.*)$/;
var filterDataAttrs = (props) => {
  let filteredProps = {};
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && dataAttrRe.test(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
};
var getClassName9 = get_class_name_factory_default("Button", Button_module_default);
var Button = (_a3) => {
  var _b2 = _a3, {
    children,
    href,
    onClick,
    variant = "primary",
    type,
    disabled,
    tabIndex,
    newTab,
    fullWidth,
    icon,
    size = "medium",
    loading: loadingProp = false
  } = _b2, props = __objRest(_b2, [
    "children",
    "href",
    "onClick",
    "variant",
    "type",
    "disabled",
    "tabIndex",
    "newTab",
    "fullWidth",
    "icon",
    "size",
    "loading"
  ]);
  const [loading, setLoading] = (0, import_react26.useState)(loadingProp);
  (0, import_react26.useEffect)(() => setLoading(loadingProp), [loadingProp]);
  const ElementType = href ? "a" : type ? "button" : "span";
  const dataAttrs = filterDataAttrs(props);
  const el = (0, import_jsx_runtime14.jsxs)(
    ElementType,
    __spreadProps(__spreadValues({
      className: getClassName9({
        primary: variant === "primary",
        secondary: variant === "secondary",
        disabled,
        fullWidth,
        [size]: true
      }),
      onClick: (e3) => {
        if (!onClick) return;
        setLoading(true);
        Promise.resolve(onClick(e3)).then(() => {
          setLoading(false);
        });
      },
      type,
      disabled: disabled || loading,
      tabIndex,
      target: newTab ? "_blank" : void 0,
      rel: newTab ? "noreferrer" : void 0,
      href
    }, dataAttrs), {
      children: [
        icon && (0, import_jsx_runtime14.jsx)("div", { className: getClassName9("icon"), children: icon }),
        children,
        loading && (0, import_jsx_runtime14.jsx)("div", { className: getClassName9("spinner"), children: (0, import_jsx_runtime14.jsx)(Loader, { size: 14 }) })
      ]
    })
  );
  return el;
};
var getClassName10 = get_class_name_factory_default("ExternalInput", styles_module_default6);
var getClassNameModal = get_class_name_factory_default("ExternalInputModal", styles_module_default6);
var dataCache = {};
var ExternalInput = ({
  field,
  onChange,
  value = null,
  name,
  id,
  readOnly
}) => {
  const {
    mapProp = (val) => val,
    mapRow = (val) => val,
    filterFields
  } = field || {};
  const [data, setData] = (0, import_react24.useState)([]);
  const [isOpen, setOpen] = (0, import_react24.useState)(false);
  const [isLoading, setIsLoading] = (0, import_react24.useState)(true);
  const hasFilterFields = !!filterFields;
  const [filters, setFilters] = (0, import_react24.useState)(field.initialFilters || {});
  const [filtersToggled, setFiltersToggled] = (0, import_react24.useState)(hasFilterFields);
  const mappedData = (0, import_react24.useMemo)(() => {
    return data.map(mapRow);
  }, [data]);
  const keys = (0, import_react24.useMemo)(() => {
    const validKeys = /* @__PURE__ */ new Set();
    for (const item of mappedData) {
      for (const key of Object.keys(item)) {
        if (typeof item[key] === "string" || typeof item[key] === "number" || (0, import_react24.isValidElement)(item[key])) {
          validKeys.add(key);
        }
      }
    }
    return Array.from(validKeys);
  }, [mappedData]);
  const [searchQuery, setSearchQuery] = (0, import_react24.useState)(field.initialQuery || "");
  const search = (0, import_react24.useCallback)(
    (query, filters2) => __async(void 0, null, function* () {
      setIsLoading(true);
      const cacheKey = `${id}-${query}-${JSON.stringify(filters2)}`;
      const listData = dataCache[cacheKey] || (yield field.fetchList({ query, filters: filters2 }));
      if (listData) {
        setData(listData);
        setIsLoading(false);
        dataCache[cacheKey] = listData;
      }
    }),
    [id, field]
  );
  const Footer = (0, import_react24.useCallback)(
    (props) => field.renderFooter ? field.renderFooter(props) : (0, import_jsx_runtime15.jsxs)("span", { className: getClassNameModal("footer"), children: [
      props.items.length,
      " result",
      props.items.length === 1 ? "" : "s"
    ] }),
    [field.renderFooter]
  );
  (0, import_react24.useEffect)(() => {
    search(searchQuery, filters);
  }, []);
  return (0, import_jsx_runtime15.jsxs)(
    "div",
    {
      className: getClassName10({
        dataSelected: !!value,
        modalVisible: isOpen,
        readOnly
      }),
      id,
      children: [
        (0, import_jsx_runtime15.jsxs)("div", { className: getClassName10("actions"), children: [
          (0, import_jsx_runtime15.jsx)(
            "button",
            {
              type: "button",
              onClick: () => setOpen(true),
              className: getClassName10("button"),
              disabled: readOnly,
              children: value ? field.getItemSummary ? field.getItemSummary(value) : "External item" : (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [
                (0, import_jsx_runtime15.jsx)(Link, { size: "16" }),
                (0, import_jsx_runtime15.jsx)("span", { children: field.placeholder })
              ] })
            }
          ),
          value && (0, import_jsx_runtime15.jsx)(
            "button",
            {
              type: "button",
              className: getClassName10("detachButton"),
              onClick: () => {
                onChange(null);
              },
              disabled: readOnly,
              children: (0, import_jsx_runtime15.jsx)(LockOpen, { size: 16 })
            }
          )
        ] }),
        (0, import_jsx_runtime15.jsx)(Modal, { onClose: () => setOpen(false), isOpen, children: (0, import_jsx_runtime15.jsxs)(
          "form",
          {
            className: getClassNameModal({
              isLoading,
              loaded: !isLoading,
              hasData: mappedData.length > 0,
              filtersToggled
            }),
            onSubmit: (e3) => {
              e3.preventDefault();
              search(searchQuery, filters);
            },
            children: [
              (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("masthead"), children: field.showSearch ? (0, import_jsx_runtime15.jsxs)("div", { className: getClassNameModal("searchForm"), children: [
                (0, import_jsx_runtime15.jsxs)("label", { className: getClassNameModal("search"), children: [
                  (0, import_jsx_runtime15.jsx)("span", { className: getClassNameModal("searchIconText"), children: "Search" }),
                  (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("searchIcon"), children: (0, import_jsx_runtime15.jsx)(Search, { size: "18" }) }),
                  (0, import_jsx_runtime15.jsx)(
                    "input",
                    {
                      className: getClassNameModal("searchInput"),
                      name: "q",
                      type: "search",
                      placeholder: field.placeholder,
                      onChange: (e3) => {
                        setSearchQuery(e3.currentTarget.value);
                      },
                      autoComplete: "off",
                      value: searchQuery
                    }
                  )
                ] }),
                (0, import_jsx_runtime15.jsxs)("div", { className: getClassNameModal("searchActions"), children: [
                  (0, import_jsx_runtime15.jsx)(Button, { type: "submit", loading: isLoading, fullWidth: true, children: "Search" }),
                  hasFilterFields && (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("searchActionIcon"), children: (0, import_jsx_runtime15.jsx)(
                    IconButton,
                    {
                      title: "Toggle filters",
                      onClick: (e3) => {
                        e3.preventDefault();
                        e3.stopPropagation();
                        setFiltersToggled(!filtersToggled);
                      },
                      children: (0, import_jsx_runtime15.jsx)(SlidersHorizontal, { size: 20 })
                    }
                  ) })
                ] })
              ] }) : (0, import_jsx_runtime15.jsx)(Heading, { rank: "2", size: "xs", children: field.placeholder || "Select data" }) }),
              (0, import_jsx_runtime15.jsxs)("div", { className: getClassNameModal("grid"), children: [
                hasFilterFields && (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("filters"), children: hasFilterFields && Object.keys(filterFields).map((fieldName) => {
                  const filterField = filterFields[fieldName];
                  return (0, import_jsx_runtime15.jsx)(
                    "div",
                    {
                      className: getClassNameModal("field"),
                      children: (0, import_jsx_runtime15.jsx)(
                        AutoFieldPrivate,
                        {
                          field: filterField,
                          name: fieldName,
                          id: `external_field_${fieldName}_filter`,
                          label: filterField.label || fieldName,
                          value: filters[fieldName],
                          onChange: (value2) => {
                            const newFilters = __spreadProps(__spreadValues({}, filters), {
                              [fieldName]: value2
                            });
                            setFilters(newFilters);
                            search(searchQuery, newFilters);
                          }
                        }
                      )
                    },
                    fieldName
                  );
                }) }),
                (0, import_jsx_runtime15.jsxs)("div", { className: getClassNameModal("tableWrapper"), children: [
                  (0, import_jsx_runtime15.jsxs)("table", { className: getClassNameModal("table"), children: [
                    (0, import_jsx_runtime15.jsx)("thead", { className: getClassNameModal("thead"), children: (0, import_jsx_runtime15.jsx)("tr", { className: getClassNameModal("tr"), children: keys.map((key) => (0, import_jsx_runtime15.jsx)(
                      "th",
                      {
                        className: getClassNameModal("th"),
                        style: { textAlign: "left" },
                        children: key
                      },
                      key
                    )) }) }),
                    (0, import_jsx_runtime15.jsx)("tbody", { className: getClassNameModal("tbody"), children: mappedData.map((item, i2) => {
                      return (0, import_jsx_runtime15.jsx)(
                        "tr",
                        {
                          style: { whiteSpace: "nowrap" },
                          className: getClassNameModal("tr"),
                          onClick: () => {
                            onChange(mapProp(data[i2]));
                            setOpen(false);
                          },
                          children: keys.map((key) => (0, import_jsx_runtime15.jsx)("td", { className: getClassNameModal("td"), children: item[key] }, key))
                        },
                        i2
                      );
                    }) })
                  ] }),
                  (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("loadingBanner"), children: (0, import_jsx_runtime15.jsx)(Loader, { size: 24 }) })
                ] })
              ] }),
              (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("footerContainer"), children: (0, import_jsx_runtime15.jsx)(Footer, { items: mappedData }) })
            ]
          }
        ) })
      ]
    }
  );
};
var ExternalField = ({
  field,
  onChange,
  value,
  name,
  label,
  Label: Label2,
  id,
  readOnly
}) => {
  var _a3, _b2, _c4;
  const validField = field;
  const deprecatedField = field;
  (0, import_react23.useEffect)(() => {
    if (deprecatedField.adaptor) {
      console.error(
        "Warning: The `adaptor` API is deprecated. Please use updated APIs on the `external` field instead. This will be a breaking change in a future release."
      );
    }
  }, []);
  if (field.type !== "external") {
    return null;
  }
  return (0, import_jsx_runtime16.jsx)(Label2, { label: label || name, icon: (0, import_jsx_runtime16.jsx)(Link, { size: 16 }), el: "div", children: (0, import_jsx_runtime16.jsx)(
    ExternalInput,
    {
      name,
      field: __spreadProps(__spreadValues({}, validField), {
        // DEPRECATED
        placeholder: ((_a3 = deprecatedField.adaptor) == null ? void 0 : _a3.name) ? `Select from ${deprecatedField.adaptor.name}` : validField.placeholder || "Select data",
        mapProp: ((_b2 = deprecatedField.adaptor) == null ? void 0 : _b2.mapProp) || validField.mapProp,
        mapRow: validField.mapRow,
        fetchList: ((_c4 = deprecatedField.adaptor) == null ? void 0 : _c4.fetchList) ? () => __async(void 0, null, function* () {
          return yield deprecatedField.adaptor.fetchList(
            deprecatedField.adaptorParams
          );
        }) : validField.fetchList
      }),
      onChange,
      value,
      id,
      readOnly
    }
  ) });
};
init_react_import();
init_react_import();
var safeJsonParse = (str) => {
  try {
    const jsonValue = JSON.parse(str);
    return jsonValue;
  } catch (e3) {
    return str;
  }
};
var getClassName11 = get_class_name_factory_default("Input", styles_module_default2);
var RadioField = ({
  field,
  onChange,
  readOnly,
  value,
  name,
  id,
  label,
  Label: Label2
}) => {
  const flatOptions = (0, import_react27.useMemo)(
    () => field.type === "radio" ? field.options.map(({ value: value2 }) => value2) : [],
    [field]
  );
  if (field.type !== "radio" || !field.options) {
    return null;
  }
  return (0, import_jsx_runtime17.jsx)(
    Label2,
    {
      icon: (0, import_jsx_runtime17.jsx)(CircleCheckBig, { size: 16 }),
      label: label || name,
      readOnly,
      el: "div",
      children: (0, import_jsx_runtime17.jsx)("div", { className: getClassName11("radioGroupItems"), id, children: field.options.map((option) => (0, import_jsx_runtime17.jsxs)(
        "label",
        {
          className: getClassName11("radio"),
          children: [
            (0, import_jsx_runtime17.jsx)(
              "input",
              {
                type: "radio",
                className: getClassName11("radioInput"),
                value: option.value,
                name,
                onChange: (e3) => {
                  var _a3;
                  const jsonValue = (_a3 = safeJsonParse(e3.target.value)) != null ? _a3 : e3.target.value;
                  if (flatOptions.indexOf(jsonValue) > -1) {
                    onChange(jsonValue);
                  } else {
                    onChange(e3.target.value);
                  }
                },
                disabled: readOnly,
                checked: value === option.value
              }
            ),
            (0, import_jsx_runtime17.jsx)("div", { className: getClassName11("radioInner"), children: option.label || option.value })
          ]
        },
        option.label + option.value
      )) })
    }
  );
};
init_react_import();
var getClassName12 = get_class_name_factory_default("Input", styles_module_default2);
var SelectField = ({
  field,
  onChange,
  label,
  Label: Label2,
  value,
  name,
  readOnly,
  id
}) => {
  const flatOptions = (0, import_react28.useMemo)(
    () => field.type === "select" ? field.options.map(({ value: value2 }) => value2) : [],
    [field]
  );
  if (field.type !== "select" || !field.options) {
    return null;
  }
  return (0, import_jsx_runtime18.jsx)(
    Label2,
    {
      label: label || name,
      icon: (0, import_jsx_runtime18.jsx)(ChevronDown, { size: 16 }),
      readOnly,
      children: (0, import_jsx_runtime18.jsx)(
        "select",
        {
          id,
          title: label || name,
          className: getClassName12("input"),
          disabled: readOnly,
          onChange: (e3) => {
            var _a3;
            const jsonValue = (_a3 = safeJsonParse(e3.target.value)) != null ? _a3 : e3.target.value;
            if (flatOptions.indexOf(jsonValue) > -1) {
              onChange(jsonValue);
            } else {
              onChange(e3.target.value);
            }
          },
          value,
          children: field.options.map((option) => (0, import_jsx_runtime18.jsx)(
            "option",
            {
              label: option.label,
              value: option.value
            },
            option.label + option.value
          ))
        }
      )
    }
  );
};
init_react_import();
var getClassName13 = get_class_name_factory_default("Input", styles_module_default2);
var TextareaField = ({
  onChange,
  readOnly,
  value,
  name,
  label,
  Label: Label2,
  id
}) => {
  return (0, import_jsx_runtime19.jsx)(Label2, { label: label || name, icon: (0, import_jsx_runtime19.jsx)(Type, { size: 16 }), readOnly, children: (0, import_jsx_runtime19.jsx)(
    "textarea",
    {
      id,
      className: getClassName13("input"),
      autoComplete: "off",
      name,
      value: typeof value === "undefined" ? "" : value,
      onChange: (e3) => onChange(e3.currentTarget.value),
      readOnly,
      tabIndex: readOnly ? -1 : void 0,
      rows: 5
    }
  ) });
};
init_react_import();
init_react_import();
var styles_module_default9 = { "ObjectField": "_ObjectField_1ua3y_5", "ObjectField-fieldset": "_ObjectField-fieldset_1ua3y_13" };
var getClassName14 = get_class_name_factory_default("ObjectField", styles_module_default9);
var ObjectField = ({
  field,
  onChange,
  value,
  name,
  label,
  Label: Label2,
  readOnly,
  id
}) => {
  const { readOnlyFields, localName = name } = useNestedFieldContext();
  if (field.type !== "object" || !field.objectFields) {
    return null;
  }
  const data = value || {};
  return (0, import_jsx_runtime20.jsx)(
    Label2,
    {
      label: label || name,
      icon: (0, import_jsx_runtime20.jsx)(EllipsisVertical, { size: 16 }),
      el: "div",
      readOnly,
      children: (0, import_jsx_runtime20.jsx)("div", { className: getClassName14(), children: (0, import_jsx_runtime20.jsx)("fieldset", { className: getClassName14("fieldset"), children: Object.keys(field.objectFields).map((subName) => {
        const subField = field.objectFields[subName];
        const subPath = `${name}.${subName}`;
        const localSubPath = `${localName || name}.${subName}`;
        const subReadOnly = readOnly ? readOnly : readOnlyFields[localSubPath];
        const label2 = subField.label || subName;
        return (0, import_jsx_runtime20.jsx)(
          NestedFieldProvider,
          {
            name: localName || id,
            subName,
            readOnlyFields,
            children: (0, import_jsx_runtime20.jsx)(
              AutoFieldPrivate,
              {
                name: subPath,
                label: subPath,
                id: `${id}_${subName}`,
                readOnly: subReadOnly,
                field: __spreadProps(__spreadValues({}, subField), {
                  label: label2
                  // May be used by custom fields
                }),
                value: data[subName],
                onChange: (val, ui) => {
                  onChange(
                    __spreadProps(__spreadValues({}, data), {
                      [subName]: val
                    }),
                    ui
                  );
                }
              }
            )
          },
          subPath
        );
      }) }) })
    }
  );
};
init_react_import();
init_react_import();
var generateId = (type) => type ? `${type}-${v4_default()}` : v4_default();
var useSafeId = () => {
  if (typeof import_react29.default.useId !== "undefined") {
    return import_react29.default.useId();
  }
  const [id] = (0, import_react29.useState)(generateId());
  return id;
};
var getClassName15 = get_class_name_factory_default("Input", styles_module_default2);
var getClassNameWrapper = get_class_name_factory_default("InputWrapper", styles_module_default2);
var FieldLabel = ({
  children,
  icon,
  label,
  el = "label",
  readOnly,
  className
}) => {
  const El = el;
  return (0, import_jsx_runtime21.jsxs)(El, { className, children: [
    (0, import_jsx_runtime21.jsxs)("div", { className: getClassName15("label"), children: [
      icon ? (0, import_jsx_runtime21.jsx)("div", { className: getClassName15("labelIcon"), children: icon }) : (0, import_jsx_runtime21.jsx)(import_jsx_runtime21.Fragment, {}),
      label,
      readOnly && (0, import_jsx_runtime21.jsx)("div", { className: getClassName15("disabledIcon"), title: "Read-only", children: (0, import_jsx_runtime21.jsx)(Lock, { size: "12" }) })
    ] }),
    children
  ] });
};
var FieldLabelInternal = ({
  children,
  icon,
  label,
  el = "label",
  readOnly
}) => {
  const { overrides } = useAppContext();
  const Wrapper = (0, import_react10.useMemo)(
    () => overrides.fieldLabel || FieldLabel,
    [overrides]
  );
  if (!label) {
    return (0, import_jsx_runtime21.jsx)(import_jsx_runtime21.Fragment, { children });
  }
  return (0, import_jsx_runtime21.jsx)(
    Wrapper,
    {
      label,
      icon,
      className: getClassName15({ readOnly }),
      readOnly,
      el,
      children
    }
  );
};
function AutoFieldInternal(props) {
  var _a3, _b2, _c4, _d2, _e, _f, _g, _h;
  const { dispatch, overrides, selectedItem } = useAppContext();
  const nestedFieldContext = (0, import_react10.useContext)(NestedFieldContext);
  const { id, Label: Label2 = FieldLabelInternal } = props;
  const field = props.field;
  const label = field.label;
  const defaultId = useSafeId();
  const resolvedId = id || defaultId;
  const defaultFields = {
    array: ArrayField,
    external: ExternalField,
    object: ObjectField,
    select: SelectField,
    textarea: TextareaField,
    radio: RadioField,
    text: DefaultField,
    number: DefaultField
  };
  const render = __spreadProps(__spreadValues({}, overrides.fieldTypes), {
    array: ((_a3 = overrides.fieldTypes) == null ? void 0 : _a3.array) || defaultFields.array,
    external: ((_b2 = overrides.fieldTypes) == null ? void 0 : _b2.external) || defaultFields.external,
    object: ((_c4 = overrides.fieldTypes) == null ? void 0 : _c4.object) || defaultFields.object,
    select: ((_d2 = overrides.fieldTypes) == null ? void 0 : _d2.select) || defaultFields.select,
    textarea: ((_e = overrides.fieldTypes) == null ? void 0 : _e.textarea) || defaultFields.textarea,
    radio: ((_f = overrides.fieldTypes) == null ? void 0 : _f.radio) || defaultFields.radio,
    text: ((_g = overrides.fieldTypes) == null ? void 0 : _g.text) || defaultFields.text,
    number: ((_h = overrides.fieldTypes) == null ? void 0 : _h.number) || defaultFields.number
  });
  const mergedProps = __spreadProps(__spreadValues({}, props), {
    field,
    label,
    Label: Label2,
    id: resolvedId
  });
  const onFocus = (0, import_react10.useCallback)(
    (e3) => {
      if (mergedProps.name && (e3.target.nodeName === "INPUT" || e3.target.nodeName === "TEXTAREA")) {
        e3.stopPropagation();
        dispatch({
          type: "setUi",
          ui: {
            field: { focus: mergedProps.name }
          }
        });
      }
    },
    [mergedProps.name]
  );
  const onBlur = (0, import_react10.useCallback)((e3) => {
    if ("name" in e3.target) {
      dispatch({
        type: "setUi",
        ui: {
          field: { focus: null }
        }
      });
    }
  }, []);
  if (field.type === "custom") {
    if (!field.render) {
      return null;
    }
    const CustomField = field.render;
    return (0, import_jsx_runtime21.jsx)("div", { className: getClassNameWrapper(), onFocus, onBlur, children: (0, import_jsx_runtime21.jsx)("div", { className: getClassName15(), children: (0, import_jsx_runtime21.jsx)(CustomField, __spreadValues({}, mergedProps)) }) });
  }
  const children = defaultFields[field.type](mergedProps);
  const Render2 = render[field.type];
  return (0, import_jsx_runtime21.jsx)(
    NestedFieldContext.Provider,
    {
      value: {
        readOnlyFields: nestedFieldContext.readOnlyFields || (selectedItem == null ? void 0 : selectedItem.readOnly) || {},
        localName: nestedFieldContext.localName
      },
      children: (0, import_jsx_runtime21.jsx)(
        "div",
        {
          className: getClassNameWrapper(),
          onFocus,
          onBlur,
          onClick: (e3) => {
            e3.stopPropagation();
          },
          children: (0, import_jsx_runtime21.jsx)(Render2, __spreadProps(__spreadValues({}, mergedProps), { children }))
        }
      )
    }
  );
}
function AutoFieldPrivate(props) {
  const { state } = useAppContext();
  const { value, onChange } = props;
  const [localValue, setLocalValue] = (0, import_react10.useState)(value);
  const onChangeDb = c2(
    (val, ui) => {
      onChange(val, ui);
    },
    50,
    { leading: true }
  );
  const onChangeLocal = (0, import_react10.useCallback)((val, ui) => {
    setLocalValue(val);
    onChangeDb(val, ui);
  }, []);
  (0, import_react10.useEffect)(() => {
    if (state.ui.field.focus !== props.name) {
      setLocalValue(value);
    }
  }, [value]);
  const localProps = {
    value: localValue,
    onChange: onChangeLocal
  };
  return (0, import_jsx_runtime21.jsx)(AutoFieldInternal, __spreadValues(__spreadValues({}, props), localProps));
}
function AutoField(props) {
  const DefaultLabel = (0, import_react10.useMemo)(() => {
    const DefaultLabel2 = (labelProps) => (0, import_jsx_runtime21.jsx)(
      "div",
      __spreadProps(__spreadValues({}, labelProps), {
        className: getClassName15({ readOnly: props.readOnly })
      })
    );
    return DefaultLabel2;
  }, [props.readOnly]);
  return (0, import_jsx_runtime21.jsx)(AutoFieldInternal, __spreadProps(__spreadValues({}, props), { Label: DefaultLabel }));
}
init_react_import();
init_react_import();
var styles_module_default10 = { "Drawer": "_Drawer_fkqfo_1", "Drawer-draggable": "_Drawer-draggable_fkqfo_8", "Drawer-draggableBg": "_Drawer-draggableBg_fkqfo_12", "Drawer-draggableFg": "_Drawer-draggableFg_fkqfo_21", "DrawerItem-draggable": "_DrawerItem-draggable_fkqfo_25", "DrawerItem--disabled": "_DrawerItem--disabled_fkqfo_38", "DrawerItem": "_DrawerItem_fkqfo_25", "Drawer--isDraggingFrom": "_Drawer--isDraggingFrom_fkqfo_48", "DrawerItem-name": "_DrawerItem-name_fkqfo_66" };
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var styles_module_default11 = { "DraggableComponent": "_DraggableComponent_1ukn8_1", "DraggableComponent-overlay": "_DraggableComponent-overlay_1ukn8_12", "DraggableComponent-loadingOverlay": "_DraggableComponent-loadingOverlay_1ukn8_29", "DraggableComponent--hover": "_DraggableComponent--hover_1ukn8_45", "DraggableComponent--isLocked": "_DraggableComponent--isLocked_1ukn8_45", "DraggableComponent--isSelected": "_DraggableComponent--isSelected_1ukn8_54", "DraggableComponent-actionsOverlay": "_DraggableComponent-actionsOverlay_1ukn8_66", "DraggableComponent-actions": "_DraggableComponent-actions_1ukn8_66" };
init_react_import();
function getDeepScrollPosition(element) {
  let totalScroll = {
    x: 0,
    y: 0
  };
  let current = element;
  while (current && current !== document.documentElement) {
    const parent = current.parentElement;
    if (parent) {
      totalScroll.x += parent.scrollLeft;
      totalScroll.y += parent.scrollTop;
    }
    current = parent;
  }
  return totalScroll;
}
init_react_import();
var dropZoneContext = (0, import_react35.createContext)(null);
var ZoneStoreContext = (0, import_react35.createContext)(
  createStore(() => ({
    zoneDepthIndex: {},
    nextZoneDepthIndex: {},
    areaDepthIndex: {},
    nextAreaDepthIndex: {},
    draggedItem: null,
    previewIndex: {}
  }))
);
var ZoneStoreProvider = ({
  children,
  store
}) => {
  return (0, import_jsx_runtime22.jsx)(ZoneStoreContext.Provider, { value: store, children });
};
var DropZoneProvider = ({
  children,
  value
}) => {
  const [hoveringComponent, setHoveringComponent] = (0, import_react35.useState)();
  const [areasWithZones, setAreasWithZones] = (0, import_react35.useState)(
    {}
  );
  const [activeZones, setActiveZones] = (0, import_react35.useState)({});
  const { dispatch } = useAppContext();
  const registerZoneArea = (0, import_react35.useCallback)(
    (area) => {
      setAreasWithZones((latest) => __spreadProps(__spreadValues({}, latest), { [area]: true }));
    },
    [setAreasWithZones]
  );
  const registerZone = (0, import_react35.useCallback)(
    (zoneCompound) => {
      if (!dispatch) {
        return;
      }
      dispatch({
        type: "registerZone",
        zone: zoneCompound
      });
      setActiveZones((latest) => __spreadProps(__spreadValues({}, latest), { [zoneCompound]: true }));
    },
    [setActiveZones, dispatch]
  );
  const unregisterZone = (0, import_react35.useCallback)(
    (zoneCompound) => {
      if (!dispatch) {
        return;
      }
      dispatch({
        type: "unregisterZone",
        zone: zoneCompound
      });
      setActiveZones((latest) => __spreadProps(__spreadValues({}, latest), {
        [zoneCompound]: false
      }));
    },
    [setActiveZones, dispatch]
  );
  const memoValue = (0, import_react35.useMemo)(
    () => __spreadValues({
      hoveringComponent,
      setHoveringComponent,
      registerZoneArea,
      areasWithZones,
      registerZone,
      unregisterZone,
      activeZones
    }, value),
    [value, hoveringComponent, areasWithZones, activeZones]
  );
  return (0, import_jsx_runtime22.jsx)(import_jsx_runtime22.Fragment, { children: memoValue && (0, import_jsx_runtime22.jsx)(dropZoneContext.Provider, { value: memoValue, children }) });
};
init_react_import();
function useContextStore(context, selector) {
  const store = (0, import_react36.useContext)(context);
  if (!store) {
    throw new Error("useContextStore must be used inside context");
  }
  return useStore(store, useShallow(selector));
}
var getClassName16 = get_class_name_factory_default("DraggableComponent", styles_module_default11);
var DEBUG2 = false;
var space = 8;
var actionsOverlayTop = space * 6.5;
var actionsTop = -(actionsOverlayTop - 8);
var actionsSide = space;
var DefaultActionBar = ({
  label,
  children,
  parentAction
}) => (0, import_jsx_runtime23.jsxs)(ActionBar, { children: [
  (0, import_jsx_runtime23.jsxs)(ActionBar.Group, { children: [
    parentAction,
    label && (0, import_jsx_runtime23.jsx)(ActionBar.Label, { label })
  ] }),
  (0, import_jsx_runtime23.jsx)(ActionBar.Group, { children })
] });
var convertIdToSelector = (id, zoneCompound, data) => {
  const content = zoneCompound && data.zones && zoneCompound !== "default-zone" ? data.zones[zoneCompound] : data.content;
  const index = content.findIndex((item) => item.props.id === id);
  return {
    zone: zoneCompound || "",
    index
  };
};
var DraggableComponent = ({
  children,
  depth,
  componentType,
  id,
  index,
  zoneCompound,
  isLoading = false,
  isSelected = false,
  debug,
  label,
  isEnabled,
  autoDragAxis,
  userDragAxis,
  inDroppableZone = true
}) => {
  const {
    zoomConfig,
    overrides,
    selectedItem,
    getPermissions,
    dispatch,
    iframe,
    state
  } = useAppContext();
  const ctx = (0, import_react34.useContext)(dropZoneContext);
  const [localZones, setLocalZones] = (0, import_react34.useState)({});
  const registerLocalZone = (0, import_react34.useCallback)(
    (zoneCompound2, active) => {
      var _a3;
      (_a3 = ctx == null ? void 0 : ctx.registerLocalZone) == null ? void 0 : _a3.call(ctx, zoneCompound2, active);
      setLocalZones((obj) => __spreadProps(__spreadValues({}, obj), {
        [zoneCompound2]: active
      }));
    },
    [setLocalZones]
  );
  const unregisterLocalZone = (0, import_react34.useCallback)(
    (zoneCompound2) => {
      var _a3;
      (_a3 = ctx == null ? void 0 : ctx.unregisterLocalZone) == null ? void 0 : _a3.call(ctx, zoneCompound2);
      setLocalZones((obj) => {
        const newLocalZones = __spreadValues({}, obj);
        delete newLocalZones[zoneCompound2];
        return newLocalZones;
      });
    },
    [setLocalZones]
  );
  const containsActiveZone = Object.values(localZones).filter(Boolean).length > 0;
  const { path = [] } = ctx || {};
  const [canDrag, setCanDrag] = (0, import_react34.useState)(false);
  (0, import_react34.useEffect)(() => {
    var _a3;
    const item = getItem({ index, zone: zoneCompound }, state.data);
    if (item) {
      const perms = getPermissions({
        item
      });
      setCanDrag((_a3 = perms.drag) != null ? _a3 : true);
    }
  }, [state, index, zoneCompound, getPermissions]);
  const userIsDragging = useContextStore(
    ZoneStoreContext,
    (s2) => !!s2.draggedItem
  );
  const canCollide = canDrag || userIsDragging;
  const disabled = !isEnabled || !canCollide;
  const [dragAxis, setDragAxis] = (0, import_react34.useState)(userDragAxis || autoDragAxis);
  const { ref: sortableRef, status } = useSortableSafe({
    id,
    index,
    group: zoneCompound,
    type: "component",
    data: {
      areaId: ctx == null ? void 0 : ctx.areaId,
      zone: zoneCompound,
      index,
      componentType,
      containsActiveZone,
      depth,
      path,
      inDroppableZone
    },
    collisionPriority: isEnabled ? depth : 0,
    collisionDetector: createDynamicCollisionDetector(dragAxis),
    disabled,
    // "Out of the way" transition from react-beautiful-dnd
    transition: {
      duration: 200,
      easing: "cubic-bezier(0.2, 0, 0, 1)"
    }
  });
  const thisIsDragging = status === "dragging";
  const ref = (0, import_react34.useRef)(null);
  const refSetter = (0, import_react34.useCallback)(
    (el) => {
      sortableRef(el);
      if (el) {
        ref.current = el;
      }
    },
    [sortableRef]
  );
  const [portalEl, setPortalEl] = (0, import_react34.useState)();
  (0, import_react34.useEffect)(() => {
    var _a3, _b2, _c4;
    setPortalEl(
      iframe.enabled ? (_a3 = ref.current) == null ? void 0 : _a3.ownerDocument.body : (_c4 = (_b2 = ref.current) == null ? void 0 : _b2.closest("[data-puck-preview]")) != null ? _c4 : document.body
    );
  }, [iframe.enabled, ref.current]);
  const getStyle = (0, import_react34.useCallback)(() => {
    var _a3, _b2, _c4;
    if (!ref.current) return;
    const rect = ref.current.getBoundingClientRect();
    const deepScrollPosition = getDeepScrollPosition(ref.current);
    const portalContainerEl = iframe.enabled ? null : (_a3 = ref.current) == null ? void 0 : _a3.closest("[data-puck-preview]");
    const portalContainerRect = portalContainerEl == null ? void 0 : portalContainerEl.getBoundingClientRect();
    const portalScroll = portalContainerEl ? getDeepScrollPosition(portalContainerEl) : { x: 0, y: 0 };
    const scroll = {
      x: deepScrollPosition.x - portalScroll.x - ((_b2 = portalContainerRect == null ? void 0 : portalContainerRect.left) != null ? _b2 : 0),
      y: deepScrollPosition.y - portalScroll.y - ((_c4 = portalContainerRect == null ? void 0 : portalContainerRect.top) != null ? _c4 : 0)
    };
    const style2 = {
      left: `${rect.left + scroll.x}px`,
      top: `${rect.top + scroll.y}px`,
      height: `${rect.height}px`,
      width: `${rect.width}px`
    };
    return style2;
  }, [ref.current]);
  const [style, setStyle] = (0, import_react34.useState)();
  const sync = (0, import_react34.useCallback)(() => {
    setStyle(getStyle());
  }, [ref.current, iframe]);
  (0, import_react34.useEffect)(() => {
    if (ref.current && !userIsDragging) {
      const observer = new ResizeObserver(sync);
      observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [ref.current, userIsDragging]);
  (0, import_react34.useEffect)(() => {
    ctx == null ? void 0 : ctx.registerPath(
      id,
      {
        index,
        zone: zoneCompound
      },
      componentType
    );
    return () => {
      var _a3;
      (_a3 = ctx == null ? void 0 : ctx.unregisterPath) == null ? void 0 : _a3.call(ctx, id);
    };
  }, [id, zoneCompound, index, componentType]);
  const CustomActionBar = (0, import_react34.useMemo)(
    () => overrides.actionBar || DefaultActionBar,
    [overrides.actionBar]
  );
  const permissions = getPermissions({
    item: selectedItem
  });
  const onClick = (0, import_react34.useCallback)(
    (e3) => {
      e3.stopPropagation();
      dispatch({
        type: "setUi",
        ui: {
          itemSelector: { index, zone: zoneCompound }
        }
      });
    },
    [index, zoneCompound, id]
  );
  const onSelectParent = (0, import_react34.useCallback)(() => {
    if (!(ctx == null ? void 0 : ctx.areaId)) {
      return;
    }
    const parentAreaId = ctx.areaId;
    const parentZone = path[path.length - 3];
    const parentItemSelector = convertIdToSelector(
      parentAreaId,
      parentZone,
      state.data
    );
    dispatch({
      type: "setUi",
      ui: {
        itemSelector: parentItemSelector
      }
    });
  }, [ctx, path]);
  const onDuplicate = (0, import_react34.useCallback)(() => {
    dispatch({
      type: "duplicate",
      sourceIndex: index,
      sourceZone: zoneCompound
    });
  }, [index, zoneCompound]);
  const onDelete = (0, import_react34.useCallback)(() => {
    dispatch({
      type: "remove",
      index,
      zone: zoneCompound
    });
  }, [index, zoneCompound]);
  const [hover, setHover] = (0, import_react34.useState)(false);
  const indicativeHover = (ctx == null ? void 0 : ctx.hoveringComponent) === id;
  (0, import_react34.useEffect)(() => {
    if (!ref.current) {
      return;
    }
    const el = ref.current;
    const _onMouseOver = (e3) => {
      if (userIsDragging) {
        if (thisIsDragging) {
          setHover(true);
        } else {
          setHover(false);
        }
      } else {
        setHover(true);
      }
      e3.stopPropagation();
    };
    const _onMouseOut = (e3) => {
      e3.stopPropagation();
      setHover(false);
    };
    el.setAttribute("data-puck-component", id);
    el.setAttribute("data-puck-dnd", id);
    el.style.position = "relative";
    el.addEventListener("click", onClick);
    el.addEventListener("mouseover", _onMouseOver);
    el.addEventListener("mouseout", _onMouseOut);
    if (thisIsDragging) {
      el.setAttribute("data-puck-dragging", "");
    } else {
      el.removeAttribute("data-puck-dragging");
    }
    return () => {
      el.removeAttribute("data-puck-component");
      el.removeAttribute("data-puck-dnd");
      el.removeEventListener("click", onClick);
      el.removeEventListener("mouseover", _onMouseOver);
      el.removeEventListener("mouseout", _onMouseOut);
      el.removeAttribute("data-puck-dragging");
    };
  }, [
    ref,
    onClick,
    containsActiveZone,
    zoneCompound,
    id,
    userIsDragging,
    thisIsDragging,
    inDroppableZone
  ]);
  (0, import_react34.useEffect)(() => {
    if (ref.current && disabled) {
      ref.current.setAttribute("data-puck-disabled", "");
      return () => {
        var _a3;
        (_a3 = ref.current) == null ? void 0 : _a3.removeAttribute("data-puck-disabled");
      };
    }
  }, [disabled, ref]);
  const [isVisible2, setIsVisible] = (0, import_react34.useState)(false);
  (0, import_react34.useEffect)(() => {
    sync();
    if ((isSelected || hover || indicativeHover) && !userIsDragging) {
      setIsVisible(true);
    } else {
      setIsVisible(false);
    }
  }, [isSelected, hover, indicativeHover, iframe, state.data, userIsDragging]);
  const syncActionsPosition = (0, import_react34.useCallback)(
    (el) => {
      if (el) {
        const view = el.ownerDocument.defaultView;
        if (view) {
          const rect = el.getBoundingClientRect();
          const diffLeft = rect.x;
          const exceedsBoundsLeft = diffLeft < 0;
          if (exceedsBoundsLeft) {
            el.style.transformOrigin = "left top";
            el.style.left = "0px";
          }
        }
      }
    },
    [zoomConfig]
  );
  (0, import_react34.useEffect)(() => {
    if (userDragAxis) {
      setDragAxis(userDragAxis);
      return;
    }
    if (ref.current) {
      const computedStyle = window.getComputedStyle(ref.current);
      if (computedStyle.display === "inline" || computedStyle.display === "inline-block") {
        setDragAxis("x");
        return;
      }
    }
    setDragAxis(autoDragAxis);
  }, [ref, userDragAxis, autoDragAxis]);
  const parentAction = (ctx == null ? void 0 : ctx.areaId) && (ctx == null ? void 0 : ctx.areaId) !== "root" && (0, import_jsx_runtime23.jsx)(ActionBar.Action, { onClick: onSelectParent, label: "Select parent", children: (0, import_jsx_runtime23.jsx)(CornerLeftUp, { size: 16 }) });
  return (0, import_jsx_runtime23.jsxs)(
    DropZoneProvider,
    {
      value: __spreadProps(__spreadValues({}, ctx), {
        areaId: id,
        zoneCompound,
        index,
        depth: depth + 1,
        registerLocalZone,
        unregisterLocalZone,
        path: [...path, id]
      }),
      children: [
        isVisible2 && (0, import_react_dom3.createPortal)(
          (0, import_jsx_runtime23.jsxs)(
            "div",
            {
              className: getClassName16({
                isSelected,
                isDragging: thisIsDragging,
                hover: hover || indicativeHover
              }),
              style: __spreadValues({}, style),
              "data-puck-overlay": true,
              children: [
                debug,
                isLoading && (0, import_jsx_runtime23.jsx)("div", { className: getClassName16("loadingOverlay"), children: (0, import_jsx_runtime23.jsx)(Loader, {}) }),
                (0, import_jsx_runtime23.jsx)(
                  "div",
                  {
                    className: getClassName16("actionsOverlay"),
                    style: {
                      top: actionsOverlayTop / zoomConfig.zoom
                    },
                    children: (0, import_jsx_runtime23.jsx)(
                      "div",
                      {
                        className: getClassName16("actions"),
                        style: {
                          transform: `scale(${1 / zoomConfig.zoom}`,
                          top: actionsTop / zoomConfig.zoom,
                          right: 0,
                          paddingLeft: actionsSide,
                          paddingRight: actionsSide
                        },
                        ref: syncActionsPosition,
                        children: (0, import_jsx_runtime23.jsxs)(
                          CustomActionBar,
                          {
                            parentAction,
                            label: DEBUG2 ? id : label,
                            children: [
                              permissions.duplicate && (0, import_jsx_runtime23.jsx)(ActionBar.Action, { onClick: onDuplicate, label: "Duplicate", children: (0, import_jsx_runtime23.jsx)(Copy, { size: 16 }) }),
                              permissions.delete && (0, import_jsx_runtime23.jsx)(ActionBar.Action, { onClick: onDelete, label: "Delete", children: (0, import_jsx_runtime23.jsx)(Trash, { size: 16 }) })
                            ]
                          }
                        )
                      }
                    )
                  }
                ),
                (0, import_jsx_runtime23.jsx)("div", { className: getClassName16("overlay") })
              ]
            }
          ),
          portalEl || document.body
        ),
        children(refSetter)
      ]
    }
  );
};
init_react_import();
var styles_module_default12 = { "DropZone": "_DropZone_kmkdc_1", "DropZone--isActive": "_DropZone--isActive_kmkdc_10", "DropZone--hasChildren": "_DropZone--hasChildren_kmkdc_14", "DropZone--userIsDragging": "_DropZone--userIsDragging_kmkdc_22", "DropZone--isAreaSelected": "_DropZone--isAreaSelected_kmkdc_26", "DropZone--hoveringOverArea": "_DropZone--hoveringOverArea_kmkdc_27", "DropZone--isRootZone": "_DropZone--isRootZone_kmkdc_27", "DropZone--isDestination": "_DropZone--isDestination_kmkdc_37", "DropZone-item": "_DropZone-item_kmkdc_49", "DropZone-hitbox": "_DropZone-hitbox_kmkdc_53", "DropZone--isEnabled": "_DropZone--isEnabled_kmkdc_61", "DropZone--isAnimating": "_DropZone--isAnimating_kmkdc_70" };
init_react_import();
var useMinEmptyHeight = ({
  zoneCompound,
  userMinEmptyHeight,
  ref
}) => {
  const [prevHeight, setPrevHeight] = (0, import_react37.useState)(0);
  const [isAnimating, setIsAnimating] = (0, import_react37.useState)(false);
  const { draggedItem, isZone } = useContextStore(ZoneStoreContext, (s2) => {
    var _a3, _b2;
    return {
      draggedItem: ((_a3 = s2.draggedItem) == null ? void 0 : _a3.data.zone) === zoneCompound ? s2.draggedItem : null,
      isZone: ((_b2 = s2.draggedItem) == null ? void 0 : _b2.data.zone) === zoneCompound
    };
  });
  (0, import_react37.useEffect)(() => {
    if (draggedItem && ref.current) {
      if (isZone) {
        const rect = ref.current.getBoundingClientRect();
        setPrevHeight(rect.height);
        setIsAnimating(true);
        return;
      }
    }
    setPrevHeight(0);
    setTimeout(() => {
      setIsAnimating(false);
    }, 400);
  }, [ref.current, draggedItem, zoneCompound]);
  return [prevHeight || userMinEmptyHeight, isAnimating];
};
init_react_import();
function assignRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else if (ref && typeof ref === "object" && "current" in ref) {
    ref.current = node;
  }
}
function assignRefs(refs, node) {
  refs.forEach((ref) => {
    assignRef(ref, node);
  });
}
init_react_import();
init_react_import();
function useRenderedCallback(callback, deps) {
  const manager = useDragDropManager();
  return (0, import_react40.useCallback)(
    (...args) => __async(this, null, function* () {
      yield manager == null ? void 0 : manager.renderer.rendering;
      return callback(...args);
    }),
    [...deps, manager]
  );
}
init_react_import();
var insert = (list, index, item) => {
  const result = Array.from(list);
  result.splice(index, 0, item);
  return result;
};
var useContentWithPreview = (content, zoneCompound) => {
  const { draggedItemId, preview, previewExists } = useContextStore(
    ZoneStoreContext,
    (s2) => {
      var _a3;
      return {
        draggedItemId: (_a3 = s2.draggedItem) == null ? void 0 : _a3.id,
        preview: s2.previewIndex[zoneCompound],
        previewExists: Object.keys(s2.previewIndex || {}).length > 0
      };
    }
  );
  const {
    state: {
      ui: { isDragging }
    }
  } = useAppContext();
  const [contentWithPreview, setContentWithPreview] = (0, import_react38.useState)(content);
  const [localPreview, setLocalPreview] = (0, import_react38.useState)(
    preview
  );
  const updateContent = useRenderedCallback(
    (content2, preview2, isDragging2) => {
      if (isDragging2 && !previewExists) {
        return;
      }
      if (preview2) {
        if (preview2.type === "insert") {
          setContentWithPreview(
            insert(
              content2.filter((item) => item.props.id !== preview2.props.id),
              preview2.index,
              {
                type: "preview",
                props: { id: preview2.props.id }
              }
            )
          );
        } else {
          setContentWithPreview(
            insert(
              content2.filter((item) => item.props.id !== preview2.props.id),
              preview2.index,
              {
                type: preview2.componentType,
                props: preview2.props
              }
            )
          );
        }
      } else {
        setContentWithPreview(
          previewExists ? content2.filter((item) => item.props.id !== draggedItemId) : content2
        );
      }
      setLocalPreview(preview2);
    },
    [draggedItemId, previewExists]
  );
  (0, import_react38.useEffect)(() => {
    updateContent(content, preview, isDragging);
  }, [content, preview, isDragging]);
  return [contentWithPreview, localPreview];
};
init_react_import();
var GRID_DRAG_AXIS = "dynamic";
var FLEX_ROW_DRAG_AXIS = "x";
var DEFAULT_DRAG_AXIS = "y";
var useDragAxis = (ref, collisionAxis) => {
  const { status } = useAppContext();
  const [dragAxis, setDragAxis] = (0, import_react41.useState)(
    collisionAxis || DEFAULT_DRAG_AXIS
  );
  const calculateDragAxis = (0, import_react41.useCallback)(() => {
    if (ref.current) {
      const computedStyle = window.getComputedStyle(ref.current);
      if (computedStyle.display === "grid") {
        setDragAxis(GRID_DRAG_AXIS);
      } else if (computedStyle.display === "flex" && computedStyle.flexDirection === "row") {
        setDragAxis(FLEX_ROW_DRAG_AXIS);
      } else {
        setDragAxis(DEFAULT_DRAG_AXIS);
      }
    }
  }, [ref.current]);
  (0, import_react41.useEffect)(() => {
    const onViewportChange = () => {
      calculateDragAxis();
    };
    window.addEventListener("viewportchange", onViewportChange);
    return () => {
      window.removeEventListener("viewportchange", onViewportChange);
    };
  }, []);
  (0, import_react41.useEffect)(calculateDragAxis, [status, collisionAxis]);
  return [dragAxis, calculateDragAxis];
};
var getClassName17 = get_class_name_factory_default("DropZone", styles_module_default12);
var getRandomColor = () => `#${Math.floor(Math.random() * 16777215).toString(16)}`;
var RENDER_DEBUG = false;
var DropZoneEditPure = (props) => (0, import_jsx_runtime24.jsx)(DropZoneEdit, __spreadValues({}, props));
var DropZoneEdit = (0, import_react33.forwardRef)(
  function DropZoneEditInternal({
    zone,
    allow,
    disallow,
    style,
    className,
    minEmptyHeight: userMinEmptyHeight = 128,
    collisionAxis
  }, userRef) {
    const appContext2 = useAppContext();
    const ctx = (0, import_react33.useContext)(dropZoneContext);
    const {
      // These all need setting via context
      data,
      config,
      areaId,
      registerZoneArea,
      depth,
      registerLocalZone,
      unregisterLocalZone,
      path = [],
      activeZones
    } = ctx;
    let zoneCompound = rootDroppableId;
    if (areaId) {
      if (zone !== rootDroppableId) {
        zoneCompound = `${areaId}:${zone}`;
      }
    }
    const isRootZone = zoneCompound === rootDroppableId || zone === rootDroppableId || areaId === "root";
    const {
      isDeepestZone,
      inNextDeepestArea,
      draggedComponentType,
      userIsDragging
    } = useContextStore(ZoneStoreContext, (s2) => {
      var _a3, _b2, _c4;
      return {
        isDeepestZone: (_a3 = s2.zoneDepthIndex[zoneCompound]) != null ? _a3 : false,
        inNextDeepestArea: s2.nextAreaDepthIndex[areaId || ""],
        draggedItemId: (_b2 = s2.draggedItem) == null ? void 0 : _b2.id,
        draggedComponentType: (_c4 = s2.draggedItem) == null ? void 0 : _c4.data.componentType,
        userIsDragging: !!s2.draggedItem
      };
    });
    const { itemSelector } = appContext2.state.ui;
    (0, import_react33.useEffect)(() => {
      if (areaId && registerZoneArea) {
        registerZoneArea(areaId);
      }
    }, [areaId]);
    (0, import_react33.useEffect)(() => {
      if (ctx == null ? void 0 : ctx.registerZone) {
        ctx == null ? void 0 : ctx.registerZone(zoneCompound);
      }
      return () => {
        if (ctx == null ? void 0 : ctx.unregisterZone) {
          ctx == null ? void 0 : ctx.unregisterZone(zoneCompound);
        }
      };
    }, []);
    const content = (0, import_react33.useMemo)(() => {
      if (areaId && zone !== rootDroppableId) {
        return setupZone(data, zoneCompound).zones[zoneCompound];
      }
      return data.content || [];
    }, [data, zoneCompound]);
    const ref = (0, import_react33.useRef)(null);
    const acceptsTarget = (0, import_react33.useCallback)(
      (componentType) => {
        if (!componentType) {
          return true;
        }
        if (disallow) {
          const defaultedAllow = allow || [];
          const filteredDisallow = (disallow || []).filter(
            (item) => defaultedAllow.indexOf(item) === -1
          );
          if (filteredDisallow.indexOf(componentType) !== -1) {
            return false;
          }
        } else if (allow) {
          if (allow.indexOf(componentType) === -1) {
            return false;
          }
        }
        return true;
      },
      [allow, disallow]
    );
    (0, import_react33.useEffect)(() => {
      if (registerLocalZone) {
        registerLocalZone(zoneCompound, acceptsTarget(draggedComponentType));
      }
      return () => {
        if (unregisterLocalZone) {
          unregisterLocalZone(zoneCompound);
        }
      };
    }, [draggedComponentType, zoneCompound]);
    const hoveringOverArea = inNextDeepestArea || isRootZone;
    let isEnabled = true;
    if (userIsDragging) {
      isEnabled = isDeepestZone;
    }
    if (isEnabled) {
      isEnabled = acceptsTarget(draggedComponentType);
    }
    const [contentWithPreview, preview] = useContentWithPreview(
      content,
      zoneCompound
    );
    const isDropEnabled = isEnabled && (preview ? contentWithPreview.length === 1 : contentWithPreview.length === 0);
    const droppableConfig = {
      id: zoneCompound,
      collisionPriority: isEnabled ? depth : 0,
      disabled: !isDropEnabled,
      collisionDetector: pointerIntersection2,
      type: "dropzone",
      data: {
        areaId,
        depth,
        isDroppableTarget: acceptsTarget(draggedComponentType),
        path
      }
    };
    const { ref: dropRef } = useDroppableSafe(droppableConfig);
    const selectedItem = itemSelector ? getItem(itemSelector, data) : null;
    const isAreaSelected = selectedItem && areaId === selectedItem.props.id;
    const [dragAxis] = useDragAxis(ref, collisionAxis);
    const [minEmptyHeight, isAnimating] = useMinEmptyHeight({
      zoneCompound,
      userMinEmptyHeight,
      ref
    });
    return (0, import_jsx_runtime24.jsx)(
      "div",
      {
        className: `${getClassName17({
          isRootZone,
          userIsDragging,
          hoveringOverArea,
          isEnabled,
          isAreaSelected,
          hasChildren: content.length > 0,
          isActive: activeZones == null ? void 0 : activeZones[zoneCompound],
          isAnimating
        })}${className ? ` ${className}` : ""}`,
        ref: (node) => {
          assignRefs([ref, dropRef, userRef], node);
        },
        "data-testid": `dropzone:${zoneCompound}`,
        "data-puck-dropzone": zoneCompound,
        style: __spreadProps(__spreadValues({}, style), {
          "--min-empty-height": `${minEmptyHeight}px`,
          backgroundColor: RENDER_DEBUG ? getRandomColor() : style == null ? void 0 : style.backgroundColor
        }),
        children: contentWithPreview.map((item, i2) => {
          var _a3, _b2, _c4, _d2, _e, _f, _g;
          const componentId = item.props.id;
          const puckProps = {
            renderDropZone: DropZoneEditPure,
            isEditing: true,
            dragRef: null
          };
          const defaultedProps = __spreadProps(__spreadValues(__spreadValues({}, (_a3 = config.components[item.type]) == null ? void 0 : _a3.defaultProps), item.props), {
            puck: puckProps,
            editMode: true
            // DEPRECATED
          });
          const isSelected = (selectedItem == null ? void 0 : selectedItem.props.id) === componentId || false;
          let Render2 = config.components[item.type] && item.type !== "preview" ? config.components[item.type].render : () => (0, import_jsx_runtime24.jsxs)("div", { style: { padding: 48, textAlign: "center" }, children: [
            "No configuration for ",
            item.type
          ] });
          const componentConfig = config.components[item.type];
          let componentType = item.type;
          let label = (_b2 = componentConfig == null ? void 0 : componentConfig["label"]) != null ? _b2 : item.type.toString();
          if (item.type === "preview") {
            let Preview4 = function() {
              return (0, import_jsx_runtime24.jsx)(DrawerItemInner, { name: label, children: appContext2.overrides.componentItem });
            };
            var Preview3 = Preview4;
            componentType = (_c4 = preview == null ? void 0 : preview.componentType) != null ? _c4 : "__preview";
            label = (_f = (_e = (_d2 = config.components[componentType]) == null ? void 0 : _d2.label) != null ? _e : componentType) != null ? _f : "Preview";
            Render2 = Preview4;
          }
          return (0, import_jsx_runtime24.jsx)(
            DropZoneProvider,
            {
              value: __spreadProps(__spreadValues({}, ctx), { path: [...path, zoneCompound] }),
              children: (0, import_jsx_runtime24.jsx)(
                DraggableComponent,
                {
                  id: componentId,
                  componentType,
                  zoneCompound,
                  depth: depth + 1,
                  index: i2,
                  isLoading: ((_g = appContext2.componentState[componentId]) == null ? void 0 : _g.loadingCount) > 0,
                  isSelected,
                  label,
                  isEnabled,
                  autoDragAxis: dragAxis,
                  userDragAxis: collisionAxis,
                  inDroppableZone: acceptsTarget(draggedComponentType),
                  children: (dragRef) => (componentConfig == null ? void 0 : componentConfig.inline) ? (0, import_jsx_runtime24.jsx)(
                    Render2,
                    __spreadProps(__spreadValues({}, defaultedProps), {
                      puck: __spreadProps(__spreadValues({}, defaultedProps.puck), {
                        dragRef
                      })
                    })
                  ) : (0, import_jsx_runtime24.jsx)("div", { ref: dragRef, children: (0, import_jsx_runtime24.jsx)(Render2, __spreadValues({}, defaultedProps)) })
                }
              )
            },
            componentId
          );
        })
      }
    );
  }
);
var DropZoneRenderPure = (props) => (0, import_jsx_runtime24.jsx)(DropZoneRender, __spreadValues({}, props));
var DropZoneRender = (0, import_react33.forwardRef)(
  function DropZoneRenderInternal({ className, style, zone }, ref) {
    const ctx = (0, import_react33.useContext)(dropZoneContext);
    const { data, areaId = "root", config } = ctx || {};
    let zoneCompound = rootDroppableId;
    let content = (data == null ? void 0 : data.content) || [];
    (0, import_react33.useEffect)(() => {
      if (ctx == null ? void 0 : ctx.registerZone) {
        ctx == null ? void 0 : ctx.registerZone(zoneCompound);
      }
      return () => {
        if (ctx == null ? void 0 : ctx.unregisterZone) {
          ctx == null ? void 0 : ctx.unregisterZone(zoneCompound);
        }
      };
    }, []);
    if (!data || !config) {
      return null;
    }
    if (areaId && zone && zone !== rootDroppableId) {
      zoneCompound = `${areaId}:${zone}`;
      content = setupZone(data, zoneCompound).zones[zoneCompound];
    }
    return (0, import_jsx_runtime24.jsx)("div", { className, style, ref, children: content.map((item) => {
      const Component = config.components[item.type];
      if (Component) {
        return (0, import_jsx_runtime24.jsx)(
          DropZoneProvider,
          {
            value: {
              data,
              config,
              areaId: item.props.id,
              depth: 1,
              path: []
            },
            children: (0, import_jsx_runtime24.jsx)(
              Component.render,
              __spreadProps(__spreadValues({}, item.props), {
                puck: {
                  renderDropZone: DropZoneRenderPure
                }
              })
            )
          },
          item.props.id
        );
      }
      return null;
    }) });
  }
);
var DropZonePure = (props) => (0, import_jsx_runtime24.jsx)(DropZone, __spreadValues({}, props));
var DropZone = (0, import_react33.forwardRef)(
  function DropZone2(props, ref) {
    const ctx = (0, import_react33.useContext)(dropZoneContext);
    if ((ctx == null ? void 0 : ctx.mode) === "edit") {
      return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: (0, import_jsx_runtime24.jsx)(DropZoneEdit, __spreadProps(__spreadValues({}, props), { ref })) });
    }
    return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: (0, import_jsx_runtime24.jsx)(DropZoneRender, __spreadProps(__spreadValues({}, props), { ref })) });
  }
);
init_react_import();
var getZoneId = (zoneCompound) => {
  if (!zoneCompound) {
    return [];
  }
  if (zoneCompound && zoneCompound.indexOf(":") > -1) {
    return zoneCompound.split(":");
  }
  return [rootDroppableId, zoneCompound];
};
init_react_import();
init_react_import();
function timeout22(callback, duration) {
  const id = setTimeout(callback, duration);
  return () => clearTimeout(id);
}
function throttle2(func, limit) {
  const time = () => performance.now();
  let cancel;
  let lastRan = 0;
  return function(...args) {
    const now = time();
    const context = this;
    if (now - lastRan >= limit) {
      func.apply(context, args);
      lastRan = now;
    } else {
      cancel == null ? void 0 : cancel();
      cancel = timeout22(() => {
        func.apply(context, args);
        lastRan = time();
      }, limit - (now - lastRan));
    }
  };
}
init_react_import();
var getFrame = () => {
  if (typeof window === "undefined") return;
  let frameEl = document.querySelector("#preview-frame");
  if ((frameEl == null ? void 0 : frameEl.tagName) === "IFRAME") {
    return frameEl.contentDocument || document;
  }
  return (frameEl == null ? void 0 : frameEl.ownerDocument) || document;
};
init_react_import();
var GlobalPosition = class {
  constructor(target, original) {
    this.scaleFactor = 1;
    this.frameEl = null;
    this.frameRect = null;
    var _a3;
    this.target = target;
    this.original = original;
    this.frameEl = document.querySelector("iframe");
    if (this.frameEl) {
      this.frameRect = this.frameEl.getBoundingClientRect();
      this.scaleFactor = this.frameRect.width / (((_a3 = this.frameEl.contentWindow) == null ? void 0 : _a3.innerWidth) || 1);
    }
  }
  get x() {
    return this.original.x;
  }
  get y() {
    return this.original.y;
  }
  get global() {
    if (document !== this.target.ownerDocument && this.frameRect) {
      return {
        x: this.x * this.scaleFactor + this.frameRect.left,
        y: this.y * this.scaleFactor + this.frameRect.top
      };
    }
    return this.original;
  }
  get frame() {
    if (document === this.target.ownerDocument && this.frameRect) {
      return {
        x: (this.x - this.frameRect.left) / this.scaleFactor,
        y: (this.y - this.frameRect.top) / this.scaleFactor
      };
    }
    return this.original;
  }
};
init_react_import();
var BaseEvent = typeof PointerEvent !== "undefined" ? PointerEvent : Event;
var BubbledPointerEvent = class extends BaseEvent {
  constructor(type, data) {
    super(type, data);
    this._originalTarget = null;
    this.originalTarget = data.originalTarget;
  }
  // Necessary for Firefox
  set originalTarget(target) {
    this._originalTarget = target;
  }
  // Necessary for Firefox
  get originalTarget() {
    return this._originalTarget;
  }
};
var depthSort = (candidates) => {
  return candidates.sort((a2, b2) => {
    const aData = a2.data;
    const bData = b2.data;
    if (aData.depth > bData.depth) {
      return 1;
    }
    if (bData.depth > aData.depth) {
      return -1;
    }
    return 0;
  });
};
var getZoneId2 = (candidate) => {
  let id = candidate == null ? void 0 : candidate.id;
  if (!candidate) return null;
  if (candidate.type === "component") {
    const data = candidate.data;
    if (data.containsActiveZone) {
      id = null;
    } else {
      id = data.zone;
    }
  } else if (candidate.type === "void") {
    return "void";
  }
  return id;
};
var getPointerCollisions = (position, manager) => {
  const candidates = [];
  let elements = position.target.ownerDocument.elementsFromPoint(
    position.x,
    position.y
  );
  const previewFrame = elements.find(
    (el) => el.getAttribute("data-puck-preview")
  );
  const drawer = elements.find((el) => el.getAttribute("data-puck-drawer"));
  if (drawer) {
    elements = [drawer];
  }
  if (previewFrame) {
    const frame = getFrame();
    if (frame) {
      elements = frame.elementsFromPoint(position.frame.x, position.frame.y);
    }
  }
  if (elements) {
    for (let i2 = 0; i2 < elements.length; i2++) {
      const element = elements[i2];
      const dropzoneId = element.getAttribute("data-puck-dropzone");
      if (dropzoneId) {
        const droppable = manager.registry.droppables.get(dropzoneId);
        if (droppable) {
          candidates.push(droppable);
        }
      }
      const id = element.getAttribute("data-puck-dnd");
      if (id) {
        const droppable = manager.registry.droppables.get(id);
        if (droppable) {
          candidates.push(droppable);
        }
      }
    }
  }
  return candidates;
};
var findDeepestCandidate = (position, manager) => {
  var _a3;
  const candidates = getPointerCollisions(position, manager);
  if (candidates.length > 0) {
    const sortedCandidates = depthSort(candidates);
    const draggable = manager.dragOperation.source;
    const draggedCandidateIndex = sortedCandidates.findIndex(
      (candidate) => candidate.id === (draggable == null ? void 0 : draggable.id)
    );
    const draggedCandidateId = draggable == null ? void 0 : draggable.id;
    let filteredCandidates = [...sortedCandidates];
    if (draggedCandidateId && draggedCandidateIndex > -1) {
      filteredCandidates.splice(draggedCandidateIndex, 1);
    }
    filteredCandidates = filteredCandidates.filter((candidate) => {
      const candidateData = candidate.data;
      if (draggedCandidateId && draggedCandidateIndex > -1) {
        if (candidateData.path.indexOf(draggedCandidateId) > -1) {
          return false;
        }
      }
      if (candidate.type === "dropzone") {
        const candidateData2 = candidate.data;
        if (!candidateData2.isDroppableTarget) {
          return false;
        }
        if (candidateData2.areaId === draggedCandidateId) {
          return false;
        }
      } else if (candidate.type === "component") {
        const candidateData2 = candidate.data;
        if (!candidateData2.inDroppableZone) {
          return false;
        }
      }
      return true;
    });
    filteredCandidates.reverse();
    const zone = getZoneId2(filteredCandidates[0]);
    const area = (_a3 = filteredCandidates[0]) == null ? void 0 : _a3.data.areaId;
    return { zone, area };
  }
  return {
    zone: "default-zone",
    area: null
  };
};
var createNestedDroppablePlugin = ({ onChange }, id) => class NestedDroppablePlugin extends Plugin {
  constructor(manager, options2) {
    super(manager);
    if (typeof window === "undefined") {
      return;
    }
    const cleanupEffect = effects(() => {
      const handleMove = (event) => {
        const target = event instanceof BubbledPointerEvent ? event.originalTarget || event.target : event.target;
        const position = new GlobalPosition(target, {
          x: event.clientX,
          y: event.clientY
        });
        const elements = document.elementsFromPoint(
          position.global.x,
          position.global.y
        );
        const overEl = elements.some((el) => el.id === id);
        if (overEl) {
          onChange(findDeepestCandidate(position, manager), manager);
        }
      };
      const handleMoveThrottled = throttle2(handleMove, 50);
      const handlePointerMove = (event) => {
        handleMoveThrottled(event);
      };
      document.body.addEventListener("pointermove", handlePointerMove, {
        capture: true
        // dndkit's PointerSensor prevents propagation during drag
      });
      this.destroy = () => {
        document.body.removeEventListener("pointermove", handlePointerMove, {
          capture: true
        });
        cleanupEffect();
      };
    });
  }
};
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var remove = (list, index) => {
  const result = Array.from(list);
  result.splice(index, 1);
  return result;
};
init_react_import();
function reduceRelatedZones(item, data, fn) {
  return __spreadProps(__spreadValues({}, data), {
    zones: Object.keys(data.zones || {}).reduce(
      (acc, key) => {
        const [parentId] = getZoneId(key);
        if (parentId === item.props.id) {
          const zones = data.zones;
          return fn(acc, key, zones[key]);
        }
        return __spreadProps(__spreadValues({}, acc), { [key]: data.zones[key] });
      },
      {}
    )
  });
}
var findRelatedByZoneId = (zoneId, data) => {
  const [zoneParentId] = getZoneId(zoneId);
  return (data.zones[zoneId] || []).reduce(
    (acc, zoneItem) => {
      const related = findRelatedByItem(zoneItem, data);
      if (zoneItem.props.id === zoneParentId) {
        return __spreadProps(__spreadValues(__spreadValues({}, acc), related), { [zoneId]: zoneItem });
      }
      return __spreadValues(__spreadValues({}, acc), related);
    },
    {}
  );
};
var findRelatedByItem = (item, data) => {
  return Object.keys(data.zones || {}).reduce(
    (acc, zoneId) => {
      const [zoneParentId] = getZoneId(zoneId);
      if (item.props.id === zoneParentId) {
        const related = findRelatedByZoneId(zoneId, data);
        return __spreadProps(__spreadValues(__spreadValues({}, acc), related), {
          [zoneId]: data.zones[zoneId]
        });
      }
      return acc;
    },
    {}
  );
};
var removeRelatedZones = (item, data) => {
  const newData = __spreadValues({}, data);
  const related = findRelatedByItem(item, data);
  Object.keys(related).forEach((key) => {
    delete newData.zones[key];
  });
  return newData;
};
function duplicateRelatedZones(item, data, newId) {
  return reduceRelatedZones(item, data, (acc, key, zone) => {
    const dupedZone = zone.map((zoneItem) => __spreadProps(__spreadValues({}, zoneItem), {
      props: __spreadProps(__spreadValues({}, zoneItem.props), { id: generateId(zoneItem.type) })
    }));
    const dupeOfDupes = dupedZone.reduce(
      (dupeOfDupes2, item2, index) => __spreadValues(__spreadValues({}, dupeOfDupes2), duplicateRelatedZones(zone[index], data, item2.props.id).zones),
      acc
    );
    const [_2, zoneId] = getZoneId(key);
    return __spreadProps(__spreadValues({}, dupeOfDupes), {
      [key]: zone,
      [`${newId}:${zoneId}`]: dupedZone
    });
  });
}
var zoneCache = {};
var addToZoneCache = (key, data) => {
  zoneCache[key] = data;
};
var replaceAction = (data, action) => {
  if (action.destinationZone === rootDroppableId) {
    return __spreadProps(__spreadValues({}, data), {
      content: replace(data.content, action.destinationIndex, action.data)
    });
  }
  const newData = setupZone(data, action.destinationZone);
  return __spreadProps(__spreadValues({}, newData), {
    zones: __spreadProps(__spreadValues({}, newData.zones), {
      [action.destinationZone]: replace(
        newData.zones[action.destinationZone],
        action.destinationIndex,
        action.data
      )
    })
  });
};
function insertAction(data, action, config) {
  const emptyComponentData = {
    type: action.componentType,
    props: __spreadProps(__spreadValues({}, config.components[action.componentType].defaultProps || {}), {
      id: action.id || generateId(action.componentType)
    })
  };
  if (action.destinationZone === rootDroppableId) {
    return __spreadProps(__spreadValues({}, data), {
      content: insert(
        data.content,
        action.destinationIndex,
        emptyComponentData
      )
    });
  }
  const newData = setupZone(data, action.destinationZone);
  return __spreadProps(__spreadValues({}, data), {
    zones: __spreadProps(__spreadValues({}, newData.zones), {
      [action.destinationZone]: insert(
        newData.zones[action.destinationZone],
        action.destinationIndex,
        emptyComponentData
      )
    })
  });
}
var reorderAction = (data, action) => {
  if (action.destinationZone === rootDroppableId) {
    return __spreadProps(__spreadValues({}, data), {
      content: reorder2(
        data.content,
        action.sourceIndex,
        action.destinationIndex
      )
    });
  }
  const newData = setupZone(data, action.destinationZone);
  return __spreadProps(__spreadValues({}, data), {
    zones: __spreadProps(__spreadValues({}, newData.zones), {
      [action.destinationZone]: reorder2(
        newData.zones[action.destinationZone],
        action.sourceIndex,
        action.destinationIndex
      )
    })
  });
};
function reduceData(data, action, config) {
  if (action.type === "insert") {
    return insertAction(data, action, config);
  }
  if (action.type === "duplicate") {
    const item = getItem(
      { index: action.sourceIndex, zone: action.sourceZone },
      data
    );
    const newItem = __spreadProps(__spreadValues({}, item), {
      props: __spreadProps(__spreadValues({}, item.props), {
        id: generateId(item.type)
      })
    });
    const dataWithRelatedDuplicated = duplicateRelatedZones(
      item,
      data,
      newItem.props.id
    );
    if (action.sourceZone === rootDroppableId) {
      return __spreadProps(__spreadValues({}, dataWithRelatedDuplicated), {
        content: insert(data.content, action.sourceIndex + 1, newItem)
      });
    }
    return __spreadProps(__spreadValues({}, dataWithRelatedDuplicated), {
      zones: __spreadProps(__spreadValues({}, dataWithRelatedDuplicated.zones), {
        [action.sourceZone]: insert(
          dataWithRelatedDuplicated.zones[action.sourceZone],
          action.sourceIndex + 1,
          newItem
        )
      })
    });
  }
  if (action.type === "reorder") {
    return reorderAction(data, action);
  }
  if (action.type === "move") {
    if (action.sourceZone === action.destinationZone && action.sourceIndex === action.destinationIndex) {
      return data;
    }
    const newData = setupZone(
      setupZone(data, action.sourceZone),
      action.destinationZone
    );
    const item = getItem(
      { zone: action.sourceZone, index: action.sourceIndex },
      newData
    );
    if (action.sourceZone === action.destinationZone) {
      return reorderAction(data, __spreadProps(__spreadValues({}, action), { type: "reorder" }));
    }
    if (action.sourceZone === rootDroppableId) {
      return __spreadProps(__spreadValues({}, newData), {
        content: remove(newData.content, action.sourceIndex),
        zones: __spreadProps(__spreadValues({}, newData.zones), {
          [action.destinationZone]: insert(
            newData.zones[action.destinationZone],
            action.destinationIndex,
            item
          )
        })
      });
    }
    if (action.destinationZone === rootDroppableId) {
      return __spreadProps(__spreadValues({}, newData), {
        content: insert(newData.content, action.destinationIndex, item),
        zones: __spreadProps(__spreadValues({}, newData.zones), {
          [action.sourceZone]: remove(
            newData.zones[action.sourceZone],
            action.sourceIndex
          )
        })
      });
    }
    return __spreadProps(__spreadValues({}, newData), {
      zones: __spreadProps(__spreadValues({}, newData.zones), {
        [action.sourceZone]: remove(
          newData.zones[action.sourceZone],
          action.sourceIndex
        ),
        [action.destinationZone]: insert(
          newData.zones[action.destinationZone],
          action.destinationIndex,
          item
        )
      })
    });
  }
  if (action.type === "replace") {
    return replaceAction(data, action);
  }
  if (action.type === "remove") {
    const item = getItem({ index: action.index, zone: action.zone }, data);
    const dataWithRelatedRemoved = setupZone(
      removeRelatedZones(item, data),
      action.zone
    );
    if (action.zone === rootDroppableId) {
      return __spreadProps(__spreadValues({}, dataWithRelatedRemoved), {
        content: remove(data.content, action.index)
      });
    }
    return __spreadProps(__spreadValues({}, dataWithRelatedRemoved), {
      zones: __spreadProps(__spreadValues({}, dataWithRelatedRemoved.zones), {
        [action.zone]: remove(
          dataWithRelatedRemoved.zones[action.zone],
          action.index
        )
      })
    });
  }
  if (action.type === "registerZone") {
    if (zoneCache[action.zone]) {
      return __spreadProps(__spreadValues({}, data), {
        zones: __spreadProps(__spreadValues({}, data.zones), {
          [action.zone]: zoneCache[action.zone]
        })
      });
    }
    return setupZone(data, action.zone);
  }
  if (action.type === "unregisterZone") {
    const _zones = __spreadValues({}, data.zones || {});
    if (_zones[action.zone]) {
      zoneCache[action.zone] = _zones[action.zone];
      delete _zones[action.zone];
    }
    return __spreadProps(__spreadValues({}, data), { zones: _zones });
  }
  if (action.type === "setData") {
    if (typeof action.data === "object") {
      return __spreadValues(__spreadValues({}, data), action.data);
    }
    return __spreadValues(__spreadValues({}, data), action.data(data));
  }
  return data;
}
init_react_import();
var reduceUi = (ui, action) => {
  if (action.type === "setUi") {
    if (typeof action.ui === "object") {
      return __spreadValues(__spreadValues({}, ui), action.ui);
    }
    return __spreadValues(__spreadValues({}, ui), action.ui(ui));
  }
  if (action.type === "duplicate") {
    return __spreadProps(__spreadValues({}, ui), {
      itemSelector: { index: action.sourceIndex + 1, zone: action.sourceZone }
    });
  }
  if (action.type === "remove") {
    return __spreadProps(__spreadValues({}, ui), {
      itemSelector: null
    });
  }
  return ui;
};
init_react_import();
function storeInterceptor(reducer, record, onAction) {
  return (state, action) => {
    const newAppState = reducer(state, action);
    const isValidType = ![
      "registerZone",
      "unregisterZone",
      "setData",
      "setUi",
      "set"
    ].includes(action.type);
    if (typeof action.recordHistory !== "undefined" ? action.recordHistory : isValidType) {
      if (record) record(newAppState);
    }
    onAction == null ? void 0 : onAction(action, newAppState, state);
    return newAppState;
  };
}
var setAction = (state, action) => {
  if (typeof action.state === "object") {
    return __spreadValues(__spreadValues({}, state), action.state);
  }
  return __spreadValues(__spreadValues({}, state), action.state(state));
};
function createReducer({
  config,
  record,
  onAction
}) {
  return storeInterceptor(
    (state, action) => {
      const data = reduceData(state.data, action, config);
      const ui = reduceUi(state.ui, action);
      if (action.type === "set") {
        return setAction(state, action);
      }
      return { data, ui };
    },
    record,
    onAction
  );
}
var insertComponent = (componentType, zone, index, {
  config,
  dispatch,
  resolveData,
  state
}) => {
  const id = generateId(componentType);
  const insertActionData = {
    type: "insert",
    componentType,
    destinationIndex: index,
    destinationZone: zone,
    id
  };
  const insertedData = insertAction(state.data, insertActionData, config);
  dispatch(__spreadProps(__spreadValues({}, insertActionData), {
    // Dispatch insert rather set, as user's may rely on this via onAction
    // We must always record history here so the insert is added to user history
    // If the user has defined a resolveData method, they will end up with 2 history
    // entries on insert - one for the initial insert, and one when the data resolves
    recordHistory: true
  }));
  const itemSelector = {
    index,
    zone
  };
  dispatch({ type: "setUi", ui: { itemSelector } });
  resolveData({
    data: insertedData,
    ui: __spreadProps(__spreadValues({}, state.ui), { itemSelector })
  });
};
init_react_import();
function getDeepDir(el) {
  function findDir(node) {
    if (!node) return "ltr";
    const d2 = node.getAttribute("dir");
    return d2 || findDir(node.parentElement);
  }
  return el ? findDir(el) : "ltr";
}
var DEBUG3 = false;
var dragListenerContext = (0, import_react32.createContext)({
  dragListeners: {}
});
function useDragListener(type, fn, deps = []) {
  const { setDragListeners } = (0, import_react32.useContext)(dragListenerContext);
  (0, import_react32.useEffect)(() => {
    if (setDragListeners) {
      setDragListeners((old) => __spreadProps(__spreadValues({}, old), {
        [type]: [...old[type] || [], fn]
      }));
    }
  }, deps);
}
var AREA_CHANGE_DEBOUNCE_MS = 100;
var useTempDisableFallback = (timeout3) => {
  const lastFallbackDisable = (0, import_react32.useRef)(null);
  return (0, import_react32.useCallback)((manager) => {
    collisionStore.setState({ fallbackEnabled: false });
    const fallbackId = generateId();
    lastFallbackDisable.current = fallbackId;
    setTimeout(() => {
      if (lastFallbackDisable.current === fallbackId) {
        collisionStore.setState({ fallbackEnabled: true });
        manager.collisionObserver.forceUpdate(true);
      }
    }, timeout3);
  }, []);
};
var DragDropContextClient = ({
  children,
  disableAutoScroll
}) => {
  const { state, config, dispatch, resolveData } = useAppContext();
  const id = (0, import_react32.useId)();
  const { data } = state;
  const debouncedParamsRef = (0, import_react32.useRef)(null);
  const tempDisableFallback = useTempDisableFallback(100);
  const [zoneStore] = (0, import_react32.useState)(
    () => createStore(() => ({
      zoneDepthIndex: {},
      nextZoneDepthIndex: {},
      areaDepthIndex: {},
      nextAreaDepthIndex: {},
      draggedItem: null,
      previewIndex: {}
    }))
  );
  const getChanged2 = (0, import_react32.useCallback)(
    (params, id2) => {
      const { zoneDepthIndex = {}, areaDepthIndex = {} } = zoneStore.getState() || {};
      const stateHasZone = Object.keys(zoneDepthIndex).length > 0;
      const stateHasArea = Object.keys(areaDepthIndex).length > 0;
      let zoneChanged = false;
      let areaChanged = false;
      if (params.zone && !zoneDepthIndex[params.zone]) {
        zoneChanged = true;
      } else if (!params.zone && stateHasZone) {
        zoneChanged = true;
      }
      if (params.area && !areaDepthIndex[params.area]) {
        areaChanged = true;
      } else if (!params.area && stateHasArea) {
        areaChanged = true;
      }
      return { zoneChanged, areaChanged };
    },
    [zoneStore]
  );
  const setDeepestAndCollide = (0, import_react32.useCallback)(
    (params, manager) => {
      const { zoneChanged, areaChanged } = getChanged2(params, id);
      if (!zoneChanged && !areaChanged) return;
      zoneStore.setState({
        zoneDepthIndex: params.zone ? { [params.zone]: true } : {},
        areaDepthIndex: params.area ? { [params.area]: true } : {}
      });
      tempDisableFallback(manager);
      setTimeout(() => {
        manager.collisionObserver.forceUpdate(true);
      }, 50);
      debouncedParamsRef.current = null;
    },
    [zoneStore]
  );
  const setDeepestDb = c2(
    setDeepestAndCollide,
    AREA_CHANGE_DEBOUNCE_MS
  );
  const cancelDb = () => {
    setDeepestDb.cancel();
    debouncedParamsRef.current = null;
  };
  (0, import_react32.useEffect)(() => {
    if (DEBUG3) {
      zoneStore.subscribe(
        (s2) => {
          var _a3, _b2;
          return console.log(
            s2.previewIndex,
            (_a3 = Object.entries(s2.zoneDepthIndex || {})[0]) == null ? void 0 : _a3[0],
            (_b2 = Object.entries(s2.areaDepthIndex || {})[0]) == null ? void 0 : _b2[0]
          );
        }
      );
    }
  }, []);
  const [plugins] = (0, import_react32.useState)(() => [
    ...disableAutoScroll ? defaultPreset.plugins.filter((plugin) => plugin !== AutoScroller) : defaultPreset.plugins,
    createNestedDroppablePlugin(
      {
        onChange: (params, manager) => {
          const state2 = zoneStore.getState();
          const { zoneChanged, areaChanged } = getChanged2(params, id);
          const isDragging = manager.dragOperation.status.dragging;
          if (areaChanged || zoneChanged) {
            let nextZoneDepthIndex = {};
            let nextAreaDepthIndex = {};
            if (params.zone) {
              nextZoneDepthIndex = { [params.zone]: true };
            }
            if (params.area) {
              nextAreaDepthIndex = { [params.area]: true };
            }
            zoneStore.setState({ nextZoneDepthIndex, nextAreaDepthIndex });
          }
          if (params.zone !== "void" && (state2 == null ? void 0 : state2.zoneDepthIndex["void"])) {
            setDeepestAndCollide(params, manager);
            return;
          }
          if (areaChanged) {
            if (isDragging) {
              const debouncedParams = debouncedParamsRef.current;
              const isSameParams = debouncedParams && debouncedParams.area === params.area && debouncedParams.zone === params.zone;
              if (!isSameParams) {
                cancelDb();
                setDeepestDb(params, manager);
                debouncedParamsRef.current = params;
              }
            } else {
              cancelDb();
              setDeepestAndCollide(params, manager);
            }
            return;
          }
          if (zoneChanged) {
            setDeepestAndCollide(params, manager);
          }
          cancelDb();
        }
      },
      id
    )
  ]);
  const sensors = useSensors();
  const [dragListeners, setDragListeners] = (0, import_react32.useState)({});
  const [pathData, setPathData] = (0, import_react32.useState)();
  const dragMode = (0, import_react32.useRef)(null);
  const registerPath = (0, import_react32.useCallback)(
    (id2, selector, label) => {
      const [area] = getZoneId(selector.zone);
      setPathData((latestPathData = {}) => {
        const parentPathData = latestPathData[area] || { path: [] };
        return __spreadProps(__spreadValues({}, latestPathData), {
          [id2]: {
            path: [
              ...parentPathData.path,
              ...selector.zone ? [selector.zone] : []
            ],
            label
          }
        });
      });
    },
    [data, setPathData]
  );
  const unregisterPath = (0, import_react32.useCallback)(
    (id2) => {
      setPathData((latestPathData = {}) => {
        const newPathData = __spreadValues({}, latestPathData);
        delete newPathData[id2];
        return newPathData;
      });
    },
    [data, setPathData]
  );
  const initialSelector = (0, import_react32.useRef)(void 0);
  return (0, import_jsx_runtime25.jsx)("div", { id, children: (0, import_jsx_runtime25.jsx)(
    dragListenerContext.Provider,
    {
      value: {
        dragListeners,
        setDragListeners
      },
      children: (0, import_jsx_runtime25.jsx)(
        DragDropProvider,
        {
          plugins,
          sensors,
          onDragEnd: (event, manager) => {
            var _a3;
            const { source, target } = event.operation;
            if (!source) {
              zoneStore.setState({ draggedItem: null });
              return;
            }
            const { zone, index } = source.data;
            const { previewIndex = {} } = zoneStore.getState() || {};
            const thisPreview = ((_a3 = previewIndex[zone]) == null ? void 0 : _a3.props.id) === source.id ? previewIndex[zone] : null;
            setTimeout(() => {
              var _a22, _b2;
              zoneStore.setState({ draggedItem: null });
              if (event.canceled || (target == null ? void 0 : target.type) === "void") {
                zoneStore.setState({ previewIndex: {} });
                (_a22 = dragListeners.dragend) == null ? void 0 : _a22.forEach((fn) => {
                  fn(event, manager);
                });
                dispatch({
                  type: "setUi",
                  ui: {
                    itemSelector: null,
                    isDragging: false
                  }
                });
                return;
              }
              if (thisPreview) {
                zoneStore.setState({ previewIndex: {} });
                if (thisPreview.type === "insert") {
                  insertComponent(
                    thisPreview.componentType,
                    thisPreview.zone,
                    thisPreview.index,
                    { config, dispatch, resolveData, state }
                  );
                } else if (initialSelector.current) {
                  dispatch({
                    type: "move",
                    sourceIndex: initialSelector.current.index,
                    sourceZone: initialSelector.current.zone,
                    destinationIndex: thisPreview.index,
                    destinationZone: thisPreview.zone,
                    recordHistory: false
                  });
                }
              }
              setTimeout(() => {
                dispatch({
                  type: "setUi",
                  ui: {
                    itemSelector: { index, zone },
                    isDragging: false
                  },
                  recordHistory: true
                });
              }, 50);
              (_b2 = dragListeners.dragend) == null ? void 0 : _b2.forEach((fn) => {
                fn(event, manager);
              });
            }, 250);
          },
          onDragOver: (event, manager) => {
            var _a3, _b2, _c4, _d2, _e;
            event.preventDefault();
            const draggedItem = (_a3 = zoneStore.getState()) == null ? void 0 : _a3.draggedItem;
            if (!draggedItem) return;
            cancelDb();
            const { source, target } = event.operation;
            if (!target || !source || target.type === "void") return;
            const [sourceId] = source.id.split(":");
            const [targetId] = target.id.split(":");
            const sourceData = source.data;
            let sourceZone = sourceData.zone;
            let sourceIndex = sourceData.index;
            let targetZone = "";
            let targetIndex = 0;
            if (target.type === "component") {
              const targetData = target.data;
              targetZone = targetData.zone;
              targetIndex = targetData.index;
              const collisionData = (_c4 = (_b2 = manager.dragOperation.data) == null ? void 0 : _b2.collisionMap) == null ? void 0 : _c4[targetId];
              const dir = getDeepDir(target.element);
              const collisionPosition = (collisionData == null ? void 0 : collisionData.direction) === "up" || dir === "ltr" && (collisionData == null ? void 0 : collisionData.direction) === "left" || dir === "rtl" && (collisionData == null ? void 0 : collisionData.direction) === "right" ? "before" : "after";
              if (targetIndex >= sourceIndex && sourceZone === targetZone) {
                targetIndex = targetIndex - 1;
              }
              if (collisionPosition === "after") {
                targetIndex = targetIndex + 1;
              }
            } else {
              targetZone = target.id.toString();
              targetIndex = 0;
            }
            if (targetId === sourceId || ((_d2 = pathData == null ? void 0 : pathData[target.id]) == null ? void 0 : _d2.path.find((path) => {
              const [pathId] = path.split(":");
              return pathId === sourceId;
            }))) {
              return;
            }
            if (dragMode.current === "new") {
              zoneStore.setState({
                previewIndex: {
                  [targetZone]: {
                    componentType: sourceData.componentType,
                    type: "insert",
                    index: targetIndex,
                    zone: targetZone,
                    props: {
                      id: source.id.toString()
                    }
                  }
                }
              });
            } else {
              if (!initialSelector.current) {
                initialSelector.current = {
                  zone: sourceData.zone,
                  index: sourceData.index
                };
              }
              const item = getItem(initialSelector.current, data);
              if (item) {
                zoneStore.setState({
                  previewIndex: {
                    [targetZone]: {
                      componentType: sourceData.componentType,
                      type: "move",
                      index: targetIndex,
                      zone: targetZone,
                      props: item.props
                    }
                  }
                });
              }
            }
            (_e = dragListeners.dragover) == null ? void 0 : _e.forEach((fn) => {
              fn(event, manager);
            });
          },
          onDragStart: (event, manager) => {
            var _a3;
            dispatch({
              type: "setUi",
              ui: { itemSelector: null, isDragging: true }
            });
            const { source } = event.operation;
            if (source && source.type !== "void") {
              const sourceData = source.data;
              const item = getItem(
                {
                  zone: sourceData.zone,
                  index: sourceData.index
                },
                data
              );
              if (item) {
                zoneStore.setState({
                  previewIndex: {
                    [sourceData.zone]: {
                      componentType: sourceData.componentType,
                      type: "move",
                      index: sourceData.index,
                      zone: sourceData.zone,
                      props: item.props
                    }
                  }
                });
              }
            }
            (_a3 = dragListeners.dragstart) == null ? void 0 : _a3.forEach((fn) => {
              fn(event, manager);
            });
          },
          onBeforeDragStart: (event) => {
            var _a3;
            const isNewComponent = ((_a3 = event.operation.source) == null ? void 0 : _a3.data.type) === "drawer";
            dragMode.current = isNewComponent ? "new" : "existing";
            initialSelector.current = void 0;
            zoneStore.setState({ draggedItem: event.operation.source });
          },
          children: (0, import_jsx_runtime25.jsx)(ZoneStoreProvider, { store: zoneStore, children: (0, import_jsx_runtime25.jsx)(
            DropZoneProvider,
            {
              value: {
                data,
                config,
                mode: "edit",
                areaId: "root",
                depth: 0,
                registerPath,
                unregisterPath,
                pathData,
                path: []
              },
              children
            }
          ) })
        }
      )
    }
  ) });
};
var DragDropContext2 = ({
  children,
  disableAutoScroll
}) => {
  const { status } = useAppContext();
  if (status === "LOADING") {
    return children;
  }
  return (0, import_jsx_runtime25.jsx)(DragDropContextClient, { disableAutoScroll, children });
};
var getClassName18 = get_class_name_factory_default("Drawer", styles_module_default10);
var getClassNameItem2 = get_class_name_factory_default("DrawerItem", styles_module_default10);
var DrawerItemInner = ({
  children,
  name,
  label,
  dragRef,
  isDragDisabled
}) => {
  const CustomInner = (0, import_react30.useMemo)(
    () => children || (({ children: children2 }) => (0, import_jsx_runtime26.jsx)("div", { className: getClassNameItem2("default"), children: children2 })),
    [children]
  );
  return (0, import_jsx_runtime26.jsx)(
    "div",
    {
      className: getClassNameItem2({ disabled: isDragDisabled }),
      ref: dragRef,
      onMouseDown: (e3) => e3.preventDefault(),
      "data-testid": dragRef ? `drawer-item:${name}` : "",
      "data-puck-drawer-item": true,
      children: (0, import_jsx_runtime26.jsx)(CustomInner, { name, children: (0, import_jsx_runtime26.jsx)("div", { className: getClassNameItem2("draggableWrapper"), children: (0, import_jsx_runtime26.jsxs)("div", { className: getClassNameItem2("draggable"), children: [
        (0, import_jsx_runtime26.jsx)("div", { className: getClassNameItem2("name"), children: label != null ? label : name }),
        (0, import_jsx_runtime26.jsx)("div", { className: getClassNameItem2("icon"), children: (0, import_jsx_runtime26.jsx)(DragIcon, {}) })
      ] }) }) })
    }
  );
};
var DrawerItemDraggable = ({
  children,
  name,
  label,
  id,
  isDragDisabled
}) => {
  const { ref } = useDraggableSafe({
    id,
    data: { type: "drawer", componentType: name },
    disabled: isDragDisabled
  });
  return (0, import_jsx_runtime26.jsxs)("div", { className: getClassName18("draggable"), children: [
    (0, import_jsx_runtime26.jsx)("div", { className: getClassName18("draggableBg"), children: (0, import_jsx_runtime26.jsx)(DrawerItemInner, { name, label, children }) }),
    (0, import_jsx_runtime26.jsx)("div", { className: getClassName18("draggableFg"), children: (0, import_jsx_runtime26.jsx)(
      DrawerItemInner,
      {
        name,
        label,
        dragRef: ref,
        isDragDisabled,
        children
      }
    ) })
  ] });
};
var DrawerItem = ({
  name,
  children,
  id,
  label,
  index,
  isDragDisabled
}) => {
  const resolvedId = id || name;
  const [dynamicId, setDynamicId] = (0, import_react30.useState)(generateId(resolvedId));
  if (typeof index !== "undefined") {
    console.error(
      "Warning: The `index` prop on Drawer.Item is deprecated and no longer required."
    );
  }
  useDragListener(
    "dragend",
    () => {
      setDynamicId(generateId(resolvedId));
    },
    [resolvedId]
  );
  return (0, import_jsx_runtime26.jsx)("div", { children: (0, import_jsx_runtime26.jsx)(
    DrawerItemDraggable,
    {
      name,
      label,
      id: dynamicId,
      isDragDisabled,
      children
    }
  ) }, dynamicId);
};
var Drawer = ({
  children,
  droppableId,
  direction
}) => {
  if (droppableId) {
    console.error(
      "Warning: The `droppableId` prop on Drawer is deprecated and no longer required."
    );
  }
  if (direction) {
    console.error(
      "Warning: The `direction` prop on Drawer is deprecated and no longer required to achieve multi-directional dragging."
    );
  }
  const id = (0, import_react30.useId)();
  const { ref } = useDroppableSafe({
    id,
    type: "void",
    collisionPriority: 0
    // Never collide with this, but we use it so NestedDroppablePlugin respects the Drawer
  });
  return (0, import_jsx_runtime26.jsx)(
    "div",
    {
      className: getClassName18(),
      ref,
      "data-puck-dnd": id,
      "data-puck-drawer": true,
      children
    }
  );
};
Drawer.Item = DrawerItem;
init_react_import();
init_react_import();
init_react_import();
var styles_module_default13 = { "SidebarSection": "_SidebarSection_8boj8_1", "SidebarSection-title": "_SidebarSection-title_8boj8_12", "SidebarSection--noBorderTop": "_SidebarSection--noBorderTop_8boj8_20", "SidebarSection-content": "_SidebarSection-content_8boj8_24", "SidebarSection--noPadding": "_SidebarSection--noPadding_8boj8_28", "SidebarSection-breadcrumbLabel": "_SidebarSection-breadcrumbLabel_8boj8_41", "SidebarSection-breadcrumbs": "_SidebarSection-breadcrumbs_8boj8_70", "SidebarSection-breadcrumb": "_SidebarSection-breadcrumb_8boj8_41", "SidebarSection-heading": "_SidebarSection-heading_8boj8_82", "SidebarSection-loadingOverlay": "_SidebarSection-loadingOverlay_8boj8_86" };
init_react_import();
var convertPathDataToBreadcrumbs = (selectedItem, pathData, data) => {
  const id = selectedItem ? selectedItem == null ? void 0 : selectedItem.props.id : "";
  const currentPathData = pathData && id && pathData[id] ? __spreadValues({}, pathData[id]) : { label: "Page", path: [] };
  if (!id) {
    return [];
  }
  return currentPathData == null ? void 0 : currentPathData.path.reduce((acc, zoneCompound) => {
    const [area] = getZoneId(zoneCompound);
    if (area === rootDroppableId) {
      return [
        {
          label: "Page",
          selector: null
        }
      ];
    }
    const parentZoneCompound = acc.length > 0 ? acc[acc.length - 1].zoneCompound : rootDroppableId;
    let parentZone = data.content;
    if (parentZoneCompound && parentZoneCompound !== rootDroppableId) {
      parentZone = data.zones[parentZoneCompound];
    }
    if (!parentZone) {
      return acc;
    }
    const itemIndex = parentZone.findIndex(
      (queryItem) => queryItem.props.id === area
    );
    const item = parentZone[itemIndex];
    if (!item) {
      return acc;
    }
    return [
      ...acc,
      {
        label: item.type.toString(),
        selector: {
          index: itemIndex,
          zone: parentZoneCompound
        },
        zoneCompound
      }
    ];
  }, []);
};
var useBreadcrumbs = (renderCount) => {
  const {
    state: { data },
    selectedItem
  } = useAppContext();
  const dzContext = (0, import_react43.useContext)(dropZoneContext);
  return (0, import_react43.useMemo)(() => {
    const breadcrumbs = convertPathDataToBreadcrumbs(
      selectedItem,
      dzContext == null ? void 0 : dzContext.pathData,
      data
    );
    if (renderCount) {
      return breadcrumbs.slice(breadcrumbs.length - renderCount);
    }
    return breadcrumbs;
  }, [selectedItem, dzContext == null ? void 0 : dzContext.pathData, renderCount]);
};
var getClassName19 = get_class_name_factory_default("SidebarSection", styles_module_default13);
var SidebarSection = ({
  children,
  title,
  background,
  showBreadcrumbs,
  noBorderTop,
  noPadding,
  isLoading
}) => {
  const { setUi } = useAppContext();
  const breadcrumbs = useBreadcrumbs(1);
  return (0, import_jsx_runtime27.jsxs)(
    "div",
    {
      className: getClassName19({ noBorderTop, noPadding }),
      style: { background },
      children: [
        (0, import_jsx_runtime27.jsx)("div", { className: getClassName19("title"), children: (0, import_jsx_runtime27.jsxs)("div", { className: getClassName19("breadcrumbs"), children: [
          showBreadcrumbs ? breadcrumbs.map((breadcrumb, i2) => (0, import_jsx_runtime27.jsxs)("div", { className: getClassName19("breadcrumb"), children: [
            (0, import_jsx_runtime27.jsx)(
              "button",
              {
                type: "button",
                className: getClassName19("breadcrumbLabel"),
                onClick: () => setUi({ itemSelector: breadcrumb.selector }),
                children: breadcrumb.label
              }
            ),
            (0, import_jsx_runtime27.jsx)(ChevronRight, { size: 16 })
          ] }, i2)) : null,
          (0, import_jsx_runtime27.jsx)("div", { className: getClassName19("heading"), children: (0, import_jsx_runtime27.jsx)(Heading, { rank: "2", size: "xs", children: title }) })
        ] }) }),
        (0, import_jsx_runtime27.jsx)("div", { className: getClassName19("content"), children }),
        isLoading && (0, import_jsx_runtime27.jsx)("div", { className: getClassName19("loadingOverlay"), children: (0, import_jsx_runtime27.jsx)(Loader, { size: 32 }) })
      ]
    }
  );
};
init_react_import();
var flushZones = (appState) => {
  const containsZones = typeof appState.data.zones !== "undefined";
  if (containsZones) {
    Object.keys(appState.data.zones || {}).forEach((zone) => {
      addToZoneCache(zone, appState.data.zones[zone]);
    });
    return __spreadProps(__spreadValues({}, appState), {
      data: __spreadProps(__spreadValues({}, appState.data), {
        zones: {}
      })
    });
  }
  return appState;
};
init_react_import();
init_react_import();
var styles_module_default14 = { "MenuBar": "_MenuBar_8pf8c_1", "MenuBar--menuOpen": "_MenuBar--menuOpen_8pf8c_14", "MenuBar-inner": "_MenuBar-inner_8pf8c_29", "MenuBar-history": "_MenuBar-history_8pf8c_45" };
var getClassName20 = get_class_name_factory_default("MenuBar", styles_module_default14);
function MenuBar({
  appState,
  dispatch,
  menuOpen = false,
  onPublish,
  renderHeaderActions,
  setMenuOpen
}) {
  const {
    history: { back, forward, historyStore }
  } = useAppContext();
  const { hasFuture = false, hasPast = false } = historyStore || {};
  return (0, import_jsx_runtime28.jsx)(
    "div",
    {
      className: getClassName20({ menuOpen }),
      onClick: (event) => {
        var _a3;
        const element = event.target;
        if (window.matchMedia("(min-width: 638px)").matches) {
          return;
        }
        if (element.tagName === "A" && ((_a3 = element.getAttribute("href")) == null ? void 0 : _a3.startsWith("#"))) {
          setMenuOpen(false);
        }
      },
      children: (0, import_jsx_runtime28.jsxs)("div", { className: getClassName20("inner"), children: [
        (0, import_jsx_runtime28.jsxs)("div", { className: getClassName20("history"), children: [
          (0, import_jsx_runtime28.jsx)(IconButton, { title: "undo", disabled: !hasPast, onClick: back, children: (0, import_jsx_runtime28.jsx)(Undo2, { size: 21 }) }),
          (0, import_jsx_runtime28.jsx)(IconButton, { title: "redo", disabled: !hasFuture, onClick: forward, children: (0, import_jsx_runtime28.jsx)(Redo2, { size: 21 }) })
        ] }),
        (0, import_jsx_runtime28.jsx)(import_jsx_runtime28.Fragment, { children: renderHeaderActions && renderHeaderActions({
          state: appState,
          dispatch
        }) })
      ] })
    }
  );
}
init_react_import();
var styles_module_default15 = { "Puck": "_Puck_11o75_19", "Puck-portal": "_Puck-portal_11o75_24", "PuckLayout-inner": "_PuckLayout-inner_11o75_31", "PuckLayout--mounted": "_PuckLayout--mounted_11o75_43", "PuckLayout--leftSideBarVisible": "_PuckLayout--leftSideBarVisible_11o75_47", "PuckLayout--rightSideBarVisible": "_PuckLayout--rightSideBarVisible_11o75_53", "PuckLayout-mounted": "_PuckLayout-mounted_11o75_67", "PuckLayout": "_PuckLayout_11o75_31", "PuckLayout-header": "_PuckLayout-header_11o75_108", "PuckLayout-headerInner": "_PuckLayout-headerInner_11o75_117", "PuckLayout-headerToggle": "_PuckLayout-headerToggle_11o75_127", "PuckLayout-rightSideBarToggle": "_PuckLayout-rightSideBarToggle_11o75_134", "PuckLayout-leftSideBarToggle": "_PuckLayout-leftSideBarToggle_11o75_135", "PuckLayout-headerTitle": "_PuckLayout-headerTitle_11o75_139", "PuckLayout-headerPath": "_PuckLayout-headerPath_11o75_143", "PuckLayout-headerTools": "_PuckLayout-headerTools_11o75_150", "PuckLayout-menuButton": "_PuckLayout-menuButton_11o75_156", "PuckLayout--menuOpen": "_PuckLayout--menuOpen_11o75_161", "PuckLayout-leftSideBar": "_PuckLayout-leftSideBar_11o75_135", "PuckLayout-rightSideBar": "_PuckLayout-rightSideBar_11o75_134" };
init_react_import();
init_react_import();
var styles_module_default16 = { "PuckFields": "_PuckFields_10bh7_1", "PuckFields--isLoading": "_PuckFields--isLoading_10bh7_6", "PuckFields-loadingOverlay": "_PuckFields-loadingOverlay_10bh7_10", "PuckFields-loadingOverlayInner": "_PuckFields-loadingOverlayInner_10bh7_25", "PuckFields-field": "_PuckFields-field_10bh7_32", "PuckFields--wrapFields": "_PuckFields--wrapFields_10bh7_36" };
init_react_import();
init_react_import();
var getParent = (itemSelector, pathData, data) => {
  var _a3;
  if (!itemSelector) return null;
  const item = getItem(itemSelector, data);
  const breadcrumbs = convertPathDataToBreadcrumbs(item, pathData, data);
  const lastItem = breadcrumbs[breadcrumbs.length - 1];
  const parent = (lastItem == null ? void 0 : lastItem.selector) ? (_a3 = getItem(lastItem.selector, data)) != null ? _a3 : null : null;
  return parent || null;
};
var useGetParent = () => {
  const { state } = useAppContext();
  const { pathData } = (0, import_react46.useContext)(dropZoneContext) || {};
  return (0, import_react46.useCallback)(
    () => getParent(state.ui.itemSelector, pathData, state.data),
    [state.ui.itemSelector, pathData, state.data]
  );
};
var useParent = () => {
  return useGetParent()();
};
init_react_import();
function useOnValueChange2(value, onChange, compare = Object.is, deps = []) {
  const tracked = (0, import_react47.useRef)(value);
  (0, import_react47.useEffect)(() => {
    const oldValue = tracked.current;
    if (!compare(value, oldValue)) {
      tracked.current = value;
      onChange(value, oldValue);
    }
  }, [onChange, compare, value, ...deps]);
}
init_react_import();
var selectorIs = (a2, b2) => (a2 == null ? void 0 : a2.zone) === (b2 == null ? void 0 : b2.zone) && (a2 == null ? void 0 : a2.index) === (b2 == null ? void 0 : b2.index);
var defaultPageFields = {
  title: { type: "text" }
};
var useResolvedFields = ({
  _skipValueCheck,
  _skipIdCheck
} = {}) => {
  var _a3, _b2;
  const { selectedItem, state, config } = useAppContext();
  const parent = useParent();
  const { data } = state;
  const rootFields = ((_a3 = config.root) == null ? void 0 : _a3.fields) || defaultPageFields;
  const componentConfig = selectedItem ? config.components[selectedItem.type] : null;
  const defaultFields = (0, import_react45.useMemo)(
    () => (selectedItem ? componentConfig == null ? void 0 : componentConfig.fields : rootFields) || {},
    [selectedItem, rootFields, componentConfig == null ? void 0 : componentConfig.fields]
  );
  const rootProps = data.root.props || data.root;
  const [lastSelectedData, setLastSelectedData] = (0, import_react45.useState)({});
  const [resolvedFields, setResolvedFields] = (0, import_react45.useState)({
    fields: defaultFields,
    id: selectedItem == null ? void 0 : selectedItem.props.id
  });
  const [fieldsLoading, setFieldsLoading] = (0, import_react45.useState)(false);
  const lastFields = (0, import_react45.useRef)(defaultFields);
  const defaultResolveFields = (_componentData, _params) => defaultFields;
  const componentData = (0, import_react45.useMemo)(
    () => selectedItem ? selectedItem : { props: rootProps, readOnly: data.root.readOnly || {} },
    [selectedItem, rootProps, data.root.readOnly]
  );
  const hasComponentResolver = selectedItem && (componentConfig == null ? void 0 : componentConfig.resolveFields);
  const hasRootResolver = !selectedItem && ((_b2 = config.root) == null ? void 0 : _b2.resolveFields);
  const hasResolver = hasComponentResolver || hasRootResolver;
  const resolveFields = (0, import_react45.useCallback)(
    (..._0) => __async(void 0, [..._0], function* (fields = {}) {
      var _a22;
      const lastData = ((_a22 = lastSelectedData.props) == null ? void 0 : _a22.id) === componentData.props.id ? lastSelectedData : null;
      const changed = getChanged(componentData, lastData);
      setLastSelectedData(componentData);
      if (hasComponentResolver) {
        return yield componentConfig.resolveFields(
          componentData,
          {
            changed,
            fields,
            lastFields: lastFields.current,
            lastData,
            appState: state,
            parent
          }
        );
      }
      if (hasRootResolver) {
        return yield config.root.resolveFields(componentData, {
          changed,
          fields,
          lastFields: lastFields.current,
          lastData,
          appState: state,
          parent
        });
      }
      return defaultResolveFields(componentData, {
        changed,
        fields,
        lastFields: lastFields.current,
        lastData
      });
    }),
    [data, config, componentData, selectedItem, state, parent]
  );
  const triggerResolver = (0, import_react45.useCallback)(() => {
    var _a22, _b22;
    if (!((_a22 = state.ui.itemSelector) == null ? void 0 : _a22.zone) || ((_b22 = state.ui.itemSelector) == null ? void 0 : _b22.zone) === "default-zone" || parent) {
      if (hasResolver) {
        setFieldsLoading(true);
        resolveFields(defaultFields).then((fields) => {
          setResolvedFields({
            fields: fields || {},
            id: selectedItem == null ? void 0 : selectedItem.props.id
          });
          lastFields.current = fields;
          setFieldsLoading(false);
        });
        return;
      }
    }
    setResolvedFields({ fields: defaultFields, id: selectedItem == null ? void 0 : selectedItem.props.id });
  }, [
    defaultFields,
    state.ui.itemSelector,
    selectedItem,
    hasResolver,
    parent,
    resolveFields
  ]);
  useOnValueChange2(
    state.ui.itemSelector,
    () => {
      lastFields.current = defaultFields;
    },
    selectorIs
  );
  useOnValueChange2(
    { data, parent, itemSelector: state.ui.itemSelector },
    () => {
      if (_skipValueCheck) return;
      triggerResolver();
    },
    (a2, b2) => JSON.stringify(a2) === JSON.stringify(b2)
  );
  (0, import_react45.useEffect)(() => {
    triggerResolver();
  }, []);
  if (resolvedFields.id !== (selectedItem == null ? void 0 : selectedItem.props.id) && !_skipIdCheck) {
    return [defaultFields, fieldsLoading];
  }
  return [resolvedFields.fields, fieldsLoading];
};
var getClassName21 = get_class_name_factory_default("PuckFields", styles_module_default16);
var DefaultFields = ({
  children
}) => {
  return (0, import_jsx_runtime29.jsx)(import_jsx_runtime29.Fragment, { children });
};
var Fields = ({ wrapFields = true }) => {
  var _a3, _b2;
  const {
    selectedItem,
    state,
    dispatch,
    config,
    resolveData,
    componentState,
    overrides
  } = useAppContext();
  const { data, ui } = state;
  const { itemSelector } = ui;
  const [fields, fieldsResolving] = useResolvedFields();
  const { getPermissions } = useAppContext();
  const componentResolving = selectedItem ? ((_a3 = componentState[selectedItem == null ? void 0 : selectedItem.props.id]) == null ? void 0 : _a3.loadingCount) > 0 : ((_b2 = componentState["puck-root"]) == null ? void 0 : _b2.loadingCount) > 0;
  const isLoading = fieldsResolving || componentResolving;
  const rootProps = data.root.props || data.root;
  const Wrapper = (0, import_react44.useMemo)(() => overrides.fields || DefaultFields, [overrides]);
  return (0, import_jsx_runtime29.jsxs)(
    "form",
    {
      className: getClassName21({ wrapFields }),
      onSubmit: (e3) => {
        e3.preventDefault();
      },
      children: [
        (0, import_jsx_runtime29.jsx)(Wrapper, { isLoading, itemSelector, children: Object.keys(fields).map((fieldName) => {
          const field = fields[fieldName];
          if (!(field == null ? void 0 : field.type)) return null;
          const onChange = (value, updatedUi) => {
            var _a22, _b22;
            let currentProps;
            if (selectedItem) {
              currentProps = selectedItem.props;
            } else {
              currentProps = rootProps;
            }
            const newProps = __spreadProps(__spreadValues({}, currentProps), {
              [fieldName]: value
            });
            if (selectedItem && itemSelector) {
              const replaceActionData = {
                type: "replace",
                destinationIndex: itemSelector.index,
                destinationZone: itemSelector.zone || rootDroppableId,
                data: __spreadProps(__spreadValues({}, selectedItem), { props: newProps })
              };
              const replacedData = replaceAction(data, replaceActionData);
              const setActionData = {
                type: "set",
                state: {
                  data: __spreadValues(__spreadValues({}, data), replacedData),
                  ui: __spreadValues(__spreadValues({}, ui), updatedUi)
                }
              };
              if ((_a22 = config.components[selectedItem.type]) == null ? void 0 : _a22.resolveData) {
                resolveData(setAction(state, setActionData));
              } else {
                dispatch(__spreadProps(__spreadValues({}, setActionData), {
                  recordHistory: true
                }));
              }
            } else {
              if (data.root.props) {
                if ((_b22 = config.root) == null ? void 0 : _b22.resolveData) {
                  resolveData({
                    ui: __spreadValues(__spreadValues({}, ui), updatedUi),
                    data: __spreadProps(__spreadValues({}, data), {
                      root: { props: newProps }
                    })
                  });
                } else {
                  dispatch({
                    type: "set",
                    state: {
                      ui: __spreadValues(__spreadValues({}, ui), updatedUi),
                      data: __spreadProps(__spreadValues({}, data), {
                        root: { props: newProps }
                      })
                    },
                    recordHistory: true
                  });
                }
              } else {
                dispatch({
                  type: "setData",
                  data: { root: newProps }
                });
              }
            }
          };
          if (selectedItem && itemSelector) {
            const { readOnly = {} } = selectedItem;
            const { edit } = getPermissions({
              item: selectedItem
            });
            const id = `${selectedItem.props.id}_${field.type}_${fieldName}`;
            return (0, import_jsx_runtime29.jsx)("div", { className: getClassName21("field"), children: (0, import_jsx_runtime29.jsx)(
              AutoFieldPrivate,
              {
                field,
                name: fieldName,
                id,
                readOnly: !edit || readOnly[fieldName],
                value: selectedItem.props[fieldName],
                onChange
              }
            ) }, id);
          } else {
            const readOnly = data.root.readOnly || {};
            const { edit } = getPermissions({
              root: true
            });
            const id = `root_${field.type}_${fieldName}`;
            return (0, import_jsx_runtime29.jsx)("div", { className: getClassName21("field"), children: (0, import_jsx_runtime29.jsx)(
              AutoFieldPrivate,
              {
                field,
                name: fieldName,
                id,
                readOnly: !edit || readOnly[fieldName],
                value: rootProps[fieldName],
                onChange
              }
            ) }, id);
          }
        }) }),
        isLoading && (0, import_jsx_runtime29.jsx)("div", { className: getClassName21("loadingOverlay"), children: (0, import_jsx_runtime29.jsx)("div", { className: getClassName21("loadingOverlayInner"), children: (0, import_jsx_runtime29.jsx)(Loader, { size: 16 }) }) })
      ]
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var styles_module_default17 = { "ComponentList": "_ComponentList_1rrlt_1", "ComponentList--isExpanded": "_ComponentList--isExpanded_1rrlt_5", "ComponentList-content": "_ComponentList-content_1rrlt_9", "ComponentList-title": "_ComponentList-title_1rrlt_17", "ComponentList-titleIcon": "_ComponentList-titleIcon_1rrlt_53" };
var getClassName22 = get_class_name_factory_default("ComponentList", styles_module_default17);
var ComponentListItem = ({
  name,
  label
}) => {
  const { overrides, getPermissions } = useAppContext();
  const canInsert = getPermissions({
    type: name
  }).insert;
  return (0, import_jsx_runtime30.jsx)(Drawer.Item, { label, name, isDragDisabled: !canInsert, children: overrides.componentItem });
};
var ComponentList = ({
  children,
  title,
  id
}) => {
  const { config, state, setUi } = useAppContext();
  const { expanded = true } = state.ui.componentList[id] || {};
  return (0, import_jsx_runtime30.jsxs)("div", { className: getClassName22({ isExpanded: expanded }), children: [
    title && (0, import_jsx_runtime30.jsxs)(
      "button",
      {
        type: "button",
        className: getClassName22("title"),
        onClick: () => setUi({
          componentList: __spreadProps(__spreadValues({}, state.ui.componentList), {
            [id]: __spreadProps(__spreadValues({}, state.ui.componentList[id]), {
              expanded: !expanded
            })
          })
        }),
        title: expanded ? `Collapse${title ? ` ${title}` : ""}` : `Expand${title ? ` ${title}` : ""}`,
        children: [
          (0, import_jsx_runtime30.jsx)("div", { children: title }),
          (0, import_jsx_runtime30.jsx)("div", { className: getClassName22("titleIcon"), children: expanded ? (0, import_jsx_runtime30.jsx)(ChevronUp, { size: 12 }) : (0, import_jsx_runtime30.jsx)(ChevronDown, { size: 12 }) })
        ]
      }
    ),
    (0, import_jsx_runtime30.jsx)("div", { className: getClassName22("content"), children: (0, import_jsx_runtime30.jsx)(Drawer, { children: children || Object.keys(config.components).map((componentKey) => {
      var _a3;
      return (0, import_jsx_runtime30.jsx)(
        ComponentListItem,
        {
          label: (_a3 = config.components[componentKey]["label"]) != null ? _a3 : componentKey,
          name: componentKey
        },
        componentKey
      );
    }) }) })
  ] });
};
ComponentList.Item = ComponentListItem;
var useComponentList = (config, ui) => {
  const [componentList, setComponentList] = (0, import_react48.useState)();
  (0, import_react48.useEffect)(() => {
    var _a3, _b2, _c4;
    if (Object.keys(ui.componentList).length > 0) {
      const matchedComponents = [];
      let _componentList;
      _componentList = Object.entries(ui.componentList).map(
        ([categoryKey, category]) => {
          if (category.visible === false || !category.components) {
            return null;
          }
          return (0, import_jsx_runtime31.jsx)(
            ComponentList,
            {
              id: categoryKey,
              title: category.title || categoryKey,
              children: category.components.map((componentName, i2) => {
                var _a22;
                matchedComponents.push(componentName);
                const componentConf = config.components[componentName] || {};
                return (0, import_jsx_runtime31.jsx)(
                  ComponentList.Item,
                  {
                    label: (_a22 = componentConf["label"]) != null ? _a22 : componentName,
                    name: componentName,
                    index: i2
                  },
                  componentName
                );
              })
            },
            categoryKey
          );
        }
      );
      const remainingComponents = Object.keys(config.components).filter(
        (component) => matchedComponents.indexOf(component) === -1
      );
      if (remainingComponents.length > 0 && !((_a3 = ui.componentList.other) == null ? void 0 : _a3.components) && ((_b2 = ui.componentList.other) == null ? void 0 : _b2.visible) !== false) {
        _componentList.push(
          (0, import_jsx_runtime31.jsx)(
            ComponentList,
            {
              id: "other",
              title: ((_c4 = ui.componentList.other) == null ? void 0 : _c4.title) || "Other",
              children: remainingComponents.map((componentName, i2) => {
                var _a22;
                const componentConf = config.components[componentName] || {};
                return (0, import_jsx_runtime31.jsx)(
                  ComponentList.Item,
                  {
                    name: componentName,
                    label: (_a22 = componentConf["label"]) != null ? _a22 : componentName,
                    index: i2
                  },
                  componentName
                );
              })
            },
            "other"
          )
        );
      }
      setComponentList(_componentList);
    }
  }, [config.categories, config.components, ui.componentList]);
  return componentList;
};
var Components = () => {
  const { config, state, overrides } = useAppContext();
  const componentList = useComponentList(config, state.ui);
  const Wrapper = (0, import_react49.useMemo)(() => overrides.components || "div", [overrides]);
  return (0, import_jsx_runtime32.jsx)(Wrapper, { children: componentList ? componentList : (0, import_jsx_runtime32.jsx)(ComponentList, { id: "all" }) });
};
init_react_import();
init_react_import();
var styleSelector = 'style, link[rel="stylesheet"]';
var collectStyles = (doc) => {
  const collected = [];
  doc.querySelectorAll(styleSelector).forEach((style) => {
    collected.push(style);
  });
  return collected;
};
var getStyleSheet = (el) => {
  return Array.from(document.styleSheets).find((ss) => {
    const ownerNode = ss.ownerNode;
    return ownerNode.href === el.href;
  });
};
var getStyles = (styleSheet) => {
  if (styleSheet) {
    try {
      return [...styleSheet.cssRules].map((rule) => rule.cssText).join("");
    } catch (e3) {
      console.warn(
        "Access to stylesheet %s is denied. Ignoring…",
        styleSheet.href
      );
    }
  }
  return "";
};
var syncAttributes = (sourceElement, targetElement) => {
  const attributes = sourceElement.attributes;
  if ((attributes == null ? void 0 : attributes.length) > 0) {
    Array.from(attributes).forEach((attribute) => {
      targetElement.setAttribute(attribute.name, attribute.value);
    });
  }
};
var defer = (fn) => setTimeout(fn, 0);
var CopyHostStyles = ({
  children,
  debug = false,
  onStylesLoaded = () => null
}) => {
  const { document: doc, window: win } = useFrame();
  (0, import_react51.useEffect)(() => {
    if (!win || !doc) {
      return () => {
      };
    }
    let elements = [];
    const hashes = {};
    const lookupEl = (el) => elements.findIndex((elementMap) => elementMap.original === el);
    const mirrorEl = (el, inlineStyles = false) => __async(void 0, null, function* () {
      let mirror;
      if (el.nodeName === "LINK" && inlineStyles) {
        mirror = document.createElement("style");
        mirror.type = "text/css";
        let styleSheet = getStyleSheet(el);
        if (!styleSheet) {
          yield new Promise((resolve) => {
            const fn = () => {
              resolve();
              el.removeEventListener("load", fn);
            };
            el.addEventListener("load", fn);
          });
          styleSheet = getStyleSheet(el);
        }
        const styles2 = getStyles(styleSheet);
        if (!styles2) {
          if (debug) {
            console.warn(
              `Tried to load styles for link element, but couldn't find them. Skipping...`
            );
          }
          return;
        }
        mirror.innerHTML = styles2;
        mirror.setAttribute("data-href", el.getAttribute("href"));
      } else {
        mirror = el.cloneNode(true);
      }
      return mirror;
    });
    const addEl = (el) => __async(void 0, null, function* () {
      const index = lookupEl(el);
      if (index > -1) {
        if (debug)
          console.log(
            `Tried to add an element that was already mirrored. Updating instead...`
          );
        elements[index].mirror.innerText = el.innerText;
        return;
      }
      const mirror = yield mirrorEl(el);
      if (!mirror) {
        return;
      }
      const elHash = (0, import_object_hash.default)(mirror.outerHTML);
      if (hashes[elHash]) {
        if (debug)
          console.log(
            `iframe already contains element that is being mirrored. Skipping...`
          );
        return;
      }
      hashes[elHash] = true;
      doc.head.append(mirror);
      elements.push({ original: el, mirror });
      if (debug) console.log(`Added style node ${el.outerHTML}`);
    });
    const removeEl = (el) => {
      var _a3, _b2;
      const index = lookupEl(el);
      if (index === -1) {
        if (debug)
          console.log(
            `Tried to remove an element that did not exist. Skipping...`
          );
        return;
      }
      const elHash = (0, import_object_hash.default)(el.outerHTML);
      (_b2 = (_a3 = elements[index]) == null ? void 0 : _a3.mirror) == null ? void 0 : _b2.remove();
      delete hashes[elHash];
      if (debug) console.log(`Removed style node ${el.outerHTML}`);
    };
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {
              const el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
              if (el && el.matches(styleSelector)) {
                defer(() => addEl(el));
              }
            }
          });
          mutation.removedNodes.forEach((node) => {
            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {
              const el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
              if (el && el.matches(styleSelector)) {
                defer(() => removeEl(el));
              }
            }
          });
        }
      });
    });
    const parentDocument = win.parent.document;
    const collectedStyles = collectStyles(parentDocument);
    const hrefs = [];
    let stylesLoaded = 0;
    const parentHtml = parentDocument.getElementsByTagName("html")[0];
    syncAttributes(parentHtml, doc.documentElement);
    const parentBody = parentDocument.getElementsByTagName("body")[0];
    syncAttributes(parentBody, doc.body);
    Promise.all(
      collectedStyles.map((styleNode, i2) => __async(void 0, null, function* () {
        if (styleNode.nodeName === "LINK") {
          const linkHref = styleNode.href;
          if (hrefs.indexOf(linkHref) > -1) {
            return;
          }
          hrefs.push(linkHref);
        }
        const mirror = yield mirrorEl(styleNode);
        if (!mirror) return;
        elements.push({ original: styleNode, mirror });
        return mirror;
      }))
    ).then((mirrorStyles) => {
      const filtered = mirrorStyles.filter(
        (el) => typeof el !== "undefined"
      );
      filtered.forEach((mirror) => {
        mirror.onload = () => {
          stylesLoaded = stylesLoaded + 1;
          if (stylesLoaded >= elements.length) {
            onStylesLoaded();
          }
        };
        mirror.onerror = () => {
          console.warn(`AutoFrame couldn't load a stylesheet`);
          stylesLoaded = stylesLoaded + 1;
          if (stylesLoaded >= elements.length) {
            onStylesLoaded();
          }
        };
      });
      doc.head.innerHTML = "";
      doc.head.append(...filtered);
      observer.observe(parentDocument.head, { childList: true, subtree: true });
      filtered.forEach((el) => {
        const elHash = (0, import_object_hash.default)(el.outerHTML);
        hashes[elHash] = true;
      });
    });
    return () => {
      observer.disconnect();
    };
  }, []);
  return (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children });
};
var autoFrameContext = (0, import_react51.createContext)({});
var useFrame = () => (0, import_react51.useContext)(autoFrameContext);
function AutoFrame(_a3) {
  var _b2 = _a3, {
    children,
    className,
    debug,
    id,
    onStylesLoaded,
    frameRef
  } = _b2, props = __objRest(_b2, [
    "children",
    "className",
    "debug",
    "id",
    "onStylesLoaded",
    "frameRef"
  ]);
  const [loaded, setLoaded] = (0, import_react51.useState)(false);
  const [ctx, setCtx] = (0, import_react51.useState)({});
  const [mountTarget, setMountTarget] = (0, import_react51.useState)();
  (0, import_react51.useEffect)(() => {
    var _a22;
    if (frameRef.current) {
      setCtx({
        document: frameRef.current.contentDocument || void 0,
        window: frameRef.current.contentWindow || void 0
      });
      setMountTarget(
        (_a22 = frameRef.current.contentDocument) == null ? void 0 : _a22.getElementById("frame-root")
      );
    }
  }, [frameRef, loaded]);
  return (0, import_jsx_runtime33.jsx)(
    "iframe",
    __spreadProps(__spreadValues({}, props), {
      className,
      id,
      srcDoc: '<!DOCTYPE html><html><head></head><body><div id="frame-root" data-puck-entry></div></body></html>',
      ref: frameRef,
      onLoad: () => {
        setLoaded(true);
      },
      children: (0, import_jsx_runtime33.jsx)(autoFrameContext.Provider, { value: ctx, children: loaded && mountTarget && (0, import_jsx_runtime33.jsx)(CopyHostStyles, { debug, onStylesLoaded, children: (0, import_react_dom4.createPortal)(children, mountTarget) }) })
    })
  );
}
AutoFrame.displayName = "AutoFrame";
var AutoFrame_default = AutoFrame;
init_react_import();
var styles_module_default18 = { "PuckPreview": "_PuckPreview_z2rgu_1", "PuckPreview-frame": "_PuckPreview-frame_z2rgu_6" };
init_react_import();
function Render({
  config,
  data
}) {
  var _a3;
  const defaultedData = __spreadProps(__spreadValues({}, data), {
    root: data.root || {},
    content: data.content || []
  });
  const rootProps = defaultedData.root.props || defaultedData.root;
  const title = (rootProps == null ? void 0 : rootProps.title) || "";
  if ((_a3 = config.root) == null ? void 0 : _a3.render) {
    return (0, import_jsx_runtime34.jsx)(
      DropZoneProvider,
      {
        value: {
          data: defaultedData,
          config,
          mode: "render",
          depth: 0,
          path: []
        },
        children: (0, import_jsx_runtime34.jsx)(
          config.root.render,
          __spreadProps(__spreadValues({}, rootProps), {
            puck: {
              renderDropZone: DropZonePure,
              isEditing: false,
              dragRef: null
            },
            title,
            editMode: false,
            id: "puck-root",
            children: (0, import_jsx_runtime34.jsx)(DropZonePure, { zone: rootDroppableId })
          })
        )
      }
    );
  }
  return (0, import_jsx_runtime34.jsx)(
    DropZoneProvider,
    {
      value: {
        data: defaultedData,
        config,
        mode: "render",
        depth: 0,
        path: []
      },
      children: (0, import_jsx_runtime34.jsx)(DropZonePure, { zone: rootDroppableId })
    }
  );
}
var getClassName23 = get_class_name_factory_default("PuckPreview", styles_module_default18);
var useBubbleIframeEvents = (ref) => {
  const { status } = useAppContext();
  (0, import_react50.useEffect)(() => {
    var _a3;
    if (ref.current && status === "READY") {
      const iframe = ref.current;
      const handlePointerMove = (event) => {
        const evt = new BubbledPointerEvent("pointermove", __spreadProps(__spreadValues({}, event), {
          bubbles: true,
          cancelable: false,
          clientX: event.clientX,
          clientY: event.clientY,
          originalTarget: event.target
        }));
        iframe.dispatchEvent(evt);
      };
      (_a3 = iframe.contentDocument) == null ? void 0 : _a3.addEventListener(
        "pointermove",
        handlePointerMove,
        {
          capture: true
        }
      );
      return () => {
        var _a22;
        (_a22 = iframe.contentDocument) == null ? void 0 : _a22.removeEventListener(
          "pointermove",
          handlePointerMove
        );
      };
    }
  }, [status]);
};
var Preview2 = ({ id = "puck-preview" }) => {
  const { config, dispatch, state, setStatus, iframe, overrides } = useAppContext();
  const Page = (0, import_react50.useCallback)(
    (pageProps) => {
      var _a3, _b2;
      return ((_a3 = config.root) == null ? void 0 : _a3.render) ? (_b2 = config.root) == null ? void 0 : _b2.render(__spreadValues({
        id: "puck-root"
      }, pageProps)) : (0, import_jsx_runtime35.jsx)(import_jsx_runtime35.Fragment, { children: pageProps.children });
    },
    [config.root]
  );
  const Frame = (0, import_react50.useMemo)(() => overrides.iframe, [overrides]);
  const rootProps = state.data.root.props || state.data.root;
  const ref = (0, import_react50.useRef)(null);
  useBubbleIframeEvents(ref);
  const inner = state.ui.previewMode === "edit" ? (0, import_jsx_runtime35.jsx)(
    Page,
    __spreadProps(__spreadValues({}, rootProps), {
      puck: {
        renderDropZone: DropZonePure,
        isEditing: true,
        dragRef: null
      },
      editMode: true,
      children: (0, import_jsx_runtime35.jsx)(DropZonePure, { zone: rootDroppableId })
    })
  ) : (0, import_jsx_runtime35.jsx)(Render, { data: state.data, config });
  return (0, import_jsx_runtime35.jsx)(
    "div",
    {
      className: getClassName23(),
      id,
      "data-puck-preview": true,
      onClick: () => {
        dispatch({ type: "setUi", ui: __spreadProps(__spreadValues({}, state.ui), { itemSelector: null }) });
      },
      children: iframe.enabled ? (0, import_jsx_runtime35.jsx)(
        AutoFrame_default,
        {
          id: "preview-frame",
          className: getClassName23("frame"),
          "data-rfd-iframe": true,
          onStylesLoaded: () => {
            setStatus("READY");
          },
          frameRef: ref,
          children: (0, import_jsx_runtime35.jsx)(autoFrameContext.Consumer, { children: ({ document: document2 }) => {
            if (Frame) {
              return (0, import_jsx_runtime35.jsx)(Frame, { document: document2, children: inner });
            }
            return inner;
          } })
        }
      ) : (0, import_jsx_runtime35.jsx)(
        "div",
        {
          id: "preview-frame",
          className: getClassName23("frame"),
          ref,
          "data-puck-entry": true,
          children: inner
        }
      )
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var findZonesForArea = (data, area) => {
  const { zones = {} } = data;
  const result = Object.keys(zones).filter(
    (zoneId) => getZoneId(zoneId)[0] === area
  );
  return result.reduce((acc, key) => {
    return __spreadProps(__spreadValues({}, acc), { [key]: zones[key] });
  }, {});
};
var areaContainsZones = (data, area) => {
  const zones = Object.keys(findZonesForArea(data, area));
  return zones.length > 0;
};
init_react_import();
init_react_import();
var styles_module_default19 = { "LayerTree": "_LayerTree_7rx04_1", "LayerTree-zoneTitle": "_LayerTree-zoneTitle_7rx04_11", "LayerTree-helper": "_LayerTree-helper_7rx04_17", "Layer": "_Layer_7rx04_1", "Layer-inner": "_Layer-inner_7rx04_29", "Layer--containsZone": "_Layer--containsZone_7rx04_35", "Layer-clickable": "_Layer-clickable_7rx04_39", "Layer--isSelected": "_Layer--isSelected_7rx04_61", "Layer-chevron": "_Layer-chevron_7rx04_77", "Layer--childIsSelected": "_Layer--childIsSelected_7rx04_78", "Layer-zones": "_Layer-zones_7rx04_82", "Layer-title": "_Layer-title_7rx04_96", "Layer-name": "_Layer-name_7rx04_105", "Layer-icon": "_Layer-icon_7rx04_111", "Layer-zoneIcon": "_Layer-zoneIcon_7rx04_116" };
init_react_import();
var scrollIntoView = (el) => {
  const oldStyle = __spreadValues({}, el.style);
  el.style.scrollMargin = "256px";
  if (el) {
    el == null ? void 0 : el.scrollIntoView({ behavior: "smooth" });
    el.style.scrollMargin = oldStyle.scrollMargin || "";
  }
};
init_react_import();
var isChildOfZone = (item, maybeChild, ctx) => {
  var _a3;
  const { data, pathData = {} } = ctx || {};
  return maybeChild && data ? !!((_a3 = pathData[maybeChild.props.id]) == null ? void 0 : _a3.path.find((zoneCompound) => {
    const [area] = getZoneId(zoneCompound);
    return area === item.props.id;
  })) : false;
};
init_react_import();
var onScrollEnd = (frame, cb) => {
  let scrollTimeout;
  const callback = function() {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(function() {
      cb();
      frame == null ? void 0 : frame.removeEventListener("scroll", callback);
    }, 50);
  };
  frame == null ? void 0 : frame.addEventListener("scroll", callback);
  setTimeout(() => {
    if (!scrollTimeout) {
      cb();
    }
  }, 50);
};
var getClassName24 = get_class_name_factory_default("LayerTree", styles_module_default19);
var getClassNameLayer = get_class_name_factory_default("Layer", styles_module_default19);
var LayerTree = ({
  data,
  config,
  zoneContent,
  itemSelector,
  setItemSelector,
  zone,
  label
}) => {
  const zones = data.zones || {};
  const ctx = (0, import_react52.useContext)(dropZoneContext);
  return (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [
    label && (0, import_jsx_runtime36.jsxs)("div", { className: getClassName24("zoneTitle"), children: [
      (0, import_jsx_runtime36.jsx)("div", { className: getClassName24("zoneIcon"), children: (0, import_jsx_runtime36.jsx)(Layers, { size: "16" }) }),
      " ",
      label
    ] }),
    (0, import_jsx_runtime36.jsxs)("ul", { className: getClassName24(), children: [
      zoneContent.length === 0 && (0, import_jsx_runtime36.jsx)("div", { className: getClassName24("helper"), children: "No items" }),
      zoneContent.map((item, i2) => {
        var _a3;
        const isSelected = (itemSelector == null ? void 0 : itemSelector.index) === i2 && (itemSelector.zone === zone || itemSelector.zone === rootDroppableId && !zone);
        const zonesForItem = findZonesForArea(data, item.props.id);
        const containsZone = Object.keys(zonesForItem).length > 0;
        const { setHoveringComponent = () => {
        }, hoveringComponent } = ctx || {};
        const selectedItem = itemSelector && data ? getItem(itemSelector, data) : null;
        const isHovering = hoveringComponent === item.props.id;
        const childIsSelected = isChildOfZone(item, selectedItem, ctx);
        const componentConfig = config.components[item.type];
        const label2 = (_a3 = componentConfig == null ? void 0 : componentConfig["label"]) != null ? _a3 : item.type.toString();
        return (0, import_jsx_runtime36.jsxs)(
          "li",
          {
            className: getClassNameLayer({
              isSelected,
              isHovering,
              containsZone,
              childIsSelected
            }),
            children: [
              (0, import_jsx_runtime36.jsx)("div", { className: getClassNameLayer("inner"), children: (0, import_jsx_runtime36.jsxs)(
                "button",
                {
                  type: "button",
                  className: getClassNameLayer("clickable"),
                  onClick: () => {
                    if (isSelected) {
                      setItemSelector(null);
                      return;
                    }
                    const id = zoneContent[i2].props.id;
                    const frame = getFrame();
                    const el = frame == null ? void 0 : frame.querySelector(
                      `[data-puck-component="${id}"]`
                    );
                    if (!el) {
                      console.error(
                        "Scroll failed. No element was found for",
                        id
                      );
                      return;
                    }
                    scrollIntoView(el);
                    onScrollEnd(frame, () => {
                      setItemSelector({
                        index: i2,
                        zone
                      });
                    });
                  },
                  onMouseOver: (e3) => {
                    e3.stopPropagation();
                    setHoveringComponent(item.props.id);
                  },
                  onMouseOut: (e3) => {
                    e3.stopPropagation();
                    setHoveringComponent(null);
                  },
                  children: [
                    containsZone && (0, import_jsx_runtime36.jsx)(
                      "div",
                      {
                        className: getClassNameLayer("chevron"),
                        title: isSelected ? "Collapse" : "Expand",
                        children: (0, import_jsx_runtime36.jsx)(ChevronDown, { size: "12" })
                      }
                    ),
                    (0, import_jsx_runtime36.jsxs)("div", { className: getClassNameLayer("title"), children: [
                      (0, import_jsx_runtime36.jsx)("div", { className: getClassNameLayer("icon"), children: item.type === "Text" || item.type === "Heading" ? (0, import_jsx_runtime36.jsx)(Type, { size: "16" }) : (0, import_jsx_runtime36.jsx)(LayoutGrid, { size: "16" }) }),
                      (0, import_jsx_runtime36.jsx)("div", { className: getClassNameLayer("name"), children: label2 })
                    ] })
                  ]
                }
              ) }),
              containsZone && Object.keys(zonesForItem).map((zoneKey, idx) => (0, import_jsx_runtime36.jsx)("div", { className: getClassNameLayer("zones"), children: (0, import_jsx_runtime36.jsx)(
                LayerTree,
                {
                  config,
                  data,
                  zoneContent: zones[zoneKey],
                  setItemSelector,
                  itemSelector,
                  zone: zoneKey,
                  label: getZoneId(zoneKey)[1]
                }
              ) }, idx))
            ]
          },
          `${item.props.id}_${i2}`
        );
      })
    ] })
  ] });
};
var Outline = () => {
  const { dispatch, state, overrides, config } = useAppContext();
  const { data, ui } = state;
  const { itemSelector } = ui;
  const setItemSelector = (0, import_react53.useCallback)(
    (newItemSelector) => {
      dispatch({
        type: "setUi",
        ui: { itemSelector: newItemSelector }
      });
    },
    []
  );
  const Wrapper = (0, import_react53.useMemo)(() => overrides.outline || "div", [overrides]);
  return (0, import_jsx_runtime37.jsx)(Wrapper, { children: (0, import_jsx_runtime37.jsx)(dropZoneContext.Consumer, { children: (ctx) => (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [
    (ctx == null ? void 0 : ctx.activeZones) && (ctx == null ? void 0 : ctx.activeZones[rootDroppableId]) && (0, import_jsx_runtime37.jsx)(
      LayerTree,
      {
        config,
        data,
        label: areaContainsZones(data, "root") ? rootDroppableId : "",
        zoneContent: data.content,
        setItemSelector,
        itemSelector
      }
    ),
    Object.entries(findZonesForArea(data, "root")).map(
      ([zoneKey, zone]) => {
        return (0, import_jsx_runtime37.jsx)(
          LayerTree,
          {
            config,
            data,
            label: zoneKey,
            zone: zoneKey,
            zoneContent: zone,
            setItemSelector,
            itemSelector
          },
          zoneKey
        );
      }
    )
  ] }) }) });
};
init_react_import();
function usePuckHistory({
  dispatch,
  initialAppState,
  historyStore,
  iframeEnabled
}) {
  const back = () => {
    var _a3;
    if (historyStore.hasPast) {
      dispatch({
        type: "set",
        state: ((_a3 = historyStore.prevHistory) == null ? void 0 : _a3.state) || initialAppState
      });
      historyStore.back();
    }
  };
  const forward = () => {
    if (historyStore.nextHistory) {
      dispatch({ type: "set", state: historyStore.nextHistory.state });
      historyStore.forward();
    }
  };
  const backIframe = () => {
    if (iframeEnabled) {
      back();
    }
  };
  const forwardIframe = () => {
    if (iframeEnabled) {
      forward();
    }
  };
  const setHistories = (histories) => {
    var _a3;
    dispatch({
      type: "set",
      state: ((_a3 = histories[histories.length - 1]) == null ? void 0 : _a3.state) || initialAppState
    });
    historyStore.setHistories(histories);
  };
  const setHistoryIndex = (index) => {
    var _a3;
    if (historyStore.histories.length > index) {
      dispatch({
        type: "set",
        state: ((_a3 = historyStore.histories[index]) == null ? void 0 : _a3.state) || initialAppState
      });
      historyStore.setHistoryIndex(index);
    }
  };
  const frame = getFrame();
  const resolvedFrame = typeof window !== "undefined" && frame !== document ? frame : void 0;
  useHotkeys("meta+z", back, { preventDefault: true });
  useHotkeys("meta+shift+z", forward, { preventDefault: true });
  useHotkeys("meta+y", forward, { preventDefault: true });
  useHotkeys("meta+z", backIframe, {
    preventDefault: true,
    document: resolvedFrame
  });
  useHotkeys("meta+shift+z", forwardIframe, {
    preventDefault: true,
    document: resolvedFrame
  });
  useHotkeys("meta+y", forwardIframe, {
    preventDefault: true,
    document: resolvedFrame
  });
  return {
    back,
    forward,
    historyStore,
    setHistories,
    setHistoryIndex
  };
}
init_react_import();
var EMPTY_HISTORY_INDEX = 0;
function useHistoryStore(initialHistory) {
  var _a3, _b2;
  const [histories, setHistories] = (0, import_react54.useState)(
    (_a3 = initialHistory == null ? void 0 : initialHistory.histories) != null ? _a3 : []
  );
  const updateHistories = (histories2) => {
    setHistories(histories2);
    setIndex(histories2.length - 1);
  };
  const [index, setIndex] = (0, import_react54.useState)(
    (_b2 = initialHistory == null ? void 0 : initialHistory.index) != null ? _b2 : EMPTY_HISTORY_INDEX
  );
  const hasPast = index > EMPTY_HISTORY_INDEX;
  const hasFuture = index < histories.length - 1;
  const currentHistory = histories[index];
  const nextHistory = hasFuture ? histories[index + 1] : null;
  const prevHistory = hasPast ? histories[index - 1] : null;
  const record = c2((state) => {
    const history = {
      state,
      id: generateId("history")
    };
    updateHistories([...histories.slice(0, index + 1), history]);
  }, 250);
  const back = () => {
    setIndex(index - 1);
  };
  const forward = () => {
    setIndex(index + 1);
  };
  return {
    index,
    currentHistory,
    hasPast,
    hasFuture,
    record,
    back,
    forward,
    nextHistory,
    prevHistory,
    histories,
    setHistories: updateHistories,
    setHistoryIndex: setIndex
  };
}
init_react_import();
init_react_import();
init_react_import();
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
var getRect = function getRect2(_ref) {
  var top = _ref.top, right = _ref.right, bottom = _ref.bottom, left = _ref.left;
  var width = right - left;
  var height = bottom - top;
  var rect = {
    top,
    right,
    bottom,
    left,
    width,
    height,
    x: left,
    y: top,
    center: {
      x: (right + left) / 2,
      y: (bottom + top) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? noSpacing : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border,
    padding
  };
};
var parse = function parse2(raw) {
  var value = raw.slice(0, -2);
  var suffix = raw.slice(-2);
  if (suffix !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? true ? invariant(false, "Could not parse value [raw: " + raw + ", without suffix: " + value + "]") : invariant(false) : void 0;
  return result;
};
var calculateBox = function calculateBox2(borderBox, styles2) {
  var margin = {
    top: parse(styles2.marginTop),
    right: parse(styles2.marginRight),
    bottom: parse(styles2.marginBottom),
    left: parse(styles2.marginLeft)
  };
  var padding = {
    top: parse(styles2.paddingTop),
    right: parse(styles2.paddingRight),
    bottom: parse(styles2.paddingBottom),
    left: parse(styles2.paddingLeft)
  };
  var border = {
    top: parse(styles2.borderTopWidth),
    right: parse(styles2.borderRightWidth),
    bottom: parse(styles2.borderBottomWidth),
    left: parse(styles2.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border
  });
};
var getBox = function getBox2(el) {
  var borderBox = el.getBoundingClientRect();
  var styles2 = window.getComputedStyle(el);
  return calculateBox(borderBox, styles2);
};
init_react_import();
init_react_import();
var styles_module_default20 = { "ViewportControls": "_ViewportControls_gejzr_1", "ViewportControls-divider": "_ViewportControls-divider_gejzr_15", "ViewportControls-zoomSelect": "_ViewportControls-zoomSelect_gejzr_21", "ViewportButton--isActive": "_ViewportButton--isActive_gejzr_38", "ViewportButton-inner": "_ViewportButton-inner_gejzr_38" };
var icons = {
  Smartphone: (0, import_jsx_runtime38.jsx)(Smartphone, { size: 16 }),
  Tablet: (0, import_jsx_runtime38.jsx)(Tablet, { size: 16 }),
  Monitor: (0, import_jsx_runtime38.jsx)(Monitor2, { size: 16 })
};
var getClassName25 = get_class_name_factory_default("ViewportControls", styles_module_default20);
var getClassNameButton = get_class_name_factory_default("ViewportButton", styles_module_default20);
var ViewportButton = ({
  children,
  height = "auto",
  title,
  width,
  onClick
}) => {
  const { state } = useAppContext();
  const [isActive, setIsActive] = (0, import_react56.useState)(false);
  (0, import_react56.useEffect)(() => {
    setIsActive(width === state.ui.viewports.current.width);
  }, [width, state.ui.viewports.current.width]);
  return (0, import_jsx_runtime38.jsx)("span", { className: getClassNameButton({ isActive }), children: (0, import_jsx_runtime38.jsx)(
    IconButton,
    {
      title,
      disabled: isActive,
      onClick: (e3) => {
        e3.stopPropagation();
        onClick({ width, height });
      },
      children: (0, import_jsx_runtime38.jsx)("span", { className: getClassNameButton("inner"), children })
    }
  ) });
};
var defaultZoomOptions = [
  { label: "25%", value: 0.25 },
  { label: "50%", value: 0.5 },
  { label: "75%", value: 0.75 },
  { label: "100%", value: 1 },
  { label: "125%", value: 1.25 },
  { label: "150%", value: 1.5 },
  { label: "200%", value: 2 }
];
var ViewportControls = ({
  autoZoom,
  zoom,
  onViewportChange,
  onZoom
}) => {
  var _a3, _b2;
  const { viewports } = useAppContext();
  const defaultsContainAutoZoom = defaultZoomOptions.find(
    (option) => option.value === autoZoom
  );
  const zoomOptions = (0, import_react56.useMemo)(
    () => [
      ...defaultZoomOptions,
      ...defaultsContainAutoZoom ? [] : [
        {
          value: autoZoom,
          label: `${(autoZoom * 100).toFixed(0)}% (Auto)`
        }
      ]
    ].filter((a2) => a2.value <= autoZoom).sort((a2, b2) => a2.value > b2.value ? 1 : -1),
    [autoZoom]
  );
  return (0, import_jsx_runtime38.jsxs)("div", { className: getClassName25(), children: [
    viewports.map((viewport, i2) => (0, import_jsx_runtime38.jsx)(
      ViewportButton,
      {
        height: viewport.height,
        width: viewport.width,
        title: viewport.label ? `Switch to ${viewport.label} viewport` : "Switch viewport",
        onClick: onViewportChange,
        children: typeof viewport.icon === "string" ? icons[viewport.icon] || viewport.icon : viewport.icon || icons.Smartphone
      },
      i2
    )),
    (0, import_jsx_runtime38.jsx)("div", { className: getClassName25("divider") }),
    (0, import_jsx_runtime38.jsx)(
      IconButton,
      {
        title: "Zoom viewport out",
        disabled: zoom <= ((_a3 = zoomOptions[0]) == null ? void 0 : _a3.value),
        onClick: (e3) => {
          e3.stopPropagation();
          onZoom(
            zoomOptions[Math.max(
              zoomOptions.findIndex((option) => option.value === zoom) - 1,
              0
            )].value
          );
        },
        children: (0, import_jsx_runtime38.jsx)(ZoomOut, { size: 16 })
      }
    ),
    (0, import_jsx_runtime38.jsx)(
      IconButton,
      {
        title: "Zoom viewport in",
        disabled: zoom >= ((_b2 = zoomOptions[zoomOptions.length - 1]) == null ? void 0 : _b2.value),
        onClick: (e3) => {
          e3.stopPropagation();
          onZoom(
            zoomOptions[Math.min(
              zoomOptions.findIndex((option) => option.value === zoom) + 1,
              zoomOptions.length - 1
            )].value
          );
        },
        children: (0, import_jsx_runtime38.jsx)(ZoomIn, { size: 16 })
      }
    ),
    (0, import_jsx_runtime38.jsx)("div", { className: getClassName25("divider") }),
    (0, import_jsx_runtime38.jsx)(
      "select",
      {
        className: getClassName25("zoomSelect"),
        value: zoom.toString(),
        onChange: (e3) => {
          onZoom(parseFloat(e3.currentTarget.value));
        },
        children: zoomOptions.map((option) => (0, import_jsx_runtime38.jsx)(
          "option",
          {
            value: option.value,
            label: option.label
          },
          option.label
        ))
      }
    )
  ] });
};
init_react_import();
var styles_module_default21 = { "PuckCanvas": "_PuckCanvas_18jay_1", "PuckCanvas-controls": "_PuckCanvas-controls_18jay_16", "PuckCanvas-inner": "_PuckCanvas-inner_18jay_21", "PuckCanvas-root": "_PuckCanvas-root_18jay_30", "PuckCanvas--ready": "_PuckCanvas--ready_18jay_55", "PuckCanvas-loader": "_PuckCanvas-loader_18jay_60", "PuckCanvas--showLoader": "_PuckCanvas--showLoader_18jay_70" };
init_react_import();
var RESET_ZOOM_SMALLER_THAN_FRAME = true;
var getZoomConfig = (uiViewport, frame, zoom) => {
  const box = getBox(frame);
  const { width: frameWidth, height: frameHeight } = box.contentBox;
  const viewportHeight = uiViewport.height === "auto" ? frameHeight : uiViewport.height;
  let rootHeight = 0;
  let autoZoom = 1;
  if (uiViewport.width > frameWidth || viewportHeight > frameHeight) {
    const widthZoom = Math.min(frameWidth / uiViewport.width, 1);
    const heightZoom = Math.min(frameHeight / viewportHeight, 1);
    zoom = widthZoom;
    if (widthZoom < heightZoom) {
      rootHeight = viewportHeight / zoom;
    } else {
      rootHeight = viewportHeight;
      zoom = heightZoom;
    }
    autoZoom = zoom;
  } else {
    if (RESET_ZOOM_SMALLER_THAN_FRAME) {
      autoZoom = 1;
      zoom = 1;
      rootHeight = viewportHeight;
    }
  }
  return { autoZoom, rootHeight, zoom };
};
var getClassName26 = get_class_name_factory_default("PuckCanvas", styles_module_default21);
var ZOOM_ON_CHANGE = true;
var Canvas = () => {
  const { status, iframe } = useAppContext();
  const { dispatch, state, overrides, setUi, zoomConfig, setZoomConfig } = useAppContext();
  const { ui } = state;
  const frameRef = (0, import_react55.useRef)(null);
  const [showTransition, setShowTransition] = (0, import_react55.useState)(false);
  const defaultRender = (0, import_react55.useMemo)(() => {
    const PuckDefault = ({ children }) => (0, import_jsx_runtime39.jsx)(import_jsx_runtime39.Fragment, { children });
    return PuckDefault;
  }, []);
  const CustomPreview = (0, import_react55.useMemo)(
    () => overrides.preview || defaultRender,
    [overrides]
  );
  const getFrameDimensions = (0, import_react55.useCallback)(() => {
    if (frameRef.current) {
      const frame = frameRef.current;
      const box = getBox(frame);
      return { width: box.contentBox.width, height: box.contentBox.height };
    }
    return { width: 0, height: 0 };
  }, [frameRef]);
  const resetAutoZoom = (0, import_react55.useCallback)(
    (ui2 = state.ui) => {
      if (frameRef.current) {
        setZoomConfig(
          getZoomConfig(ui2.viewports.current, frameRef.current, zoomConfig.zoom)
        );
      }
    },
    [frameRef, zoomConfig, state.ui]
  );
  (0, import_react55.useEffect)(() => {
    setShowTransition(false);
    resetAutoZoom();
  }, [frameRef, ui.leftSideBarVisible, ui.rightSideBarVisible]);
  (0, import_react55.useEffect)(() => {
    const { height: frameHeight } = getFrameDimensions();
    if (ui.viewports.current.height === "auto") {
      setZoomConfig(__spreadProps(__spreadValues({}, zoomConfig), {
        rootHeight: frameHeight / zoomConfig.zoom
      }));
    }
  }, [zoomConfig.zoom]);
  (0, import_react55.useEffect)(() => {
    if (ZOOM_ON_CHANGE) {
      setShowTransition(true);
      resetAutoZoom(ui);
    }
  }, [ui.viewports.current.width]);
  (0, import_react55.useEffect)(() => {
    const cb = () => {
      setShowTransition(false);
      resetAutoZoom();
    };
    window.addEventListener("resize", cb);
    return () => {
      window.removeEventListener("resize", cb);
    };
  }, []);
  const [showLoader, setShowLoader] = (0, import_react55.useState)(false);
  (0, import_react55.useEffect)(() => {
    setTimeout(() => {
      setShowLoader(true);
    }, 500);
  }, []);
  return (0, import_jsx_runtime39.jsxs)(
    "div",
    {
      className: getClassName26({
        ready: status === "READY" || !iframe.enabled || !iframe.waitForStyles,
        showLoader
      }),
      onClick: () => dispatch({
        type: "setUi",
        ui: { itemSelector: null },
        recordHistory: true
      }),
      children: [
        ui.viewports.controlsVisible && iframe.enabled && (0, import_jsx_runtime39.jsx)("div", { className: getClassName26("controls"), children: (0, import_jsx_runtime39.jsx)(
          ViewportControls,
          {
            autoZoom: zoomConfig.autoZoom,
            zoom: zoomConfig.zoom,
            onViewportChange: (viewport) => {
              setShowTransition(true);
              const uiViewport = __spreadProps(__spreadValues({}, viewport), {
                height: viewport.height || "auto",
                zoom: zoomConfig.zoom
              });
              const newUi = __spreadProps(__spreadValues({}, ui), {
                viewports: __spreadProps(__spreadValues({}, ui.viewports), { current: uiViewport }),
                itemSelector: null
              });
              setUi(newUi);
              if (ZOOM_ON_CHANGE) {
                resetAutoZoom(newUi);
              }
            },
            onZoom: (zoom) => {
              setShowTransition(true);
              setZoomConfig(__spreadProps(__spreadValues({}, zoomConfig), { zoom }));
            }
          }
        ) }),
        (0, import_jsx_runtime39.jsxs)("div", { className: getClassName26("inner"), ref: frameRef, children: [
          (0, import_jsx_runtime39.jsx)(
            "div",
            {
              className: getClassName26("root"),
              style: {
                width: iframe.enabled ? ui.viewports.current.width : "100%",
                height: zoomConfig.rootHeight,
                transform: iframe.enabled ? `scale(${zoomConfig.zoom})` : void 0,
                transition: showTransition ? "width 150ms ease-out, height 150ms ease-out, transform 150ms ease-out" : "",
                overflow: iframe.enabled ? void 0 : "auto"
              },
              suppressHydrationWarning: true,
              id: "puck-canvas-root",
              onTransitionEnd: () => {
                window.dispatchEvent(
                  new CustomEvent("viewportchange", {
                    bubbles: true,
                    cancelable: false
                  })
                );
              },
              children: (0, import_jsx_runtime39.jsx)(CustomPreview, { children: (0, import_jsx_runtime39.jsx)(Preview2, {}) })
            }
          ),
          (0, import_jsx_runtime39.jsx)("div", { className: getClassName26("loader"), children: (0, import_jsx_runtime39.jsx)(Loader, { size: 24 }) })
        ] })
      ]
    }
  );
};
init_react_import();
init_react_import();
var loadOverrides = ({
  overrides,
  plugins
}) => {
  const collected = __spreadValues({}, overrides);
  plugins == null ? void 0 : plugins.forEach((plugin) => {
    Object.keys(plugin.overrides).forEach((_overridesType) => {
      const overridesType = _overridesType;
      if (overridesType === "fieldTypes") {
        const fieldTypes = plugin.overrides.fieldTypes;
        Object.keys(fieldTypes).forEach((fieldType) => {
          collected.fieldTypes = collected.fieldTypes || {};
          const childNode2 = collected.fieldTypes[fieldType];
          const Comp2 = (props) => fieldTypes[fieldType](__spreadProps(__spreadValues({}, props), {
            children: childNode2 ? childNode2(props) : props.children
          }));
          collected.fieldTypes[fieldType] = Comp2;
        });
        return;
      }
      const childNode = collected[overridesType];
      const Comp = (props) => plugin.overrides[overridesType](__spreadProps(__spreadValues({}, props), {
        children: childNode ? childNode(props) : props.children
      }));
      collected[overridesType] = Comp;
    });
  });
  return collected;
};
var useLoadedOverrides = ({
  overrides,
  plugins
}) => {
  return (0, import_react57.useMemo)(() => {
    return loadOverrides({ overrides, plugins });
  }, [plugins, overrides]);
};
init_react_import();
var DefaultOverride = ({ children }) => (0, import_jsx_runtime40.jsx)(import_jsx_runtime40.Fragment, { children });
init_react_import();
var styles = ``;
var useInjectStyleSheet = (initialStyles, iframeEnabled) => {
  const [el, setEl] = (0, import_react58.useState)();
  (0, import_react58.useEffect)(() => {
    setEl(document.createElement("style"));
  }, []);
  (0, import_react58.useEffect)(() => {
    var _a3;
    if (!el || typeof window === "undefined") {
      return;
    }
    el.innerHTML = initialStyles;
    if (iframeEnabled) {
      const frame = getFrame();
      (_a3 = frame == null ? void 0 : frame.head) == null ? void 0 : _a3.appendChild(el);
    }
    document.head.appendChild(el);
  }, [iframeEnabled, el]);
  return el;
};
var useInjectGlobalCss = (iframeEnabled) => {
  return useInjectStyleSheet(styles, iframeEnabled);
};
init_react_import();
var usePreviewModeHotkeys = (dispatch, iframeEnabled) => {
  const toggleInteractive = (0, import_react59.useCallback)(() => {
    dispatch({
      type: "setUi",
      ui: (ui) => ({
        previewMode: ui.previewMode === "edit" ? "interactive" : "edit"
      })
    });
  }, [dispatch]);
  const toggleInteractiveIframe = () => {
    if (iframeEnabled) {
      toggleInteractive();
    }
  };
  const frame = getFrame();
  const resolvedFrame = typeof window !== "undefined" && frame !== document ? frame : void 0;
  useHotkeys("meta+i", toggleInteractive, { preventDefault: true });
  useHotkeys("meta+i", toggleInteractiveIframe, {
    preventDefault: true,
    document: resolvedFrame
  });
  useHotkeys("ctrl+i", toggleInteractive, { preventDefault: true });
  useHotkeys("ctrl+i", toggleInteractiveIframe, {
    preventDefault: true,
    document: resolvedFrame
  });
};
var getClassName27 = get_class_name_factory_default("Puck", styles_module_default15);
var getLayoutClassName = get_class_name_factory_default("PuckLayout", styles_module_default15);
function Puck({
  children,
  config,
  data: initialData,
  ui: initialUi,
  onChange,
  onPublish,
  onAction,
  permissions = {},
  plugins,
  overrides,
  renderHeader,
  renderHeaderActions,
  headerTitle,
  headerPath,
  viewports = defaultViewports,
  iframe: _iframe,
  dnd,
  initialHistory: _initialHistory
}) {
  var _a3, _b2;
  const iframe = __spreadValues({
    enabled: true,
    waitForStyles: true
  }, _iframe);
  useInjectGlobalCss(iframe.enabled);
  const [generatedAppState] = (0, import_react42.useState)(() => {
    var _a22, _b22, _c4, _d2, _e, _f, _g, _h, _i;
    const initial = __spreadValues(__spreadValues({}, defaultAppState.ui), initialUi);
    let clientUiState = {};
    if (typeof window !== "undefined") {
      if (window.matchMedia("(max-width: 638px)").matches) {
        clientUiState = __spreadProps(__spreadValues({}, clientUiState), {
          leftSideBarVisible: false,
          rightSideBarVisible: false
        });
      }
      const viewportWidth = window.innerWidth;
      const viewportDifferences = Object.entries(viewports).map(([key, value]) => ({
        key,
        diff: Math.abs(viewportWidth - value.width)
      })).sort((a2, b2) => a2.diff > b2.diff ? 1 : -1);
      const closestViewport = viewportDifferences[0].key;
      if (iframe.enabled) {
        clientUiState = __spreadProps(__spreadValues({}, clientUiState), {
          viewports: __spreadProps(__spreadValues({}, initial.viewports), {
            current: __spreadProps(__spreadValues({}, initial.viewports.current), {
              height: ((_b22 = (_a22 = initialUi == null ? void 0 : initialUi.viewports) == null ? void 0 : _a22.current) == null ? void 0 : _b22.height) || ((_c4 = viewports[closestViewport]) == null ? void 0 : _c4.height) || "auto",
              width: ((_e = (_d2 = initialUi == null ? void 0 : initialUi.viewports) == null ? void 0 : _d2.current) == null ? void 0 : _e.width) || ((_f = viewports[closestViewport]) == null ? void 0 : _f.width)
            })
          })
        });
      }
    }
    if (Object.keys((initialData == null ? void 0 : initialData.root) || {}).length > 0 && !((_g = initialData == null ? void 0 : initialData.root) == null ? void 0 : _g.props)) {
      console.error(
        "Warning: Defining props on `root` is deprecated. Please use `root.props`, or republish this page to migrate automatically."
      );
    }
    const rootProps2 = ((_h = initialData == null ? void 0 : initialData.root) == null ? void 0 : _h.props) || (initialData == null ? void 0 : initialData.root) || {};
    const defaultedRootProps = __spreadValues(__spreadValues({}, (_i = config.root) == null ? void 0 : _i.defaultProps), rootProps2);
    return __spreadProps(__spreadValues({}, defaultAppState), {
      data: __spreadProps(__spreadValues({}, initialData), {
        root: __spreadProps(__spreadValues({}, initialData == null ? void 0 : initialData.root), { props: defaultedRootProps }),
        content: initialData.content || []
      }),
      ui: __spreadProps(__spreadValues(__spreadValues({}, initial), clientUiState), {
        // Store categories under componentList on state to allow render functions and plugins to modify
        componentList: config.categories ? Object.entries(config.categories).reduce(
          (acc, [categoryName, category]) => {
            return __spreadProps(__spreadValues({}, acc), {
              [categoryName]: {
                title: category.title,
                components: category.components,
                expanded: category.defaultExpanded,
                visible: category.visible
              }
            });
          },
          {}
        ) : {}
      })
    });
  });
  const { appendData = true } = _initialHistory || {};
  const histories = [
    ...(_initialHistory == null ? void 0 : _initialHistory.histories) || [],
    ...appendData ? [{ state: generatedAppState }] : []
  ].map((history2) => __spreadProps(__spreadValues({}, history2), {
    // Inject default data to enable partial history injections
    state: __spreadValues(__spreadValues({}, generatedAppState), history2.state)
  }));
  const initialHistoryIndex = (_initialHistory == null ? void 0 : _initialHistory.index) || histories.length - 1;
  const initialAppState = histories[initialHistoryIndex].state;
  const historyStore = useHistoryStore({
    histories,
    index: initialHistoryIndex
  });
  const [reducer] = (0, import_react42.useState)(
    () => createReducer({
      config,
      record: historyStore.record,
      onAction
    })
  );
  const [appState, dispatch] = (0, import_react42.useReducer)(
    reducer,
    flushZones(initialAppState)
  );
  const { data, ui } = appState;
  const history = usePuckHistory({
    dispatch,
    initialAppState,
    historyStore,
    iframeEnabled: (_a3 = _iframe == null ? void 0 : _iframe.enabled) != null ? _a3 : true
  });
  const [menuOpen, setMenuOpen] = (0, import_react42.useState)(false);
  const { itemSelector, leftSideBarVisible, rightSideBarVisible } = ui;
  const selectedItem = itemSelector ? getItem(itemSelector, data) : null;
  (0, import_react42.useEffect)(() => {
    if (onChange) onChange(data);
  }, [data]);
  const rootProps = data.root.props || data.root;
  const toggleSidebars = (0, import_react42.useCallback)(
    (sidebar) => {
      const widerViewport = window.matchMedia("(min-width: 638px)").matches;
      const sideBarVisible = sidebar === "left" ? leftSideBarVisible : rightSideBarVisible;
      const oppositeSideBar = sidebar === "left" ? "rightSideBarVisible" : "leftSideBarVisible";
      dispatch({
        type: "setUi",
        ui: __spreadValues({
          [`${sidebar}SideBarVisible`]: !sideBarVisible
        }, !widerViewport ? { [oppositeSideBar]: false } : {})
      });
    },
    [dispatch, leftSideBarVisible, rightSideBarVisible]
  );
  (0, import_react42.useEffect)(() => {
    if (!window.matchMedia("(min-width: 638px)").matches) {
      dispatch({
        type: "setUi",
        ui: {
          leftSideBarVisible: false,
          rightSideBarVisible: false
        }
      });
    }
    const handleResize = () => {
      if (!window.matchMedia("(min-width: 638px)").matches) {
        dispatch({
          type: "setUi",
          ui: (ui2) => __spreadValues(__spreadValues({}, ui2), ui2.rightSideBarVisible ? { leftSideBarVisible: false } : {})
        });
      }
    };
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  const defaultHeaderRender = (0, import_react42.useMemo)(() => {
    if (renderHeader) {
      console.warn(
        "`renderHeader` is deprecated. Please use `overrides.header` and the `usePuck` hook instead"
      );
      const RenderHeader = (_a22) => {
        var _b22 = _a22, { actions } = _b22, props = __objRest(_b22, ["actions"]);
        const Comp = renderHeader;
        return (0, import_jsx_runtime41.jsx)(Comp, __spreadProps(__spreadValues({}, props), { dispatch, state: appState, children: actions }));
      };
      return RenderHeader;
    }
    return DefaultOverride;
  }, [renderHeader]);
  const defaultHeaderActionsRender = (0, import_react42.useMemo)(() => {
    if (renderHeaderActions) {
      console.warn(
        "`renderHeaderActions` is deprecated. Please use `overrides.headerActions` and the `usePuck` hook instead."
      );
      const RenderHeader = (props) => {
        const Comp = renderHeaderActions;
        return (0, import_jsx_runtime41.jsx)(Comp, __spreadProps(__spreadValues({}, props), { dispatch, state: appState }));
      };
      return RenderHeader;
    }
    return DefaultOverride;
  }, [renderHeader]);
  const loadedOverrides = useLoadedOverrides({
    overrides,
    plugins
  });
  const CustomPuck = (0, import_react42.useMemo)(
    () => loadedOverrides.puck || DefaultOverride,
    [loadedOverrides]
  );
  const CustomHeader = (0, import_react42.useMemo)(
    () => loadedOverrides.header || defaultHeaderRender,
    [loadedOverrides]
  );
  const CustomHeaderActions = (0, import_react42.useMemo)(
    () => loadedOverrides.headerActions || defaultHeaderActionsRender,
    [loadedOverrides]
  );
  const [mounted, setMounted] = (0, import_react42.useState)(false);
  (0, import_react42.useEffect)(() => {
    setMounted(true);
  }, []);
  const selectedComponentConfig = selectedItem && config.components[selectedItem.type];
  const selectedComponentLabel = selectedItem ? (_b2 = selectedComponentConfig == null ? void 0 : selectedComponentConfig["label"]) != null ? _b2 : selectedItem.type.toString() : "";
  usePreviewModeHotkeys(dispatch, iframe.enabled);
  return (0, import_jsx_runtime41.jsxs)("div", { className: `Puck ${getClassName27()}`, children: [
    (0, import_jsx_runtime41.jsx)(
      AppProvider,
      {
        value: {
          state: appState,
          dispatch,
          config,
          plugins: plugins || [],
          overrides: loadedOverrides,
          history,
          viewports,
          iframe,
          globalPermissions: __spreadValues({
            delete: true,
            drag: true,
            duplicate: true,
            insert: true,
            edit: true
          }, permissions),
          getPermissions: () => ({}),
          refreshPermissions: () => null
        },
        children: (0, import_jsx_runtime41.jsx)(DragDropContext2, { disableAutoScroll: dnd == null ? void 0 : dnd.disableAutoScroll, children: (0, import_jsx_runtime41.jsx)(CustomPuck, { children: children || (0, import_jsx_runtime41.jsx)(
          "div",
          {
            className: getLayoutClassName({
              leftSideBarVisible,
              menuOpen,
              mounted,
              rightSideBarVisible
            }),
            children: (0, import_jsx_runtime41.jsxs)("div", { className: getLayoutClassName("inner"), children: [
              (0, import_jsx_runtime41.jsx)(
                CustomHeader,
                {
                  actions: (0, import_jsx_runtime41.jsx)(import_jsx_runtime41.Fragment, { children: (0, import_jsx_runtime41.jsx)(CustomHeaderActions, { children: (0, import_jsx_runtime41.jsx)(
                    Button,
                    {
                      onClick: () => {
                        onPublish && onPublish(data);
                      },
                      icon: (0, import_jsx_runtime41.jsx)(Globe, { size: "14px" }),
                      children: "Publish"
                    }
                  ) }) }),
                  children: (0, import_jsx_runtime41.jsx)("header", { className: getLayoutClassName("header"), children: (0, import_jsx_runtime41.jsxs)("div", { className: getLayoutClassName("headerInner"), children: [
                    (0, import_jsx_runtime41.jsxs)("div", { className: getLayoutClassName("headerToggle"), children: [
                      (0, import_jsx_runtime41.jsx)(
                        "div",
                        {
                          className: getLayoutClassName("leftSideBarToggle"),
                          children: (0, import_jsx_runtime41.jsx)(
                            IconButton,
                            {
                              onClick: () => {
                                toggleSidebars("left");
                              },
                              title: "Toggle left sidebar",
                              children: (0, import_jsx_runtime41.jsx)(PanelLeft, { focusable: "false" })
                            }
                          )
                        }
                      ),
                      (0, import_jsx_runtime41.jsx)(
                        "div",
                        {
                          className: getLayoutClassName("rightSideBarToggle"),
                          children: (0, import_jsx_runtime41.jsx)(
                            IconButton,
                            {
                              onClick: () => {
                                toggleSidebars("right");
                              },
                              title: "Toggle right sidebar",
                              children: (0, import_jsx_runtime41.jsx)(PanelRight, { focusable: "false" })
                            }
                          )
                        }
                      )
                    ] }),
                    (0, import_jsx_runtime41.jsx)("div", { className: getLayoutClassName("headerTitle"), children: (0, import_jsx_runtime41.jsxs)(Heading, { rank: "2", size: "xs", children: [
                      headerTitle || rootProps.title || "Page",
                      headerPath && (0, import_jsx_runtime41.jsxs)(import_jsx_runtime41.Fragment, { children: [
                        " ",
                        (0, import_jsx_runtime41.jsx)(
                          "code",
                          {
                            className: getLayoutClassName("headerPath"),
                            children: headerPath
                          }
                        )
                      ] })
                    ] }) }),
                    (0, import_jsx_runtime41.jsxs)("div", { className: getLayoutClassName("headerTools"), children: [
                      (0, import_jsx_runtime41.jsx)("div", { className: getLayoutClassName("menuButton"), children: (0, import_jsx_runtime41.jsx)(
                        IconButton,
                        {
                          onClick: () => {
                            return setMenuOpen(!menuOpen);
                          },
                          title: "Toggle menu bar",
                          children: menuOpen ? (0, import_jsx_runtime41.jsx)(ChevronUp, { focusable: "false" }) : (0, import_jsx_runtime41.jsx)(ChevronDown, { focusable: "false" })
                        }
                      ) }),
                      (0, import_jsx_runtime41.jsx)(
                        MenuBar,
                        {
                          appState,
                          dispatch,
                          onPublish,
                          menuOpen,
                          renderHeaderActions: () => (0, import_jsx_runtime41.jsx)(CustomHeaderActions, { children: (0, import_jsx_runtime41.jsx)(
                            Button,
                            {
                              onClick: () => {
                                onPublish && onPublish(data);
                              },
                              icon: (0, import_jsx_runtime41.jsx)(Globe, { size: "14px" }),
                              children: "Publish"
                            }
                          ) }),
                          setMenuOpen
                        }
                      )
                    ] })
                  ] }) })
                }
              ),
              (0, import_jsx_runtime41.jsxs)("div", { className: getLayoutClassName("leftSideBar"), children: [
                (0, import_jsx_runtime41.jsx)(SidebarSection, { title: "Components", noBorderTop: true, children: (0, import_jsx_runtime41.jsx)(Components, {}) }),
                (0, import_jsx_runtime41.jsx)(SidebarSection, { title: "Outline", children: (0, import_jsx_runtime41.jsx)(Outline, {}) })
              ] }),
              (0, import_jsx_runtime41.jsx)(Canvas, {}),
              (0, import_jsx_runtime41.jsx)("div", { className: getLayoutClassName("rightSideBar"), children: (0, import_jsx_runtime41.jsx)(
                SidebarSection,
                {
                  noPadding: true,
                  noBorderTop: true,
                  showBreadcrumbs: true,
                  title: selectedItem ? selectedComponentLabel : "Page",
                  children: (0, import_jsx_runtime41.jsx)(Fields, {})
                }
              ) })
            ] })
          }
        ) }) })
      }
    ),
    (0, import_jsx_runtime41.jsx)("div", { id: "puck-portal-root", className: getClassName27("portal") })
  ] });
}
Puck.Components = Components;
Puck.Fields = Fields;
Puck.Outline = Outline;
Puck.Preview = Preview2;
init_react_import();
var migrations = [
  // Migrate root to root.props
  (data) => {
    const rootProps = data.root.props || data.root;
    if (Object.keys(data.root).length > 0 && !data.root.props) {
      console.warn(
        "Migration applied: Root props moved from `root` to `root.props`."
      );
      return __spreadProps(__spreadValues({}, data), {
        root: {
          props: __spreadValues({}, rootProps)
        }
      });
    }
    return data;
  }
];
function migrate(data) {
  return migrations == null ? void 0 : migrations.reduce((acc, migration) => migration(acc), data);
}
init_react_import();
function transformProps(data, propTransforms) {
  const mapItem = (item) => {
    if (propTransforms[item.type]) {
      return __spreadProps(__spreadValues({}, item), {
        props: propTransforms[item.type](item.props)
      });
    }
    return item;
  };
  const defaultedData = defaultData(data);
  const rootProps = defaultedData.root.props || defaultedData.root;
  let newRoot = __spreadValues({}, defaultedData.root);
  if (propTransforms["root"]) {
    if (defaultedData.root.props) {
      newRoot.props = propTransforms["root"](rootProps);
    } else {
      newRoot = propTransforms["root"](rootProps);
    }
  }
  const afterPropTransforms = __spreadProps(__spreadValues({}, defaultedData), {
    root: newRoot,
    content: defaultedData.content.map(mapItem),
    zones: Object.keys(data.zones || {}).reduce(
      (acc, zoneKey) => __spreadProps(__spreadValues({}, acc), {
        [zoneKey]: data.zones[zoneKey].map(mapItem)
      }),
      {}
    )
  });
  return afterPropTransforms;
}
init_react_import();
var usePuck = () => {
  const {
    state: appState,
    config,
    history,
    dispatch,
    selectedItem: currentItem,
    getPermissions,
    refreshPermissions
  } = useAppContext();
  if (dispatch === defaultContext.dispatch) {
    throw new Error(
      "usePuck was used outside of the <Puck> component. The usePuck hook must be rendered within the <Puck> context as children, overrides or plugins as described in https://puckeditor.com/docs/api-reference/functions/use-puck."
    );
  }
  return {
    appState,
    config,
    dispatch,
    getPermissions,
    refreshPermissions,
    history: {
      back: history.back,
      forward: history.forward,
      setHistories: history.setHistories,
      setHistoryIndex: history.setHistoryIndex,
      hasPast: history.historyStore.hasPast,
      hasFuture: history.historyStore.hasFuture,
      histories: history.historyStore.histories,
      index: history.historyStore.index,
      historyStore: history.historyStore
    },
    selectedItem: currentItem || null
  };
};
export {
  Action,
  ActionBar,
  AutoField,
  Button,
  Drawer,
  DropZone,
  FieldLabel,
  Group,
  IconButton,
  Label,
  Puck,
  Render,
  migrate,
  overrideKeys,
  resolveAllData,
  transformProps,
  usePuck
};
/*! Bundled license information:

@measured/puck/dist/index.mjs:
  (*! Bundled license information:
  
  classnames/index.js:
    (*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    *)
  
  lucide-react/dist/esm/shared/src/utils.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/defaultAttributes.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/Icon.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/createLucideIcon.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/chevron-down.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/chevron-right.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/chevron-up.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/circle-check-big.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/copy.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/corner-left-up.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/ellipsis-vertical.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/globe.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/hash.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/layers.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/layout-grid.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/link.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/list.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/lock-open.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/lock.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/monitor.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/panel-left.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/panel-right.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/plus.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/redo-2.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/search.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/sliders-horizontal.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/smartphone.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/tablet.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/trash.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/type.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/undo-2.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/zoom-in.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/zoom-out.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/lucide-react.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  *)
*/
//# sourceMappingURL=@measured_puck.js.map
